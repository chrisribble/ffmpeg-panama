// Generated by jextract

package io.github.chrisribble.ffmpeg8;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class FFmpeg_3 {

    FFmpeg_3() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("avcodec"), LIBRARY_ARENA)
            .or(SymbolLookup.libraryLookup(System.mapLibraryName("avformat"), LIBRARY_ARENA))
            .or(SymbolLookup.libraryLookup(System.mapLibraryName("avutil"), LIBRARY_ARENA))
            .or(SymbolLookup.libraryLookup(System.mapLibraryName("swscale"), LIBRARY_ARENA))
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2Y = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2Y 0
     * }
     */
    public static int __GLIBC_USE_ISOC2Y() {
        return __GLIBC_USE_ISOC2Y;
    }
    private static final int __GLIBC_USE_ISOC23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC23 0
     * }
     */
    public static int __GLIBC_USE_ISOC23() {
        return __GLIBC_USE_ISOC23;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_TIME_BITS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_TIME_BITS64 1
     * }
     */
    public static int __USE_TIME_BITS64() {
        return __USE_TIME_BITS64;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C23_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C23_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C23_STRTOL() {
        return __GLIBC_USE_C23_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)41L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 41
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C23 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C23() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C23;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C23() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C23;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _BITS_STDINT_LEAST_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_LEAST_H 1
     * }
     */
    public static int _BITS_STDINT_LEAST_H() {
        return _BITS_STDINT_LEAST_H;
    }
    private static final int FF_LAMBDA_SHIFT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_LAMBDA_SHIFT 7
     * }
     */
    public static int FF_LAMBDA_SHIFT() {
        return FF_LAMBDA_SHIFT;
    }
    private static final int FF_QP2LAMBDA = (int)118L;
    /**
     * {@snippet lang=c :
     * #define FF_QP2LAMBDA 118
     * }
     */
    public static int FF_QP2LAMBDA() {
        return FF_QP2LAMBDA;
    }
    private static final int AV_TIME_BASE = (int)1000000L;
    /**
     * {@snippet lang=c :
     * #define AV_TIME_BASE 1000000
     * }
     */
    public static int AV_TIME_BASE() {
        return AV_TIME_BASE;
    }
    private static final int _ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ERRNO_H 1
     * }
     */
    public static int _ERRNO_H() {
        return _ERRNO_H;
    }
    private static final int _BITS_ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ERRNO_H 1
     * }
     */
    public static int _BITS_ERRNO_H() {
        return _BITS_ERRNO_H;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int ENOTBLK = (int)15L;
    /**
     * {@snippet lang=c :
     * #define ENOTBLK 15
     * }
     */
    public static int ENOTBLK() {
        return ENOTBLK;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int ETXTBSY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 26
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EDEADLK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 35
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)36L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 36
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)37L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 37
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 38
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 39
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int ELOOP = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 40
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int ENOMSG = (int)42L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 42
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int EIDRM = (int)43L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 43
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int ECHRNG = (int)44L;
    /**
     * {@snippet lang=c :
     * #define ECHRNG 44
     * }
     */
    public static int ECHRNG() {
        return ECHRNG;
    }
    private static final int EL2NSYNC = (int)45L;
    /**
     * {@snippet lang=c :
     * #define EL2NSYNC 45
     * }
     */
    public static int EL2NSYNC() {
        return EL2NSYNC;
    }
    private static final int EL3HLT = (int)46L;
    /**
     * {@snippet lang=c :
     * #define EL3HLT 46
     * }
     */
    public static int EL3HLT() {
        return EL3HLT;
    }
    private static final int EL3RST = (int)47L;
    /**
     * {@snippet lang=c :
     * #define EL3RST 47
     * }
     */
    public static int EL3RST() {
        return EL3RST;
    }
    private static final int ELNRNG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define ELNRNG 48
     * }
     */
    public static int ELNRNG() {
        return ELNRNG;
    }
    private static final int EUNATCH = (int)49L;
    /**
     * {@snippet lang=c :
     * #define EUNATCH 49
     * }
     */
    public static int EUNATCH() {
        return EUNATCH;
    }
    private static final int ENOCSI = (int)50L;
    /**
     * {@snippet lang=c :
     * #define ENOCSI 50
     * }
     */
    public static int ENOCSI() {
        return ENOCSI;
    }
    private static final int EL2HLT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define EL2HLT 51
     * }
     */
    public static int EL2HLT() {
        return EL2HLT;
    }
    private static final int EBADE = (int)52L;
    /**
     * {@snippet lang=c :
     * #define EBADE 52
     * }
     */
    public static int EBADE() {
        return EBADE;
    }
    private static final int EBADR = (int)53L;
    /**
     * {@snippet lang=c :
     * #define EBADR 53
     * }
     */
    public static int EBADR() {
        return EBADR;
    }
    private static final int EXFULL = (int)54L;
    /**
     * {@snippet lang=c :
     * #define EXFULL 54
     * }
     */
    public static int EXFULL() {
        return EXFULL;
    }
    private static final int ENOANO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define ENOANO 55
     * }
     */
    public static int ENOANO() {
        return ENOANO;
    }
    private static final int EBADRQC = (int)56L;
    /**
     * {@snippet lang=c :
     * #define EBADRQC 56
     * }
     */
    public static int EBADRQC() {
        return EBADRQC;
    }
    private static final int EBADSLT = (int)57L;
    /**
     * {@snippet lang=c :
     * #define EBADSLT 57
     * }
     */
    public static int EBADSLT() {
        return EBADSLT;
    }
    private static final int EBFONT = (int)59L;
    /**
     * {@snippet lang=c :
     * #define EBFONT 59
     * }
     */
    public static int EBFONT() {
        return EBFONT;
    }
    private static final int ENOSTR = (int)60L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 60
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENODATA = (int)61L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 61
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ETIME = (int)62L;
    /**
     * {@snippet lang=c :
     * #define ETIME 62
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ENOSR = (int)63L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 63
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENONET = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ENONET 64
     * }
     */
    public static int ENONET() {
        return ENONET;
    }
    private static final int ENOPKG = (int)65L;
    /**
     * {@snippet lang=c :
     * #define ENOPKG 65
     * }
     */
    public static int ENOPKG() {
        return ENOPKG;
    }
    private static final int EREMOTE = (int)66L;
    /**
     * {@snippet lang=c :
     * #define EREMOTE 66
     * }
     */
    public static int EREMOTE() {
        return EREMOTE;
    }
    private static final int ENOLINK = (int)67L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 67
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int EADV = (int)68L;
    /**
     * {@snippet lang=c :
     * #define EADV 68
     * }
     */
    public static int EADV() {
        return EADV;
    }
    private static final int ESRMNT = (int)69L;
    /**
     * {@snippet lang=c :
     * #define ESRMNT 69
     * }
     */
    public static int ESRMNT() {
        return ESRMNT;
    }
    private static final int ECOMM = (int)70L;
    /**
     * {@snippet lang=c :
     * #define ECOMM 70
     * }
     */
    public static int ECOMM() {
        return ECOMM;
    }
    private static final int EPROTO = (int)71L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 71
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EMULTIHOP = (int)72L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 72
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int EDOTDOT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define EDOTDOT 73
     * }
     */
    public static int EDOTDOT() {
        return EDOTDOT;
    }
    private static final int EBADMSG = (int)74L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 74
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EOVERFLOW = (int)75L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 75
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int ENOTUNIQ = (int)76L;
    /**
     * {@snippet lang=c :
     * #define ENOTUNIQ 76
     * }
     */
    public static int ENOTUNIQ() {
        return ENOTUNIQ;
    }
    private static final int EBADFD = (int)77L;
    /**
     * {@snippet lang=c :
     * #define EBADFD 77
     * }
     */
    public static int EBADFD() {
        return EBADFD;
    }
    private static final int EREMCHG = (int)78L;
    /**
     * {@snippet lang=c :
     * #define EREMCHG 78
     * }
     */
    public static int EREMCHG() {
        return EREMCHG;
    }
    private static final int ELIBACC = (int)79L;
    /**
     * {@snippet lang=c :
     * #define ELIBACC 79
     * }
     */
    public static int ELIBACC() {
        return ELIBACC;
    }
    private static final int ELIBBAD = (int)80L;
    /**
     * {@snippet lang=c :
     * #define ELIBBAD 80
     * }
     */
    public static int ELIBBAD() {
        return ELIBBAD;
    }
    private static final int ELIBSCN = (int)81L;
    /**
     * {@snippet lang=c :
     * #define ELIBSCN 81
     * }
     */
    public static int ELIBSCN() {
        return ELIBSCN;
    }
    private static final int ELIBMAX = (int)82L;
    /**
     * {@snippet lang=c :
     * #define ELIBMAX 82
     * }
     */
    public static int ELIBMAX() {
        return ELIBMAX;
    }
    private static final int ELIBEXEC = (int)83L;
    /**
     * {@snippet lang=c :
     * #define ELIBEXEC 83
     * }
     */
    public static int ELIBEXEC() {
        return ELIBEXEC;
    }
    private static final int EILSEQ = (int)84L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 84
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int ERESTART = (int)85L;
    /**
     * {@snippet lang=c :
     * #define ERESTART 85
     * }
     */
    public static int ERESTART() {
        return ERESTART;
    }
    private static final int ESTRPIPE = (int)86L;
    /**
     * {@snippet lang=c :
     * #define ESTRPIPE 86
     * }
     */
    public static int ESTRPIPE() {
        return ESTRPIPE;
    }
    private static final int EUSERS = (int)87L;
    /**
     * {@snippet lang=c :
     * #define EUSERS 87
     * }
     */
    public static int EUSERS() {
        return EUSERS;
    }
    private static final int ENOTSOCK = (int)88L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 88
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int EDESTADDRREQ = (int)89L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 89
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EMSGSIZE = (int)90L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 90
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int EPROTOTYPE = (int)91L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 91
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ENOPROTOOPT = (int)92L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 92
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int EPROTONOSUPPORT = (int)93L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 93
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int ESOCKTNOSUPPORT = (int)94L;
    /**
     * {@snippet lang=c :
     * #define ESOCKTNOSUPPORT 94
     * }
     */
    public static int ESOCKTNOSUPPORT() {
        return ESOCKTNOSUPPORT;
    }
    private static final int EOPNOTSUPP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 95
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EPFNOSUPPORT = (int)96L;
    /**
     * {@snippet lang=c :
     * #define EPFNOSUPPORT 96
     * }
     */
    public static int EPFNOSUPPORT() {
        return EPFNOSUPPORT;
    }
    private static final int EAFNOSUPPORT = (int)97L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 97
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EADDRINUSE = (int)98L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 98
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)99L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 99
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int ENETDOWN = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 100
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETUNREACH = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 101
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENETRESET = (int)102L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 102
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ECONNABORTED = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 103
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNRESET = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 104
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int ENOBUFS = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 105
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int EISCONN = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 106
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ENOTCONN = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 107
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ESHUTDOWN = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ESHUTDOWN 108
     * }
     */
    public static int ESHUTDOWN() {
        return ESHUTDOWN;
    }
    private static final int ETOOMANYREFS = (int)109L;
    /**
     * {@snippet lang=c :
     * #define ETOOMANYREFS 109
     * }
     */
    public static int ETOOMANYREFS() {
        return ETOOMANYREFS;
    }
    private static final int ETIMEDOUT = (int)110L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 110
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ECONNREFUSED = (int)111L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 111
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int EHOSTDOWN = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EHOSTDOWN 112
     * }
     */
    public static int EHOSTDOWN() {
        return EHOSTDOWN;
    }
    private static final int EHOSTUNREACH = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 113
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EALREADY = (int)114L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 114
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EINPROGRESS = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 115
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int ESTALE = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ESTALE 116
     * }
     */
    public static int ESTALE() {
        return ESTALE;
    }
    private static final int EUCLEAN = (int)117L;
    /**
     * {@snippet lang=c :
     * #define EUCLEAN 117
     * }
     */
    public static int EUCLEAN() {
        return EUCLEAN;
    }
    private static final int ENOTNAM = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENOTNAM 118
     * }
     */
    public static int ENOTNAM() {
        return ENOTNAM;
    }
    private static final int ENAVAIL = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENAVAIL 119
     * }
     */
    public static int ENAVAIL() {
        return ENAVAIL;
    }
    private static final int EISNAM = (int)120L;
    /**
     * {@snippet lang=c :
     * #define EISNAM 120
     * }
     */
    public static int EISNAM() {
        return EISNAM;
    }
    private static final int EREMOTEIO = (int)121L;
    /**
     * {@snippet lang=c :
     * #define EREMOTEIO 121
     * }
     */
    public static int EREMOTEIO() {
        return EREMOTEIO;
    }
    private static final int EDQUOT = (int)122L;
    /**
     * {@snippet lang=c :
     * #define EDQUOT 122
     * }
     */
    public static int EDQUOT() {
        return EDQUOT;
    }
    private static final int ENOMEDIUM = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOMEDIUM 123
     * }
     */
    public static int ENOMEDIUM() {
        return ENOMEDIUM;
    }
    private static final int EMEDIUMTYPE = (int)124L;
    /**
     * {@snippet lang=c :
     * #define EMEDIUMTYPE 124
     * }
     */
    public static int EMEDIUMTYPE() {
        return EMEDIUMTYPE;
    }
    private static final int ECANCELED = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 125
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ENOKEY = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOKEY 126
     * }
     */
    public static int ENOKEY() {
        return ENOKEY;
    }
    private static final int EKEYEXPIRED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define EKEYEXPIRED 127
     * }
     */
    public static int EKEYEXPIRED() {
        return EKEYEXPIRED;
    }
    private static final int EKEYREVOKED = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EKEYREVOKED 128
     * }
     */
    public static int EKEYREVOKED() {
        return EKEYREVOKED;
    }
    private static final int EKEYREJECTED = (int)129L;
    /**
     * {@snippet lang=c :
     * #define EKEYREJECTED 129
     * }
     */
    public static int EKEYREJECTED() {
        return EKEYREJECTED;
    }
    private static final int EOWNERDEAD = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 130
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int ENOTRECOVERABLE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 131
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ERFKILL = (int)132L;
    /**
     * {@snippet lang=c :
     * #define ERFKILL 132
     * }
     */
    public static int ERFKILL() {
        return ERFKILL;
    }
    private static final int EHWPOISON = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EHWPOISON 133
     * }
     */
    public static int EHWPOISON() {
        return EHWPOISON;
    }
    private static final int _INTTYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _INTTYPES_H 1
     * }
     */
    public static int _INTTYPES_H() {
        return _INTTYPES_H;
    }
    private static final int ____gwchar_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____gwchar_t_defined 1
     * }
     */
    public static int ____gwchar_t_defined() {
        return ____gwchar_t_defined;
    }
    private static final int _LIBC_LIMITS_H_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _LIBC_LIMITS_H_ 1
     * }
     */
    public static int _LIBC_LIMITS_H_() {
        return _LIBC_LIMITS_H_;
    }
    private static final int MB_LEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 16
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int _BITS_POSIX1_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX1_LIM_H 1
     * }
     */
    public static int _BITS_POSIX1_LIM_H() {
        return _BITS_POSIX1_LIM_H;
    }
    private static final int _POSIX_AIO_LISTIO_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_LISTIO_MAX 2
     * }
     */
    public static int _POSIX_AIO_LISTIO_MAX() {
        return _POSIX_AIO_LISTIO_MAX;
    }
    private static final int _POSIX_AIO_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_MAX 1
     * }
     */
    public static int _POSIX_AIO_MAX() {
        return _POSIX_AIO_MAX;
    }
    private static final int _POSIX_ARG_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ARG_MAX 4096
     * }
     */
    public static int _POSIX_ARG_MAX() {
        return _POSIX_ARG_MAX;
    }
    private static final int _POSIX_CHILD_MAX = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHILD_MAX 25
     * }
     */
    public static int _POSIX_CHILD_MAX() {
        return _POSIX_CHILD_MAX;
    }
    private static final int _POSIX_DELAYTIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_DELAYTIMER_MAX 32
     * }
     */
    public static int _POSIX_DELAYTIMER_MAX() {
        return _POSIX_DELAYTIMER_MAX;
    }
    private static final int _POSIX_HOST_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_HOST_NAME_MAX 255
     * }
     */
    public static int _POSIX_HOST_NAME_MAX() {
        return _POSIX_HOST_NAME_MAX;
    }
    private static final int _POSIX_LINK_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LINK_MAX 8
     * }
     */
    public static int _POSIX_LINK_MAX() {
        return _POSIX_LINK_MAX;
    }
    private static final int _POSIX_LOGIN_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LOGIN_NAME_MAX 9
     * }
     */
    public static int _POSIX_LOGIN_NAME_MAX() {
        return _POSIX_LOGIN_NAME_MAX;
    }
    private static final int _POSIX_MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_CANON 255
     * }
     */
    public static int _POSIX_MAX_CANON() {
        return _POSIX_MAX_CANON;
    }
    private static final int _POSIX_MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_INPUT 255
     * }
     */
    public static int _POSIX_MAX_INPUT() {
        return _POSIX_MAX_INPUT;
    }
    private static final int _POSIX_MQ_OPEN_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_OPEN_MAX 8
     * }
     */
    public static int _POSIX_MQ_OPEN_MAX() {
        return _POSIX_MQ_OPEN_MAX;
    }
    private static final int _POSIX_MQ_PRIO_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_PRIO_MAX 32
     * }
     */
    public static int _POSIX_MQ_PRIO_MAX() {
        return _POSIX_MQ_PRIO_MAX;
    }
    private static final int _POSIX_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NAME_MAX 14
     * }
     */
    public static int _POSIX_NAME_MAX() {
        return _POSIX_NAME_MAX;
    }
    private static final int _POSIX_NGROUPS_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NGROUPS_MAX 8
     * }
     */
    public static int _POSIX_NGROUPS_MAX() {
        return _POSIX_NGROUPS_MAX;
    }
    private static final int _POSIX_OPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_OPEN_MAX 20
     * }
     */
    public static int _POSIX_OPEN_MAX() {
        return _POSIX_OPEN_MAX;
    }
    private static final int _POSIX_PATH_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PATH_MAX 256
     * }
     */
    public static int _POSIX_PATH_MAX() {
        return _POSIX_PATH_MAX;
    }
    private static final int _POSIX_PIPE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PIPE_BUF 512
     * }
     */
    public static int _POSIX_PIPE_BUF() {
        return _POSIX_PIPE_BUF;
    }
    private static final int _POSIX_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }
    private static final int _POSIX_RTSIG_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RTSIG_MAX 8
     * }
     */
    public static int _POSIX_RTSIG_MAX() {
        return _POSIX_RTSIG_MAX;
    }
    private static final int _POSIX_SEM_NSEMS_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_NSEMS_MAX 256
     * }
     */
    public static int _POSIX_SEM_NSEMS_MAX() {
        return _POSIX_SEM_NSEMS_MAX;
    }
    private static final int _POSIX_SEM_VALUE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_VALUE_MAX 32767
     * }
     */
    public static int _POSIX_SEM_VALUE_MAX() {
        return _POSIX_SEM_VALUE_MAX;
    }
    private static final int _POSIX_SIGQUEUE_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SIGQUEUE_MAX 32
     * }
     */
    public static int _POSIX_SIGQUEUE_MAX() {
        return _POSIX_SIGQUEUE_MAX;
    }
    private static final int _POSIX_SSIZE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SSIZE_MAX 32767
     * }
     */
    public static int _POSIX_SSIZE_MAX() {
        return _POSIX_SSIZE_MAX;
    }
    private static final int _POSIX_STREAM_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_STREAM_MAX 8
     * }
     */
    public static int _POSIX_STREAM_MAX() {
        return _POSIX_STREAM_MAX;
    }
    private static final int _POSIX_SYMLINK_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLINK_MAX 255
     * }
     */
    public static int _POSIX_SYMLINK_MAX() {
        return _POSIX_SYMLINK_MAX;
    }
    private static final int _POSIX_SYMLOOP_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLOOP_MAX 8
     * }
     */
    public static int _POSIX_SYMLOOP_MAX() {
        return _POSIX_SYMLOOP_MAX;
    }
    private static final int _POSIX_TIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMER_MAX 32
     * }
     */
    public static int _POSIX_TIMER_MAX() {
        return _POSIX_TIMER_MAX;
    }
    private static final int _POSIX_TTY_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TTY_NAME_MAX 9
     * }
     */
    public static int _POSIX_TTY_NAME_MAX() {
        return _POSIX_TTY_NAME_MAX;
    }
    private static final int _POSIX_TZNAME_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TZNAME_MAX 6
     * }
     */
    public static int _POSIX_TZNAME_MAX() {
        return _POSIX_TZNAME_MAX;
    }
    private static final int _POSIX_CLOCKRES_MIN = (int)20000000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCKRES_MIN 20000000
     * }
     */
    public static int _POSIX_CLOCKRES_MIN() {
        return _POSIX_CLOCKRES_MIN;
    }
    private static final int NR_OPEN = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define NR_OPEN 1024
     * }
     */
    public static int NR_OPEN() {
        return NR_OPEN;
    }
    private static final int NGROUPS_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS_MAX 65536
     * }
     */
    public static int NGROUPS_MAX() {
        return NGROUPS_MAX;
    }
    private static final int ARG_MAX = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 131072
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }
    private static final int LINK_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define LINK_MAX 127
     * }
     */
    public static int LINK_MAX() {
        return LINK_MAX;
    }
    private static final int MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CANON 255
     * }
     */
    public static int MAX_CANON() {
        return MAX_CANON;
    }
    private static final int MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_INPUT 255
     * }
     */
    public static int MAX_INPUT() {
        return MAX_INPUT;
    }
    private static final int NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define NAME_MAX 255
     * }
     */
    public static int NAME_MAX() {
        return NAME_MAX;
    }
    private static final int PATH_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PATH_MAX 4096
     * }
     */
    public static int PATH_MAX() {
        return PATH_MAX;
    }
    private static final int PIPE_BUF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PIPE_BUF 4096
     * }
     */
    public static int PIPE_BUF() {
        return PIPE_BUF;
    }
    private static final int XATTR_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define XATTR_NAME_MAX 255
     * }
     */
    public static int XATTR_NAME_MAX() {
        return XATTR_NAME_MAX;
    }
    private static final int XATTR_SIZE_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_SIZE_MAX 65536
     * }
     */
    public static int XATTR_SIZE_MAX() {
        return XATTR_SIZE_MAX;
    }
    private static final int XATTR_LIST_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_LIST_MAX 65536
     * }
     */
    public static int XATTR_LIST_MAX() {
        return XATTR_LIST_MAX;
    }
    private static final int RTSIG_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RTSIG_MAX 32
     * }
     */
    public static int RTSIG_MAX() {
        return RTSIG_MAX;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int PTHREAD_KEYS_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_KEYS_MAX 1024
     * }
     */
    public static int PTHREAD_KEYS_MAX() {
        return PTHREAD_KEYS_MAX;
    }
    private static final int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int _POSIX_THREAD_DESTRUCTOR_ITERATIONS() {
        return _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _POSIX_THREAD_THREADS_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_THREADS_MAX 64
     * }
     */
    public static int _POSIX_THREAD_THREADS_MAX() {
        return _POSIX_THREAD_THREADS_MAX;
    }
    private static final int AIO_PRIO_DELTA_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AIO_PRIO_DELTA_MAX 20
     * }
     */
    public static int AIO_PRIO_DELTA_MAX() {
        return AIO_PRIO_DELTA_MAX;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int DELAYTIMER_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define DELAYTIMER_MAX 2147483647
     * }
     */
    public static int DELAYTIMER_MAX() {
        return DELAYTIMER_MAX;
    }
    private static final int TTY_NAME_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define TTY_NAME_MAX 32
     * }
     */
    public static int TTY_NAME_MAX() {
        return TTY_NAME_MAX;
    }
    private static final int LOGIN_NAME_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define LOGIN_NAME_MAX 256
     * }
     */
    public static int LOGIN_NAME_MAX() {
        return LOGIN_NAME_MAX;
    }
    private static final int HOST_NAME_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define HOST_NAME_MAX 64
     * }
     */
    public static int HOST_NAME_MAX() {
        return HOST_NAME_MAX;
    }
    private static final int MQ_PRIO_MAX = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MQ_PRIO_MAX 32768
     * }
     */
    public static int MQ_PRIO_MAX() {
        return MQ_PRIO_MAX;
    }
    private static final int _BITS_POSIX2_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX2_LIM_H 1
     * }
     */
    public static int _BITS_POSIX2_LIM_H() {
        return _BITS_POSIX2_LIM_H;
    }
    private static final int _POSIX2_BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_BASE_MAX 99
     * }
     */
    public static int _POSIX2_BC_BASE_MAX() {
        return _POSIX2_BC_BASE_MAX;
    }
    private static final int _POSIX2_BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_DIM_MAX 2048
     * }
     */
    public static int _POSIX2_BC_DIM_MAX() {
        return _POSIX2_BC_DIM_MAX;
    }
    private static final int _POSIX2_BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_SCALE_MAX 99
     * }
     */
    public static int _POSIX2_BC_SCALE_MAX() {
        return _POSIX2_BC_SCALE_MAX;
    }
    private static final int _POSIX2_BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_STRING_MAX 1000
     * }
     */
    public static int _POSIX2_BC_STRING_MAX() {
        return _POSIX2_BC_STRING_MAX;
    }
    private static final int _POSIX2_COLL_WEIGHTS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_COLL_WEIGHTS_MAX 2
     * }
     */
    public static int _POSIX2_COLL_WEIGHTS_MAX() {
        return _POSIX2_COLL_WEIGHTS_MAX;
    }
    private static final int _POSIX2_EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_EXPR_NEST_MAX 32
     * }
     */
    public static int _POSIX2_EXPR_NEST_MAX() {
        return _POSIX2_EXPR_NEST_MAX;
    }
    private static final int _POSIX2_LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LINE_MAX 2048
     * }
     */
    public static int _POSIX2_LINE_MAX() {
        return _POSIX2_LINE_MAX;
    }
    private static final int _POSIX2_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX2_RE_DUP_MAX() {
        return _POSIX2_RE_DUP_MAX;
    }
    private static final int _POSIX2_CHARCLASS_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHARCLASS_NAME_MAX 14
     * }
     */
    public static int _POSIX2_CHARCLASS_NAME_MAX() {
        return _POSIX2_CHARCLASS_NAME_MAX;
    }
    private static final int COLL_WEIGHTS_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define COLL_WEIGHTS_MAX 255
     * }
     */
    public static int COLL_WEIGHTS_MAX() {
        return COLL_WEIGHTS_MAX;
    }
    private static final int CHARCLASS_NAME_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define CHARCLASS_NAME_MAX 2048
     * }
     */
    public static int CHARCLASS_NAME_MAX() {
        return CHARCLASS_NAME_MAX;
    }
    private static final int _MATH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _MATH_H 1
     * }
     */
    public static int _MATH_H() {
        return _MATH_H;
    }
    private static final int _BITS_LIBM_SIMD_DECL_STUBS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_LIBM_SIMD_DECL_STUBS_H 1
     * }
     */
    public static int _BITS_LIBM_SIMD_DECL_STUBS_H() {
        return _BITS_LIBM_SIMD_DECL_STUBS_H;
    }
    private static final int __HAVE_FLOAT128 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 1
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 1
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int __FP_LOGB0_IS_MIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FP_LOGB0_IS_MIN 1
     * }
     */
    public static int __FP_LOGB0_IS_MIN() {
        return __FP_LOGB0_IS_MIN;
    }
    private static final int __FP_LOGBNAN_IS_MIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FP_LOGBNAN_IS_MIN 1
     * }
     */
    public static int __FP_LOGBNAN_IS_MIN() {
        return __FP_LOGBNAN_IS_MIN;
    }
    private static final int __MATH_DECLARING_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __MATH_DECLARING_DOUBLE 1
     * }
     */
    public static int __MATH_DECLARING_DOUBLE() {
        return __MATH_DECLARING_DOUBLE;
    }
    private static final int __MATH_DECLARING_FLOATN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __MATH_DECLARING_FLOATN 0
     * }
     */
    public static int __MATH_DECLARING_FLOATN() {
        return __MATH_DECLARING_FLOATN;
    }
    private static final int __MATH_DECLARE_LDOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __MATH_DECLARE_LDOUBLE 1
     * }
     */
    public static int __MATH_DECLARE_LDOUBLE() {
        return __MATH_DECLARE_LDOUBLE;
    }
    private static final int FP_NAN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FP_NAN 0
     * }
     */
    public static int FP_NAN() {
        return FP_NAN;
    }
    private static final int FP_INFINITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_INFINITE 1
     * }
     */
    public static int FP_INFINITE() {
        return FP_INFINITE;
    }
    private static final int FP_ZERO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FP_ZERO 2
     * }
     */
    public static int FP_ZERO() {
        return FP_ZERO;
    }
    private static final int FP_SUBNORMAL = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FP_SUBNORMAL 3
     * }
     */
    public static int FP_SUBNORMAL() {
        return FP_SUBNORMAL;
    }
    private static final int FP_NORMAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FP_NORMAL 4
     * }
     */
    public static int FP_NORMAL() {
        return FP_NORMAL;
    }
    private static final int MATH_ERRNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERRNO 1
     * }
     */
    public static int MATH_ERRNO() {
        return MATH_ERRNO;
    }
    private static final int MATH_ERREXCEPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERREXCEPT 2
     * }
     */
    public static int MATH_ERREXCEPT() {
        return MATH_ERREXCEPT;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int __cookie_io_functions_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __cookie_io_functions_t_defined 1
     * }
     */
    public static int __cookie_io_functions_t_defined() {
        return __cookie_io_functions_t_defined;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int _STRING_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRING_H 1
     * }
     */
    public static int _STRING_H() {
        return _STRING_H;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int _STRINGS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRINGS_H 1
     * }
     */
    public static int _STRINGS_H() {
        return _STRINGS_H;
    }
    private static final int AV_HAVE_BIGENDIAN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_HAVE_BIGENDIAN 0
     * }
     */
    public static int AV_HAVE_BIGENDIAN() {
        return AV_HAVE_BIGENDIAN;
    }
    private static final int AV_HAVE_FAST_UNALIGNED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_HAVE_FAST_UNALIGNED 1
     * }
     */
    public static int AV_HAVE_FAST_UNALIGNED() {
        return AV_HAVE_FAST_UNALIGNED;
    }
    private static final int AV_ERROR_MAX_STRING_SIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_ERROR_MAX_STRING_SIZE 64
     * }
     */
    public static int AV_ERROR_MAX_STRING_SIZE() {
        return AV_ERROR_MAX_STRING_SIZE;
    }
    private static final int LIBAVUTIL_VERSION_MAJOR = (int)60L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_MAJOR 60
     * }
     */
    public static int LIBAVUTIL_VERSION_MAJOR() {
        return LIBAVUTIL_VERSION_MAJOR;
    }
    private static final int LIBAVUTIL_VERSION_MINOR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_MINOR 8
     * }
     */
    public static int LIBAVUTIL_VERSION_MINOR() {
        return LIBAVUTIL_VERSION_MINOR;
    }
    private static final int LIBAVUTIL_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_MICRO 100
     * }
     */
    public static int LIBAVUTIL_VERSION_MICRO() {
        return LIBAVUTIL_VERSION_MICRO;
    }
    private static final int AV_LOG_PANIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PANIC 0
     * }
     */
    public static int AV_LOG_PANIC() {
        return AV_LOG_PANIC;
    }
    private static final int AV_LOG_FATAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_FATAL 8
     * }
     */
    public static int AV_LOG_FATAL() {
        return AV_LOG_FATAL;
    }
    private static final int AV_LOG_ERROR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_ERROR 16
     * }
     */
    public static int AV_LOG_ERROR() {
        return AV_LOG_ERROR;
    }
    private static final int AV_LOG_WARNING = (int)24L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_WARNING 24
     * }
     */
    public static int AV_LOG_WARNING() {
        return AV_LOG_WARNING;
    }
    private static final int AV_LOG_INFO = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_INFO 32
     * }
     */
    public static int AV_LOG_INFO() {
        return AV_LOG_INFO;
    }
    private static final int AV_LOG_VERBOSE = (int)40L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_VERBOSE 40
     * }
     */
    public static int AV_LOG_VERBOSE() {
        return AV_LOG_VERBOSE;
    }
    private static final int AV_LOG_DEBUG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_DEBUG 48
     * }
     */
    public static int AV_LOG_DEBUG() {
        return AV_LOG_DEBUG;
    }
    private static final int AV_LOG_TRACE = (int)56L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_TRACE 56
     * }
     */
    public static int AV_LOG_TRACE() {
        return AV_LOG_TRACE;
    }
    private static final int AV_LOG_SKIP_REPEATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_SKIP_REPEATED 1
     * }
     */
    public static int AV_LOG_SKIP_REPEATED() {
        return AV_LOG_SKIP_REPEATED;
    }
    private static final int AV_LOG_PRINT_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PRINT_LEVEL 2
     * }
     */
    public static int AV_LOG_PRINT_LEVEL() {
        return AV_LOG_PRINT_LEVEL;
    }
    private static final int AV_LOG_PRINT_TIME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PRINT_TIME 4
     * }
     */
    public static int AV_LOG_PRINT_TIME() {
        return AV_LOG_PRINT_TIME;
    }
    private static final int AV_LOG_PRINT_DATETIME = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PRINT_DATETIME 8
     * }
     */
    public static int AV_LOG_PRINT_DATETIME() {
        return AV_LOG_PRINT_DATETIME;
    }
    private static final int AVPALETTE_SIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVPALETTE_SIZE 1024
     * }
     */
    public static int AVPALETTE_SIZE() {
        return AVPALETTE_SIZE;
    }
    private static final int AVPALETTE_COUNT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVPALETTE_COUNT 256
     * }
     */
    public static int AVPALETTE_COUNT() {
        return AVPALETTE_COUNT;
    }
    private static final int AV_VIDEO_MAX_PLANES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_VIDEO_MAX_PLANES 4
     * }
     */
    public static int AV_VIDEO_MAX_PLANES() {
        return AV_VIDEO_MAX_PLANES;
    }
    private static final int AV_FOURCC_MAX_STRING_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_FOURCC_MAX_STRING_SIZE 32
     * }
     */
    public static int AV_FOURCC_MAX_STRING_SIZE() {
        return AV_FOURCC_MAX_STRING_SIZE;
    }
    private static final int AV_DICT_MATCH_CASE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_MATCH_CASE 1
     * }
     */
    public static int AV_DICT_MATCH_CASE() {
        return AV_DICT_MATCH_CASE;
    }
    private static final int AV_DICT_IGNORE_SUFFIX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_IGNORE_SUFFIX 2
     * }
     */
    public static int AV_DICT_IGNORE_SUFFIX() {
        return AV_DICT_IGNORE_SUFFIX;
    }
    private static final int AV_DICT_DONT_STRDUP_KEY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_STRDUP_KEY 4
     * }
     */
    public static int AV_DICT_DONT_STRDUP_KEY() {
        return AV_DICT_DONT_STRDUP_KEY;
    }
    private static final int AV_DICT_DONT_STRDUP_VAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_STRDUP_VAL 8
     * }
     */
    public static int AV_DICT_DONT_STRDUP_VAL() {
        return AV_DICT_DONT_STRDUP_VAL;
    }
    private static final int AV_DICT_DONT_OVERWRITE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_OVERWRITE 16
     * }
     */
    public static int AV_DICT_DONT_OVERWRITE() {
        return AV_DICT_DONT_OVERWRITE;
    }
    private static final int AV_DICT_APPEND = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_APPEND 32
     * }
     */
    public static int AV_DICT_APPEND() {
        return AV_DICT_APPEND;
    }
    private static final int AV_DICT_MULTIKEY = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_MULTIKEY 64
     * }
     */
    public static int AV_DICT_MULTIKEY() {
        return AV_DICT_MULTIKEY;
    }
    private static final int AV_DICT_DEDUP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DEDUP 128
     * }
     */
    public static int AV_DICT_DEDUP() {
        return AV_DICT_DEDUP;
    }
    private static final int AV_NUM_DATA_POINTERS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_NUM_DATA_POINTERS 8
     * }
     */
    public static int AV_NUM_DATA_POINTERS() {
        return AV_NUM_DATA_POINTERS;
    }
    private static final int FF_DECODE_ERROR_INVALID_BITSTREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_INVALID_BITSTREAM 1
     * }
     */
    public static int FF_DECODE_ERROR_INVALID_BITSTREAM() {
        return FF_DECODE_ERROR_INVALID_BITSTREAM;
    }
    private static final int FF_DECODE_ERROR_MISSING_REFERENCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_MISSING_REFERENCE 2
     * }
     */
    public static int FF_DECODE_ERROR_MISSING_REFERENCE() {
        return FF_DECODE_ERROR_MISSING_REFERENCE;
    }
    private static final int FF_DECODE_ERROR_CONCEALMENT_ACTIVE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_CONCEALMENT_ACTIVE 4
     * }
     */
    public static int FF_DECODE_ERROR_CONCEALMENT_ACTIVE() {
        return FF_DECODE_ERROR_CONCEALMENT_ACTIVE;
    }
    private static final int FF_DECODE_ERROR_DECODE_SLICES = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_DECODE_SLICES 8
     * }
     */
    public static int FF_DECODE_ERROR_DECODE_SLICES() {
        return FF_DECODE_ERROR_DECODE_SLICES;
    }
    private static final int LIBAVCODEC_VERSION_MAJOR = (int)62L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MAJOR 62
     * }
     */
    public static int LIBAVCODEC_VERSION_MAJOR() {
        return LIBAVCODEC_VERSION_MAJOR;
    }
    private static final int AV_INPUT_BUFFER_PADDING_SIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_INPUT_BUFFER_PADDING_SIZE 64
     * }
     */
    public static int AV_INPUT_BUFFER_PADDING_SIZE() {
        return AV_INPUT_BUFFER_PADDING_SIZE;
    }
    private static final int FF_COMPLIANCE_VERY_STRICT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_COMPLIANCE_VERY_STRICT 2
     * }
     */
    public static int FF_COMPLIANCE_VERY_STRICT() {
        return FF_COMPLIANCE_VERY_STRICT;
    }
    private static final int FF_COMPLIANCE_STRICT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_COMPLIANCE_STRICT 1
     * }
     */
    public static int FF_COMPLIANCE_STRICT() {
        return FF_COMPLIANCE_STRICT;
    }
    private static final int FF_COMPLIANCE_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_COMPLIANCE_NORMAL 0
     * }
     */
    public static int FF_COMPLIANCE_NORMAL() {
        return FF_COMPLIANCE_NORMAL;
    }
    private static final int AV_PROFILE_AAC_MAIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_MAIN 0
     * }
     */
    public static int AV_PROFILE_AAC_MAIN() {
        return AV_PROFILE_AAC_MAIN;
    }
    private static final int AV_PROFILE_AAC_LOW = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_LOW 1
     * }
     */
    public static int AV_PROFILE_AAC_LOW() {
        return AV_PROFILE_AAC_LOW;
    }
    private static final int AV_PROFILE_AAC_SSR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_SSR 2
     * }
     */
    public static int AV_PROFILE_AAC_SSR() {
        return AV_PROFILE_AAC_SSR;
    }
    private static final int AV_PROFILE_AAC_LTP = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_LTP 3
     * }
     */
    public static int AV_PROFILE_AAC_LTP() {
        return AV_PROFILE_AAC_LTP;
    }
    private static final int AV_PROFILE_AAC_HE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_HE 4
     * }
     */
    public static int AV_PROFILE_AAC_HE() {
        return AV_PROFILE_AAC_HE;
    }
    private static final int AV_PROFILE_AAC_HE_V2 = (int)28L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_HE_V2 28
     * }
     */
    public static int AV_PROFILE_AAC_HE_V2() {
        return AV_PROFILE_AAC_HE_V2;
    }
    private static final int AV_PROFILE_AAC_LD = (int)22L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_LD 22
     * }
     */
    public static int AV_PROFILE_AAC_LD() {
        return AV_PROFILE_AAC_LD;
    }
    private static final int AV_PROFILE_AAC_ELD = (int)38L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_ELD 38
     * }
     */
    public static int AV_PROFILE_AAC_ELD() {
        return AV_PROFILE_AAC_ELD;
    }
    private static final int AV_PROFILE_AAC_USAC = (int)41L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_USAC 41
     * }
     */
    public static int AV_PROFILE_AAC_USAC() {
        return AV_PROFILE_AAC_USAC;
    }
    private static final int AV_PROFILE_MPEG2_AAC_LOW = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_AAC_LOW 128
     * }
     */
    public static int AV_PROFILE_MPEG2_AAC_LOW() {
        return AV_PROFILE_MPEG2_AAC_LOW;
    }
    private static final int AV_PROFILE_MPEG2_AAC_HE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_AAC_HE 131
     * }
     */
    public static int AV_PROFILE_MPEG2_AAC_HE() {
        return AV_PROFILE_MPEG2_AAC_HE;
    }
    private static final int AV_PROFILE_DNXHD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHD 0
     * }
     */
    public static int AV_PROFILE_DNXHD() {
        return AV_PROFILE_DNXHD;
    }
    private static final int AV_PROFILE_DNXHR_LB = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_LB 1
     * }
     */
    public static int AV_PROFILE_DNXHR_LB() {
        return AV_PROFILE_DNXHR_LB;
    }
    private static final int AV_PROFILE_DNXHR_SQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_SQ 2
     * }
     */
    public static int AV_PROFILE_DNXHR_SQ() {
        return AV_PROFILE_DNXHR_SQ;
    }
    private static final int AV_PROFILE_DNXHR_HQ = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_HQ 3
     * }
     */
    public static int AV_PROFILE_DNXHR_HQ() {
        return AV_PROFILE_DNXHR_HQ;
    }
    private static final int AV_PROFILE_DNXHR_HQX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_HQX 4
     * }
     */
    public static int AV_PROFILE_DNXHR_HQX() {
        return AV_PROFILE_DNXHR_HQX;
    }
    private static final int AV_PROFILE_DNXHR_444 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_444 5
     * }
     */
    public static int AV_PROFILE_DNXHR_444() {
        return AV_PROFILE_DNXHR_444;
    }
    private static final int AV_PROFILE_DTS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS 20
     * }
     */
    public static int AV_PROFILE_DTS() {
        return AV_PROFILE_DTS;
    }
    private static final int AV_PROFILE_DTS_ES = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_ES 30
     * }
     */
    public static int AV_PROFILE_DTS_ES() {
        return AV_PROFILE_DTS_ES;
    }
    private static final int AV_PROFILE_DTS_96_24 = (int)40L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_96_24 40
     * }
     */
    public static int AV_PROFILE_DTS_96_24() {
        return AV_PROFILE_DTS_96_24;
    }
    private static final int AV_PROFILE_DTS_HD_HRA = (int)50L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_HRA 50
     * }
     */
    public static int AV_PROFILE_DTS_HD_HRA() {
        return AV_PROFILE_DTS_HD_HRA;
    }
    private static final int AV_PROFILE_DTS_HD_MA = (int)60L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_MA 60
     * }
     */
    public static int AV_PROFILE_DTS_HD_MA() {
        return AV_PROFILE_DTS_HD_MA;
    }
    private static final int AV_PROFILE_DTS_EXPRESS = (int)70L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_EXPRESS 70
     * }
     */
    public static int AV_PROFILE_DTS_EXPRESS() {
        return AV_PROFILE_DTS_EXPRESS;
    }
    private static final int AV_PROFILE_DTS_HD_MA_X = (int)61L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_MA_X 61
     * }
     */
    public static int AV_PROFILE_DTS_HD_MA_X() {
        return AV_PROFILE_DTS_HD_MA_X;
    }
    private static final int AV_PROFILE_DTS_HD_MA_X_IMAX = (int)62L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_MA_X_IMAX 62
     * }
     */
    public static int AV_PROFILE_DTS_HD_MA_X_IMAX() {
        return AV_PROFILE_DTS_HD_MA_X_IMAX;
    }
    private static final int AV_PROFILE_EAC3_DDP_ATMOS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_EAC3_DDP_ATMOS 30
     * }
     */
    public static int AV_PROFILE_EAC3_DDP_ATMOS() {
        return AV_PROFILE_EAC3_DDP_ATMOS;
    }
    private static final int AV_PROFILE_TRUEHD_ATMOS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_TRUEHD_ATMOS 30
     * }
     */
    public static int AV_PROFILE_TRUEHD_ATMOS() {
        return AV_PROFILE_TRUEHD_ATMOS;
    }
    private static final int AV_PROFILE_MPEG2_422 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_422 0
     * }
     */
    public static int AV_PROFILE_MPEG2_422() {
        return AV_PROFILE_MPEG2_422;
    }
    private static final int AV_PROFILE_MPEG2_HIGH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_HIGH 1
     * }
     */
    public static int AV_PROFILE_MPEG2_HIGH() {
        return AV_PROFILE_MPEG2_HIGH;
    }
    private static final int AV_PROFILE_MPEG2_SS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_SS 2
     * }
     */
    public static int AV_PROFILE_MPEG2_SS() {
        return AV_PROFILE_MPEG2_SS;
    }
    private static final int AV_PROFILE_MPEG2_SNR_SCALABLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_SNR_SCALABLE 3
     * }
     */
    public static int AV_PROFILE_MPEG2_SNR_SCALABLE() {
        return AV_PROFILE_MPEG2_SNR_SCALABLE;
    }
    private static final int AV_PROFILE_MPEG2_MAIN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_MAIN 4
     * }
     */
    public static int AV_PROFILE_MPEG2_MAIN() {
        return AV_PROFILE_MPEG2_MAIN;
    }
    private static final int AV_PROFILE_MPEG2_SIMPLE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_SIMPLE 5
     * }
     */
    public static int AV_PROFILE_MPEG2_SIMPLE() {
        return AV_PROFILE_MPEG2_SIMPLE;
    }
    private static final int AV_PROFILE_H264_BASELINE = (int)66L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_BASELINE 66
     * }
     */
    public static int AV_PROFILE_H264_BASELINE() {
        return AV_PROFILE_H264_BASELINE;
    }
    private static final int AV_PROFILE_H264_MAIN = (int)77L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_MAIN 77
     * }
     */
    public static int AV_PROFILE_H264_MAIN() {
        return AV_PROFILE_H264_MAIN;
    }
    private static final int AV_PROFILE_H264_EXTENDED = (int)88L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_EXTENDED 88
     * }
     */
    public static int AV_PROFILE_H264_EXTENDED() {
        return AV_PROFILE_H264_EXTENDED;
    }
    private static final int AV_PROFILE_H264_HIGH = (int)100L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH 100
     * }
     */
    public static int AV_PROFILE_H264_HIGH() {
        return AV_PROFILE_H264_HIGH;
    }
    private static final int AV_PROFILE_H264_HIGH_10 = (int)110L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_10 110
     * }
     */
    public static int AV_PROFILE_H264_HIGH_10() {
        return AV_PROFILE_H264_HIGH_10;
    }
    private static final int AV_PROFILE_H264_MULTIVIEW_HIGH = (int)118L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_MULTIVIEW_HIGH 118
     * }
     */
    public static int AV_PROFILE_H264_MULTIVIEW_HIGH() {
        return AV_PROFILE_H264_MULTIVIEW_HIGH;
    }
    private static final int AV_PROFILE_H264_HIGH_422 = (int)122L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_422 122
     * }
     */
    public static int AV_PROFILE_H264_HIGH_422() {
        return AV_PROFILE_H264_HIGH_422;
    }
    private static final int AV_PROFILE_H264_STEREO_HIGH = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_STEREO_HIGH 128
     * }
     */
    public static int AV_PROFILE_H264_STEREO_HIGH() {
        return AV_PROFILE_H264_STEREO_HIGH;
    }
    private static final int AV_PROFILE_H264_HIGH_444 = (int)144L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_444 144
     * }
     */
    public static int AV_PROFILE_H264_HIGH_444() {
        return AV_PROFILE_H264_HIGH_444;
    }
    private static final int AV_PROFILE_H264_HIGH_444_PREDICTIVE = (int)244L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_444_PREDICTIVE 244
     * }
     */
    public static int AV_PROFILE_H264_HIGH_444_PREDICTIVE() {
        return AV_PROFILE_H264_HIGH_444_PREDICTIVE;
    }
    private static final int AV_PROFILE_H264_CAVLC_444 = (int)44L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_CAVLC_444 44
     * }
     */
    public static int AV_PROFILE_H264_CAVLC_444() {
        return AV_PROFILE_H264_CAVLC_444;
    }
    private static final int AV_PROFILE_VC1_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_SIMPLE 0
     * }
     */
    public static int AV_PROFILE_VC1_SIMPLE() {
        return AV_PROFILE_VC1_SIMPLE;
    }
    private static final int AV_PROFILE_VC1_MAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_MAIN 1
     * }
     */
    public static int AV_PROFILE_VC1_MAIN() {
        return AV_PROFILE_VC1_MAIN;
    }
    private static final int AV_PROFILE_VC1_COMPLEX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_COMPLEX 2
     * }
     */
    public static int AV_PROFILE_VC1_COMPLEX() {
        return AV_PROFILE_VC1_COMPLEX;
    }
    private static final int AV_PROFILE_VC1_ADVANCED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_ADVANCED 3
     * }
     */
    public static int AV_PROFILE_VC1_ADVANCED() {
        return AV_PROFILE_VC1_ADVANCED;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE 0
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE() {
        return AV_PROFILE_MPEG4_SIMPLE;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE_SCALABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE_SCALABLE 1
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE_SCALABLE() {
        return AV_PROFILE_MPEG4_SIMPLE_SCALABLE;
    }
    private static final int AV_PROFILE_MPEG4_CORE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_CORE 2
     * }
     */
    public static int AV_PROFILE_MPEG4_CORE() {
        return AV_PROFILE_MPEG4_CORE;
    }
    private static final int AV_PROFILE_MPEG4_MAIN = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_MAIN 3
     * }
     */
    public static int AV_PROFILE_MPEG4_MAIN() {
        return AV_PROFILE_MPEG4_MAIN;
    }
    private static final int AV_PROFILE_MPEG4_N_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_N_BIT 4
     * }
     */
    public static int AV_PROFILE_MPEG4_N_BIT() {
        return AV_PROFILE_MPEG4_N_BIT;
    }
    private static final int AV_PROFILE_MPEG4_SCALABLE_TEXTURE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SCALABLE_TEXTURE 5
     * }
     */
    public static int AV_PROFILE_MPEG4_SCALABLE_TEXTURE() {
        return AV_PROFILE_MPEG4_SCALABLE_TEXTURE;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION 6
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION() {
        return AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION;
    }
    private static final int AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE 7
     * }
     */
    public static int AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE() {
        return AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE;
    }
    private static final int AV_PROFILE_MPEG4_HYBRID = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_HYBRID 8
     * }
     */
    public static int AV_PROFILE_MPEG4_HYBRID() {
        return AV_PROFILE_MPEG4_HYBRID;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_REAL_TIME = (int)9L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_REAL_TIME 9
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_REAL_TIME() {
        return AV_PROFILE_MPEG4_ADVANCED_REAL_TIME;
    }
    private static final int AV_PROFILE_MPEG4_CORE_SCALABLE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_CORE_SCALABLE 10
     * }
     */
    public static int AV_PROFILE_MPEG4_CORE_SCALABLE() {
        return AV_PROFILE_MPEG4_CORE_SCALABLE;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_CODING = (int)11L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_CODING 11
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_CODING() {
        return AV_PROFILE_MPEG4_ADVANCED_CODING;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_CORE = (int)12L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_CORE 12
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_CORE() {
        return AV_PROFILE_MPEG4_ADVANCED_CORE;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE 13
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE() {
        return AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE_STUDIO = (int)14L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE_STUDIO 14
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE_STUDIO() {
        return AV_PROFILE_MPEG4_SIMPLE_STUDIO;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_SIMPLE = (int)15L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_SIMPLE 15
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_SIMPLE() {
        return AV_PROFILE_MPEG4_ADVANCED_SIMPLE;
    }
    private static final int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 1
     * }
     */
    public static int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0() {
        return AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0;
    }
    private static final int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 2
     * }
     */
    public static int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1() {
        return AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1;
    }
    private static final int AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION 32768
     * }
     */
    public static int AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION() {
        return AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION;
    }
    private static final int AV_PROFILE_JPEG2000_DCINEMA_2K = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_DCINEMA_2K 3
     * }
     */
    public static int AV_PROFILE_JPEG2000_DCINEMA_2K() {
        return AV_PROFILE_JPEG2000_DCINEMA_2K;
    }
    private static final int AV_PROFILE_JPEG2000_DCINEMA_4K = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_DCINEMA_4K 4
     * }
     */
    public static int AV_PROFILE_JPEG2000_DCINEMA_4K() {
        return AV_PROFILE_JPEG2000_DCINEMA_4K;
    }
    private static final int AV_PROFILE_VP9_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_0 0
     * }
     */
    public static int AV_PROFILE_VP9_0() {
        return AV_PROFILE_VP9_0;
    }
    private static final int AV_PROFILE_VP9_1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_1 1
     * }
     */
    public static int AV_PROFILE_VP9_1() {
        return AV_PROFILE_VP9_1;
    }
    private static final int AV_PROFILE_VP9_2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_2 2
     * }
     */
    public static int AV_PROFILE_VP9_2() {
        return AV_PROFILE_VP9_2;
    }
    private static final int AV_PROFILE_VP9_3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_3 3
     * }
     */
    public static int AV_PROFILE_VP9_3() {
        return AV_PROFILE_VP9_3;
    }
    private static final int AV_PROFILE_HEVC_MAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MAIN 1
     * }
     */
    public static int AV_PROFILE_HEVC_MAIN() {
        return AV_PROFILE_HEVC_MAIN;
    }
    private static final int AV_PROFILE_HEVC_MAIN_10 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MAIN_10 2
     * }
     */
    public static int AV_PROFILE_HEVC_MAIN_10() {
        return AV_PROFILE_HEVC_MAIN_10;
    }
    private static final int AV_PROFILE_HEVC_MAIN_STILL_PICTURE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MAIN_STILL_PICTURE 3
     * }
     */
    public static int AV_PROFILE_HEVC_MAIN_STILL_PICTURE() {
        return AV_PROFILE_HEVC_MAIN_STILL_PICTURE;
    }
    private static final int AV_PROFILE_HEVC_REXT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_REXT 4
     * }
     */
    public static int AV_PROFILE_HEVC_REXT() {
        return AV_PROFILE_HEVC_REXT;
    }
    private static final int AV_PROFILE_HEVC_MULTIVIEW_MAIN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MULTIVIEW_MAIN 6
     * }
     */
    public static int AV_PROFILE_HEVC_MULTIVIEW_MAIN() {
        return AV_PROFILE_HEVC_MULTIVIEW_MAIN;
    }
    private static final int AV_PROFILE_HEVC_SCC = (int)9L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_SCC 9
     * }
     */
    public static int AV_PROFILE_HEVC_SCC() {
        return AV_PROFILE_HEVC_SCC;
    }
    private static final int AV_PROFILE_VVC_MAIN_10 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VVC_MAIN_10 1
     * }
     */
    public static int AV_PROFILE_VVC_MAIN_10() {
        return AV_PROFILE_VVC_MAIN_10;
    }
    private static final int AV_PROFILE_VVC_MAIN_10_444 = (int)33L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VVC_MAIN_10_444 33
     * }
     */
    public static int AV_PROFILE_VVC_MAIN_10_444() {
        return AV_PROFILE_VVC_MAIN_10_444;
    }
    private static final int AV_PROFILE_AV1_MAIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AV1_MAIN 0
     * }
     */
    public static int AV_PROFILE_AV1_MAIN() {
        return AV_PROFILE_AV1_MAIN;
    }
    private static final int AV_PROFILE_AV1_HIGH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AV1_HIGH 1
     * }
     */
    public static int AV_PROFILE_AV1_HIGH() {
        return AV_PROFILE_AV1_HIGH;
    }
    private static final int AV_PROFILE_AV1_PROFESSIONAL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AV1_PROFESSIONAL 2
     * }
     */
    public static int AV_PROFILE_AV1_PROFESSIONAL() {
        return AV_PROFILE_AV1_PROFESSIONAL;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = (int)192L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT 192
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT() {
        return AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = (int)193L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT 193
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT() {
        return AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = (int)194L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT 194
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT() {
        return AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS = (int)195L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS 195
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS() {
        return AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS;
    }
    private static final int AV_PROFILE_MJPEG_JPEG_LS = (int)247L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_JPEG_LS 247
     * }
     */
    public static int AV_PROFILE_MJPEG_JPEG_LS() {
        return AV_PROFILE_MJPEG_JPEG_LS;
    }
    private static final int AV_PROFILE_SBC_MSBC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_SBC_MSBC 1
     * }
     */
    public static int AV_PROFILE_SBC_MSBC() {
        return AV_PROFILE_SBC_MSBC;
    }
    private static final int AV_PROFILE_PRORES_PROXY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_PROXY 0
     * }
     */
    public static int AV_PROFILE_PRORES_PROXY() {
        return AV_PROFILE_PRORES_PROXY;
    }
    private static final int AV_PROFILE_PRORES_LT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_LT 1
     * }
     */
    public static int AV_PROFILE_PRORES_LT() {
        return AV_PROFILE_PRORES_LT;
    }
    private static final int AV_PROFILE_PRORES_STANDARD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_STANDARD 2
     * }
     */
    public static int AV_PROFILE_PRORES_STANDARD() {
        return AV_PROFILE_PRORES_STANDARD;
    }
    private static final int AV_PROFILE_PRORES_HQ = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_HQ 3
     * }
     */
    public static int AV_PROFILE_PRORES_HQ() {
        return AV_PROFILE_PRORES_HQ;
    }
    private static final int AV_PROFILE_PRORES_4444 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_4444 4
     * }
     */
    public static int AV_PROFILE_PRORES_4444() {
        return AV_PROFILE_PRORES_4444;
    }
    private static final int AV_PROFILE_PRORES_XQ = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_XQ 5
     * }
     */
    public static int AV_PROFILE_PRORES_XQ() {
        return AV_PROFILE_PRORES_XQ;
    }
    private static final int AV_PROFILE_PRORES_RAW = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_RAW 0
     * }
     */
    public static int AV_PROFILE_PRORES_RAW() {
        return AV_PROFILE_PRORES_RAW;
    }
    private static final int AV_PROFILE_PRORES_RAW_HQ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_RAW_HQ 1
     * }
     */
    public static int AV_PROFILE_PRORES_RAW_HQ() {
        return AV_PROFILE_PRORES_RAW_HQ;
    }
    private static final int AV_PROFILE_ARIB_PROFILE_A = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_ARIB_PROFILE_A 0
     * }
     */
    public static int AV_PROFILE_ARIB_PROFILE_A() {
        return AV_PROFILE_ARIB_PROFILE_A;
    }
    private static final int AV_PROFILE_ARIB_PROFILE_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_ARIB_PROFILE_C 1
     * }
     */
    public static int AV_PROFILE_ARIB_PROFILE_C() {
        return AV_PROFILE_ARIB_PROFILE_C;
    }
    private static final int AV_PROFILE_KLVA_SYNC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_KLVA_SYNC 0
     * }
     */
    public static int AV_PROFILE_KLVA_SYNC() {
        return AV_PROFILE_KLVA_SYNC;
    }
    private static final int AV_PROFILE_KLVA_ASYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_KLVA_ASYNC 1
     * }
     */
    public static int AV_PROFILE_KLVA_ASYNC() {
        return AV_PROFILE_KLVA_ASYNC;
    }
    private static final int AV_PROFILE_EVC_BASELINE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_EVC_BASELINE 0
     * }
     */
    public static int AV_PROFILE_EVC_BASELINE() {
        return AV_PROFILE_EVC_BASELINE;
    }
    private static final int AV_PROFILE_EVC_MAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_EVC_MAIN 1
     * }
     */
    public static int AV_PROFILE_EVC_MAIN() {
        return AV_PROFILE_EVC_MAIN;
    }
    private static final int AV_PROFILE_APV_422_10 = (int)33L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_422_10 33
     * }
     */
    public static int AV_PROFILE_APV_422_10() {
        return AV_PROFILE_APV_422_10;
    }
    private static final int AV_PROFILE_APV_422_12 = (int)44L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_422_12 44
     * }
     */
    public static int AV_PROFILE_APV_422_12() {
        return AV_PROFILE_APV_422_12;
    }
    private static final int AV_PROFILE_APV_444_10 = (int)55L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_444_10 55
     * }
     */
    public static int AV_PROFILE_APV_444_10() {
        return AV_PROFILE_APV_444_10;
    }
    private static final int AV_PROFILE_APV_444_12 = (int)66L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_444_12 66
     * }
     */
    public static int AV_PROFILE_APV_444_12() {
        return AV_PROFILE_APV_444_12;
    }
    private static final int AV_PROFILE_APV_4444_10 = (int)77L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_4444_10 77
     * }
     */
    public static int AV_PROFILE_APV_4444_10() {
        return AV_PROFILE_APV_4444_10;
    }
    private static final int AV_PROFILE_APV_4444_12 = (int)88L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_4444_12 88
     * }
     */
    public static int AV_PROFILE_APV_4444_12() {
        return AV_PROFILE_APV_4444_12;
    }
    private static final int AV_PROFILE_APV_400_10 = (int)99L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_400_10 99
     * }
     */
    public static int AV_PROFILE_APV_400_10() {
        return AV_PROFILE_APV_400_10;
    }
    private static final int AV_PKT_FLAG_KEY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_KEY 1
     * }
     */
    public static int AV_PKT_FLAG_KEY() {
        return AV_PKT_FLAG_KEY;
    }
    private static final int AV_PKT_FLAG_CORRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_CORRUPT 2
     * }
     */
    public static int AV_PKT_FLAG_CORRUPT() {
        return AV_PKT_FLAG_CORRUPT;
    }
    private static final int AV_PKT_FLAG_DISCARD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_DISCARD 4
     * }
     */
    public static int AV_PKT_FLAG_DISCARD() {
        return AV_PKT_FLAG_DISCARD;
    }
    private static final int AV_PKT_FLAG_TRUSTED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_TRUSTED 8
     * }
     */
    public static int AV_PKT_FLAG_TRUSTED() {
        return AV_PKT_FLAG_TRUSTED;
    }
    private static final int AV_PKT_FLAG_DISPOSABLE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_DISPOSABLE 16
     * }
     */
    public static int AV_PKT_FLAG_DISPOSABLE() {
        return AV_PKT_FLAG_DISPOSABLE;
    }
    private static final int LIBAVCODEC_VERSION_MINOR = (int)11L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MINOR 11
     * }
     */
    public static int LIBAVCODEC_VERSION_MINOR() {
        return LIBAVCODEC_VERSION_MINOR;
    }
    private static final int LIBAVCODEC_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MICRO 100
     * }
     */
    public static int LIBAVCODEC_VERSION_MICRO() {
        return LIBAVCODEC_VERSION_MICRO;
    }
    private static final int SLICE_FLAG_CODED_ORDER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_CODED_ORDER 1
     * }
     */
    public static int SLICE_FLAG_CODED_ORDER() {
        return SLICE_FLAG_CODED_ORDER;
    }
    private static final int SLICE_FLAG_ALLOW_FIELD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_ALLOW_FIELD 2
     * }
     */
    public static int SLICE_FLAG_ALLOW_FIELD() {
        return SLICE_FLAG_ALLOW_FIELD;
    }
    private static final int SLICE_FLAG_ALLOW_PLANE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_ALLOW_PLANE 4
     * }
     */
    public static int SLICE_FLAG_ALLOW_PLANE() {
        return SLICE_FLAG_ALLOW_PLANE;
    }
    private static final int FF_CMP_SAD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SAD 0
     * }
     */
    public static int FF_CMP_SAD() {
        return FF_CMP_SAD;
    }
    private static final int FF_CMP_SSE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SSE 1
     * }
     */
    public static int FF_CMP_SSE() {
        return FF_CMP_SSE;
    }
    private static final int FF_CMP_SATD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SATD 2
     * }
     */
    public static int FF_CMP_SATD() {
        return FF_CMP_SATD;
    }
    private static final int FF_CMP_DCT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCT 3
     * }
     */
    public static int FF_CMP_DCT() {
        return FF_CMP_DCT;
    }
    private static final int FF_CMP_PSNR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_PSNR 4
     * }
     */
    public static int FF_CMP_PSNR() {
        return FF_CMP_PSNR;
    }
    private static final int FF_CMP_BIT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_BIT 5
     * }
     */
    public static int FF_CMP_BIT() {
        return FF_CMP_BIT;
    }
    private static final int FF_CMP_RD = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_RD 6
     * }
     */
    public static int FF_CMP_RD() {
        return FF_CMP_RD;
    }
    private static final int FF_CMP_ZERO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_ZERO 7
     * }
     */
    public static int FF_CMP_ZERO() {
        return FF_CMP_ZERO;
    }
    private static final int FF_CMP_VSAD = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_VSAD 8
     * }
     */
    public static int FF_CMP_VSAD() {
        return FF_CMP_VSAD;
    }
    private static final int FF_CMP_VSSE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_VSSE 9
     * }
     */
    public static int FF_CMP_VSSE() {
        return FF_CMP_VSSE;
    }
    private static final int FF_CMP_NSSE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_NSSE 10
     * }
     */
    public static int FF_CMP_NSSE() {
        return FF_CMP_NSSE;
    }
    private static final int FF_CMP_W53 = (int)11L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_W53 11
     * }
     */
    public static int FF_CMP_W53() {
        return FF_CMP_W53;
    }
    private static final int FF_CMP_W97 = (int)12L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_W97 12
     * }
     */
    public static int FF_CMP_W97() {
        return FF_CMP_W97;
    }
    private static final int FF_CMP_DCTMAX = (int)13L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCTMAX 13
     * }
     */
    public static int FF_CMP_DCTMAX() {
        return FF_CMP_DCTMAX;
    }
    private static final int FF_CMP_DCT264 = (int)14L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCT264 14
     * }
     */
    public static int FF_CMP_DCT264() {
        return FF_CMP_DCT264;
    }
    private static final int FF_CMP_MEDIAN_SAD = (int)15L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_MEDIAN_SAD 15
     * }
     */
    public static int FF_CMP_MEDIAN_SAD() {
        return FF_CMP_MEDIAN_SAD;
    }
    private static final int FF_CMP_CHROMA = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_CHROMA 256
     * }
     */
    public static int FF_CMP_CHROMA() {
        return FF_CMP_CHROMA;
    }
    private static final int FF_MB_DECISION_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_SIMPLE 0
     * }
     */
    public static int FF_MB_DECISION_SIMPLE() {
        return FF_MB_DECISION_SIMPLE;
    }
    private static final int FF_MB_DECISION_BITS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_BITS 1
     * }
     */
    public static int FF_MB_DECISION_BITS() {
        return FF_MB_DECISION_BITS;
    }
    private static final int FF_MB_DECISION_RD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_RD 2
     * }
     */
    public static int FF_MB_DECISION_RD() {
        return FF_MB_DECISION_RD;
    }
    private static final int FF_BUG_AUTODETECT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_AUTODETECT 1
     * }
     */
    public static int FF_BUG_AUTODETECT() {
        return FF_BUG_AUTODETECT;
    }
    private static final int FF_BUG_XVID_ILACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_XVID_ILACE 4
     * }
     */
    public static int FF_BUG_XVID_ILACE() {
        return FF_BUG_XVID_ILACE;
    }
    private static final int FF_BUG_UMP4 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_UMP4 8
     * }
     */
    public static int FF_BUG_UMP4() {
        return FF_BUG_UMP4;
    }
    private static final int FF_BUG_NO_PADDING = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_NO_PADDING 16
     * }
     */
    public static int FF_BUG_NO_PADDING() {
        return FF_BUG_NO_PADDING;
    }
    private static final int FF_BUG_AMV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_AMV 32
     * }
     */
    public static int FF_BUG_AMV() {
        return FF_BUG_AMV;
    }
    private static final int FF_BUG_QPEL_CHROMA = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_QPEL_CHROMA 64
     * }
     */
    public static int FF_BUG_QPEL_CHROMA() {
        return FF_BUG_QPEL_CHROMA;
    }
    private static final int FF_BUG_STD_QPEL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_STD_QPEL 128
     * }
     */
    public static int FF_BUG_STD_QPEL() {
        return FF_BUG_STD_QPEL;
    }
    private static final int FF_BUG_QPEL_CHROMA2 = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_QPEL_CHROMA2 256
     * }
     */
    public static int FF_BUG_QPEL_CHROMA2() {
        return FF_BUG_QPEL_CHROMA2;
    }
    private static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_DIRECT_BLOCKSIZE 512
     * }
     */
    public static int FF_BUG_DIRECT_BLOCKSIZE() {
        return FF_BUG_DIRECT_BLOCKSIZE;
    }
    private static final int FF_BUG_EDGE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_EDGE 1024
     * }
     */
    public static int FF_BUG_EDGE() {
        return FF_BUG_EDGE;
    }
    private static final int FF_BUG_HPEL_CHROMA = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_HPEL_CHROMA 2048
     * }
     */
    public static int FF_BUG_HPEL_CHROMA() {
        return FF_BUG_HPEL_CHROMA;
    }
    private static final int FF_BUG_DC_CLIP = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_DC_CLIP 4096
     * }
     */
    public static int FF_BUG_DC_CLIP() {
        return FF_BUG_DC_CLIP;
    }
    private static final int FF_BUG_MS = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_MS 8192
     * }
     */
    public static int FF_BUG_MS() {
        return FF_BUG_MS;
    }
    private static final int FF_BUG_TRUNCATED = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_TRUNCATED 16384
     * }
     */
    public static int FF_BUG_TRUNCATED() {
        return FF_BUG_TRUNCATED;
    }
    private static final int FF_BUG_IEDGE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_IEDGE 32768
     * }
     */
    public static int FF_BUG_IEDGE() {
        return FF_BUG_IEDGE;
    }
    private static final int FF_EC_GUESS_MVS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_GUESS_MVS 1
     * }
     */
    public static int FF_EC_GUESS_MVS() {
        return FF_EC_GUESS_MVS;
    }
    private static final int FF_EC_DEBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_DEBLOCK 2
     * }
     */
    public static int FF_EC_DEBLOCK() {
        return FF_EC_DEBLOCK;
    }
    private static final int FF_EC_FAVOR_INTER = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_FAVOR_INTER 256
     * }
     */
    public static int FF_EC_FAVOR_INTER() {
        return FF_EC_FAVOR_INTER;
    }
    private static final int FF_DEBUG_PICT_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_PICT_INFO 1
     * }
     */
    public static int FF_DEBUG_PICT_INFO() {
        return FF_DEBUG_PICT_INFO;
    }
    private static final int FF_DEBUG_RC = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_RC 2
     * }
     */
    public static int FF_DEBUG_RC() {
        return FF_DEBUG_RC;
    }
    private static final int FF_DEBUG_BITSTREAM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BITSTREAM 4
     * }
     */
    public static int FF_DEBUG_BITSTREAM() {
        return FF_DEBUG_BITSTREAM;
    }
    private static final int FF_DEBUG_MB_TYPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_MB_TYPE 8
     * }
     */
    public static int FF_DEBUG_MB_TYPE() {
        return FF_DEBUG_MB_TYPE;
    }
    private static final int FF_DEBUG_QP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_QP 16
     * }
     */
    public static int FF_DEBUG_QP() {
        return FF_DEBUG_QP;
    }
    private static final int FF_DEBUG_DCT_COEFF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_DCT_COEFF 64
     * }
     */
    public static int FF_DEBUG_DCT_COEFF() {
        return FF_DEBUG_DCT_COEFF;
    }
    private static final int FF_DEBUG_SKIP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_SKIP 128
     * }
     */
    public static int FF_DEBUG_SKIP() {
        return FF_DEBUG_SKIP;
    }
    private static final int FF_DEBUG_STARTCODE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_STARTCODE 256
     * }
     */
    public static int FF_DEBUG_STARTCODE() {
        return FF_DEBUG_STARTCODE;
    }
    private static final int FF_DEBUG_ER = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_ER 1024
     * }
     */
    public static int FF_DEBUG_ER() {
        return FF_DEBUG_ER;
    }
    private static final int FF_DEBUG_MMCO = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_MMCO 2048
     * }
     */
    public static int FF_DEBUG_MMCO() {
        return FF_DEBUG_MMCO;
    }
    private static final int FF_DEBUG_BUGS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BUGS 4096
     * }
     */
    public static int FF_DEBUG_BUGS() {
        return FF_DEBUG_BUGS;
    }
    private static final int FF_DEBUG_BUFFERS = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BUFFERS 32768
     * }
     */
    public static int FF_DEBUG_BUFFERS() {
        return FF_DEBUG_BUFFERS;
    }
    private static final int FF_DEBUG_THREADS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_THREADS 65536
     * }
     */
    public static int FF_DEBUG_THREADS() {
        return FF_DEBUG_THREADS;
    }
    private static final int FF_DEBUG_GREEN_MD = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_GREEN_MD 8388608
     * }
     */
    public static int FF_DEBUG_GREEN_MD() {
        return FF_DEBUG_GREEN_MD;
    }
    private static final int FF_DEBUG_NOMC = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_NOMC 16777216
     * }
     */
    public static int FF_DEBUG_NOMC() {
        return FF_DEBUG_NOMC;
    }
    private static final int FF_DCT_AUTO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_AUTO 0
     * }
     */
    public static int FF_DCT_AUTO() {
        return FF_DCT_AUTO;
    }
    private static final int FF_DCT_FASTINT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_FASTINT 1
     * }
     */
    public static int FF_DCT_FASTINT() {
        return FF_DCT_FASTINT;
    }
    private static final int FF_DCT_INT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_INT 2
     * }
     */
    public static int FF_DCT_INT() {
        return FF_DCT_INT;
    }
    private static final int FF_DCT_MMX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_MMX 3
     * }
     */
    public static int FF_DCT_MMX() {
        return FF_DCT_MMX;
    }
    private static final int FF_DCT_ALTIVEC = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_ALTIVEC 5
     * }
     */
    public static int FF_DCT_ALTIVEC() {
        return FF_DCT_ALTIVEC;
    }
    private static final int FF_DCT_FAAN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_FAAN 6
     * }
     */
    public static int FF_DCT_FAAN() {
        return FF_DCT_FAAN;
    }
    private static final int FF_DCT_NEON = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_NEON 7
     * }
     */
    public static int FF_DCT_NEON() {
        return FF_DCT_NEON;
    }
    private static final int FF_IDCT_AUTO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_AUTO 0
     * }
     */
    public static int FF_IDCT_AUTO() {
        return FF_IDCT_AUTO;
    }
    private static final int FF_IDCT_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_INT 1
     * }
     */
    public static int FF_IDCT_INT() {
        return FF_IDCT_INT;
    }
    private static final int FF_IDCT_SIMPLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLE 2
     * }
     */
    public static int FF_IDCT_SIMPLE() {
        return FF_IDCT_SIMPLE;
    }
    private static final int FF_IDCT_SIMPLEMMX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEMMX 3
     * }
     */
    public static int FF_IDCT_SIMPLEMMX() {
        return FF_IDCT_SIMPLEMMX;
    }
    private static final int FF_IDCT_ARM = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_ARM 7
     * }
     */
    public static int FF_IDCT_ARM() {
        return FF_IDCT_ARM;
    }
    private static final int FF_IDCT_ALTIVEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_ALTIVEC 8
     * }
     */
    public static int FF_IDCT_ALTIVEC() {
        return FF_IDCT_ALTIVEC;
    }
    private static final int FF_IDCT_SIMPLEARM = (int)10L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARM 10
     * }
     */
    public static int FF_IDCT_SIMPLEARM() {
        return FF_IDCT_SIMPLEARM;
    }
    private static final int FF_IDCT_XVID = (int)14L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_XVID 14
     * }
     */
    public static int FF_IDCT_XVID() {
        return FF_IDCT_XVID;
    }
    private static final int FF_IDCT_SIMPLEARMV5TE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARMV5TE 16
     * }
     */
    public static int FF_IDCT_SIMPLEARMV5TE() {
        return FF_IDCT_SIMPLEARMV5TE;
    }
    private static final int FF_IDCT_SIMPLEARMV6 = (int)17L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARMV6 17
     * }
     */
    public static int FF_IDCT_SIMPLEARMV6() {
        return FF_IDCT_SIMPLEARMV6;
    }
    private static final int FF_IDCT_FAAN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_FAAN 20
     * }
     */
    public static int FF_IDCT_FAAN() {
        return FF_IDCT_FAAN;
    }
    private static final int FF_IDCT_SIMPLENEON = (int)22L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLENEON 22
     * }
     */
    public static int FF_IDCT_SIMPLENEON() {
        return FF_IDCT_SIMPLENEON;
    }
    private static final int FF_IDCT_SIMPLEAUTO = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEAUTO 128
     * }
     */
    public static int FF_IDCT_SIMPLEAUTO() {
        return FF_IDCT_SIMPLEAUTO;
    }
    private static final int FF_THREAD_FRAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_THREAD_FRAME 1
     * }
     */
    public static int FF_THREAD_FRAME() {
        return FF_THREAD_FRAME;
    }
    private static final int FF_THREAD_SLICE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_THREAD_SLICE 2
     * }
     */
    public static int FF_THREAD_SLICE() {
        return FF_THREAD_SLICE;
    }
    private static final int FF_CODEC_PROPERTY_LOSSLESS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_LOSSLESS 1
     * }
     */
    public static int FF_CODEC_PROPERTY_LOSSLESS() {
        return FF_CODEC_PROPERTY_LOSSLESS;
    }
    private static final int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 2
     * }
     */
    public static int FF_CODEC_PROPERTY_CLOSED_CAPTIONS() {
        return FF_CODEC_PROPERTY_CLOSED_CAPTIONS;
    }
    private static final int FF_CODEC_PROPERTY_FILM_GRAIN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_FILM_GRAIN 4
     * }
     */
    public static int FF_CODEC_PROPERTY_FILM_GRAIN() {
        return FF_CODEC_PROPERTY_FILM_GRAIN;
    }
    private static final int FF_SUB_CHARENC_MODE_AUTOMATIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_AUTOMATIC 0
     * }
     */
    public static int FF_SUB_CHARENC_MODE_AUTOMATIC() {
        return FF_SUB_CHARENC_MODE_AUTOMATIC;
    }
    private static final int FF_SUB_CHARENC_MODE_PRE_DECODER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_PRE_DECODER 1
     * }
     */
    public static int FF_SUB_CHARENC_MODE_PRE_DECODER() {
        return FF_SUB_CHARENC_MODE_PRE_DECODER;
    }
    private static final int FF_SUB_CHARENC_MODE_IGNORE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_IGNORE 2
     * }
     */
    public static int FF_SUB_CHARENC_MODE_IGNORE() {
        return FF_SUB_CHARENC_MODE_IGNORE;
    }
    private static final int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AV_HWACCEL_CODEC_CAP_EXPERIMENTAL 512
     * }
     */
    public static int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL() {
        return AV_HWACCEL_CODEC_CAP_EXPERIMENTAL;
    }
    private static final int AV_SUBTITLE_FLAG_FORCED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_SUBTITLE_FLAG_FORCED 1
     * }
     */
    public static int AV_SUBTITLE_FLAG_FORCED() {
        return AV_SUBTITLE_FLAG_FORCED;
    }
    private static final int AV_PARSER_PTS_NB = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PARSER_PTS_NB 4
     * }
     */
    public static int AV_PARSER_PTS_NB() {
        return AV_PARSER_PTS_NB;
    }
    private static final int PARSER_FLAG_COMPLETE_FRAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_COMPLETE_FRAMES 1
     * }
     */
    public static int PARSER_FLAG_COMPLETE_FRAMES() {
        return PARSER_FLAG_COMPLETE_FRAMES;
    }
    private static final int PARSER_FLAG_ONCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_ONCE 2
     * }
     */
    public static int PARSER_FLAG_ONCE() {
        return PARSER_FLAG_ONCE;
    }
    private static final int PARSER_FLAG_FETCHED_OFFSET = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_FETCHED_OFFSET 4
     * }
     */
    public static int PARSER_FLAG_FETCHED_OFFSET() {
        return PARSER_FLAG_FETCHED_OFFSET;
    }
    private static final int PARSER_FLAG_USE_CODEC_TS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_USE_CODEC_TS 4096
     * }
     */
    public static int PARSER_FLAG_USE_CODEC_TS() {
        return PARSER_FLAG_USE_CODEC_TS;
    }
    private static final int LIBAVFORMAT_VERSION_MAJOR = (int)62L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MAJOR 62
     * }
     */
    public static int LIBAVFORMAT_VERSION_MAJOR() {
        return LIBAVFORMAT_VERSION_MAJOR;
    }
    private static final int FF_API_R_FRAME_RATE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_R_FRAME_RATE 1
     * }
     */
    public static int FF_API_R_FRAME_RATE() {
        return FF_API_R_FRAME_RATE;
    }
    private static final int AVSEEK_SIZE = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_SIZE 65536
     * }
     */
    public static int AVSEEK_SIZE() {
        return AVSEEK_SIZE;
    }
    private static final int AVSEEK_FORCE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FORCE 131072
     * }
     */
    public static int AVSEEK_FORCE() {
        return AVSEEK_FORCE;
    }
    private static final int AVIO_FLAG_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_READ 1
     * }
     */
    public static int AVIO_FLAG_READ() {
        return AVIO_FLAG_READ;
    }
    private static final int AVIO_FLAG_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_WRITE 2
     * }
     */
    public static int AVIO_FLAG_WRITE() {
        return AVIO_FLAG_WRITE;
    }
    private static final int AVIO_FLAG_NONBLOCK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_NONBLOCK 8
     * }
     */
    public static int AVIO_FLAG_NONBLOCK() {
        return AVIO_FLAG_NONBLOCK;
    }
    private static final int AVIO_FLAG_DIRECT = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_DIRECT 32768
     * }
     */
    public static int AVIO_FLAG_DIRECT() {
        return AVIO_FLAG_DIRECT;
    }
    private static final int LIBAVFORMAT_VERSION_MINOR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MINOR 3
     * }
     */
    public static int LIBAVFORMAT_VERSION_MINOR() {
        return LIBAVFORMAT_VERSION_MINOR;
    }
    private static final int LIBAVFORMAT_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MICRO 100
     * }
     */
    public static int LIBAVFORMAT_VERSION_MICRO() {
        return LIBAVFORMAT_VERSION_MICRO;
    }
    private static final int AVPROBE_SCORE_EXTENSION = (int)50L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_EXTENSION 50
     * }
     */
    public static int AVPROBE_SCORE_EXTENSION() {
        return AVPROBE_SCORE_EXTENSION;
    }
    private static final int AVPROBE_SCORE_MIME_BONUS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_MIME_BONUS 30
     * }
     */
    public static int AVPROBE_SCORE_MIME_BONUS() {
        return AVPROBE_SCORE_MIME_BONUS;
    }
    private static final int AVPROBE_SCORE_MAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_MAX 100
     * }
     */
    public static int AVPROBE_SCORE_MAX() {
        return AVPROBE_SCORE_MAX;
    }
    private static final int AVPROBE_PADDING_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_PADDING_SIZE 32
     * }
     */
    public static int AVPROBE_PADDING_SIZE() {
        return AVPROBE_PADDING_SIZE;
    }
    private static final int AVFMT_NOFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOFILE 1
     * }
     */
    public static int AVFMT_NOFILE() {
        return AVFMT_NOFILE;
    }
    private static final int AVFMT_NEEDNUMBER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NEEDNUMBER 2
     * }
     */
    public static int AVFMT_NEEDNUMBER() {
        return AVFMT_NEEDNUMBER;
    }
    private static final int AVFMT_EXPERIMENTAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_EXPERIMENTAL 4
     * }
     */
    public static int AVFMT_EXPERIMENTAL() {
        return AVFMT_EXPERIMENTAL;
    }
    private static final int AVFMT_SHOW_IDS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_SHOW_IDS 8
     * }
     */
    public static int AVFMT_SHOW_IDS() {
        return AVFMT_SHOW_IDS;
    }
    private static final int AVFMT_GLOBALHEADER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_GLOBALHEADER 64
     * }
     */
    public static int AVFMT_GLOBALHEADER() {
        return AVFMT_GLOBALHEADER;
    }
    private static final int AVFMT_NOTIMESTAMPS = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOTIMESTAMPS 128
     * }
     */
    public static int AVFMT_NOTIMESTAMPS() {
        return AVFMT_NOTIMESTAMPS;
    }
    private static final int AVFMT_GENERIC_INDEX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_GENERIC_INDEX 256
     * }
     */
    public static int AVFMT_GENERIC_INDEX() {
        return AVFMT_GENERIC_INDEX;
    }
    private static final int AVFMT_TS_DISCONT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_DISCONT 512
     * }
     */
    public static int AVFMT_TS_DISCONT() {
        return AVFMT_TS_DISCONT;
    }
    private static final int AVFMT_VARIABLE_FPS = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_VARIABLE_FPS 1024
     * }
     */
    public static int AVFMT_VARIABLE_FPS() {
        return AVFMT_VARIABLE_FPS;
    }
    private static final int AVFMT_NODIMENSIONS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NODIMENSIONS 2048
     * }
     */
    public static int AVFMT_NODIMENSIONS() {
        return AVFMT_NODIMENSIONS;
    }
    private static final int AVFMT_NOSTREAMS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOSTREAMS 4096
     * }
     */
    public static int AVFMT_NOSTREAMS() {
        return AVFMT_NOSTREAMS;
    }
    private static final int AVFMT_NOBINSEARCH = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOBINSEARCH 8192
     * }
     */
    public static int AVFMT_NOBINSEARCH() {
        return AVFMT_NOBINSEARCH;
    }
    private static final int AVFMT_NOGENSEARCH = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOGENSEARCH 16384
     * }
     */
    public static int AVFMT_NOGENSEARCH() {
        return AVFMT_NOGENSEARCH;
    }
    private static final int AVFMT_NO_BYTE_SEEK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NO_BYTE_SEEK 32768
     * }
     */
    public static int AVFMT_NO_BYTE_SEEK() {
        return AVFMT_NO_BYTE_SEEK;
    }
    private static final int AVFMT_TS_NONSTRICT = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_NONSTRICT 131072
     * }
     */
    public static int AVFMT_TS_NONSTRICT() {
        return AVFMT_TS_NONSTRICT;
    }
    private static final int AVFMT_TS_NEGATIVE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_NEGATIVE 262144
     * }
     */
    public static int AVFMT_TS_NEGATIVE() {
        return AVFMT_TS_NEGATIVE;
    }
    private static final int AVFMT_SEEK_TO_PTS = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_SEEK_TO_PTS 67108864
     * }
     */
    public static int AVFMT_SEEK_TO_PTS() {
        return AVFMT_SEEK_TO_PTS;
    }
    private static final int AVINDEX_KEYFRAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVINDEX_KEYFRAME 1
     * }
     */
    public static int AVINDEX_KEYFRAME() {
        return AVINDEX_KEYFRAME;
    }
    private static final int AVINDEX_DISCARD_FRAME = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVINDEX_DISCARD_FRAME 2
     * }
     */
    public static int AVINDEX_DISCARD_FRAME() {
        return AVINDEX_DISCARD_FRAME;
    }
    private static final int AV_PTS_WRAP_IGNORE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PTS_WRAP_IGNORE 0
     * }
     */
    public static int AV_PTS_WRAP_IGNORE() {
        return AV_PTS_WRAP_IGNORE;
    }
    private static final int AV_PTS_WRAP_ADD_OFFSET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PTS_WRAP_ADD_OFFSET 1
     * }
     */
    public static int AV_PTS_WRAP_ADD_OFFSET() {
        return AV_PTS_WRAP_ADD_OFFSET;
    }
    private static final int AVSTREAM_EVENT_FLAG_METADATA_UPDATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 1
     * }
     */
    public static int AVSTREAM_EVENT_FLAG_METADATA_UPDATED() {
        return AVSTREAM_EVENT_FLAG_METADATA_UPDATED;
    }
    private static final int AV_PROGRAM_RUNNING = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROGRAM_RUNNING 1
     * }
     */
    public static int AV_PROGRAM_RUNNING() {
        return AV_PROGRAM_RUNNING;
    }
    private static final int AVFMTCTX_NOHEADER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMTCTX_NOHEADER 1
     * }
     */
    public static int AVFMTCTX_NOHEADER() {
        return AVFMTCTX_NOHEADER;
    }
    private static final int AVFMTCTX_UNSEEKABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMTCTX_UNSEEKABLE 2
     * }
     */
    public static int AVFMTCTX_UNSEEKABLE() {
        return AVFMTCTX_UNSEEKABLE;
    }
    private static final int AVFMT_FLAG_GENPTS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_GENPTS 1
     * }
     */
    public static int AVFMT_FLAG_GENPTS() {
        return AVFMT_FLAG_GENPTS;
    }
    private static final int AVFMT_FLAG_IGNIDX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_IGNIDX 2
     * }
     */
    public static int AVFMT_FLAG_IGNIDX() {
        return AVFMT_FLAG_IGNIDX;
    }
    private static final int AVFMT_FLAG_NONBLOCK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NONBLOCK 4
     * }
     */
    public static int AVFMT_FLAG_NONBLOCK() {
        return AVFMT_FLAG_NONBLOCK;
    }
    private static final int AVFMT_FLAG_IGNDTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_IGNDTS 8
     * }
     */
    public static int AVFMT_FLAG_IGNDTS() {
        return AVFMT_FLAG_IGNDTS;
    }
    private static final int AVFMT_FLAG_NOFILLIN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOFILLIN 16
     * }
     */
    public static int AVFMT_FLAG_NOFILLIN() {
        return AVFMT_FLAG_NOFILLIN;
    }
    private static final int AVFMT_FLAG_NOPARSE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOPARSE 32
     * }
     */
    public static int AVFMT_FLAG_NOPARSE() {
        return AVFMT_FLAG_NOPARSE;
    }
    private static final int AVFMT_FLAG_NOBUFFER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOBUFFER 64
     * }
     */
    public static int AVFMT_FLAG_NOBUFFER() {
        return AVFMT_FLAG_NOBUFFER;
    }
    private static final int AVFMT_FLAG_CUSTOM_IO = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_CUSTOM_IO 128
     * }
     */
    public static int AVFMT_FLAG_CUSTOM_IO() {
        return AVFMT_FLAG_CUSTOM_IO;
    }
    private static final int AVFMT_FLAG_DISCARD_CORRUPT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_DISCARD_CORRUPT 256
     * }
     */
    public static int AVFMT_FLAG_DISCARD_CORRUPT() {
        return AVFMT_FLAG_DISCARD_CORRUPT;
    }
    private static final int AVFMT_FLAG_FLUSH_PACKETS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_FLUSH_PACKETS 512
     * }
     */
    public static int AVFMT_FLAG_FLUSH_PACKETS() {
        return AVFMT_FLAG_FLUSH_PACKETS;
    }
    private static final int AVFMT_FLAG_BITEXACT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_BITEXACT 1024
     * }
     */
    public static int AVFMT_FLAG_BITEXACT() {
        return AVFMT_FLAG_BITEXACT;
    }
    private static final int AVFMT_FLAG_SORT_DTS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_SORT_DTS 65536
     * }
     */
    public static int AVFMT_FLAG_SORT_DTS() {
        return AVFMT_FLAG_SORT_DTS;
    }
    private static final int AVFMT_FLAG_FAST_SEEK = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_FAST_SEEK 524288
     * }
     */
    public static int AVFMT_FLAG_FAST_SEEK() {
        return AVFMT_FLAG_FAST_SEEK;
    }
    private static final int AVFMT_FLAG_AUTO_BSF = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_AUTO_BSF 2097152
     * }
     */
    public static int AVFMT_FLAG_AUTO_BSF() {
        return AVFMT_FLAG_AUTO_BSF;
    }
    private static final int FF_FDEBUG_TS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_FDEBUG_TS 1
     * }
     */
    public static int FF_FDEBUG_TS() {
        return FF_FDEBUG_TS;
    }
    private static final int AVFMT_EVENT_FLAG_METADATA_UPDATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_EVENT_FLAG_METADATA_UPDATED 1
     * }
     */
    public static int AVFMT_EVENT_FLAG_METADATA_UPDATED() {
        return AVFMT_EVENT_FLAG_METADATA_UPDATED;
    }
    private static final int AVFMT_AVOID_NEG_TS_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_DISABLED 0
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_DISABLED() {
        return AVFMT_AVOID_NEG_TS_DISABLED;
    }
    private static final int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE() {
        return AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE;
    }
    private static final int AVFMT_AVOID_NEG_TS_MAKE_ZERO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_MAKE_ZERO 2
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_MAKE_ZERO() {
        return AVFMT_AVOID_NEG_TS_MAKE_ZERO;
    }
    private static final int AVSEEK_FLAG_BACKWARD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_BACKWARD 1
     * }
     */
    public static int AVSEEK_FLAG_BACKWARD() {
        return AVSEEK_FLAG_BACKWARD;
    }
    private static final int AVSEEK_FLAG_BYTE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_BYTE 2
     * }
     */
    public static int AVSEEK_FLAG_BYTE() {
        return AVSEEK_FLAG_BYTE;
    }
    private static final int AVSEEK_FLAG_ANY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_ANY 4
     * }
     */
    public static int AVSEEK_FLAG_ANY() {
        return AVSEEK_FLAG_ANY;
    }
    private static final int AVSEEK_FLAG_FRAME = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_FRAME 8
     * }
     */
    public static int AVSEEK_FLAG_FRAME() {
        return AVSEEK_FLAG_FRAME;
    }
    private static final int AVSTREAM_INIT_IN_WRITE_HEADER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_INIT_IN_WRITE_HEADER 0
     * }
     */
    public static int AVSTREAM_INIT_IN_WRITE_HEADER() {
        return AVSTREAM_INIT_IN_WRITE_HEADER;
    }
    private static final int AVSTREAM_INIT_IN_INIT_OUTPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_INIT_IN_INIT_OUTPUT 1
     * }
     */
    public static int AVSTREAM_INIT_IN_INIT_OUTPUT() {
        return AVSTREAM_INIT_IN_INIT_OUTPUT;
    }
    private static final int AV_FRAME_FILENAME_FLAGS_MULTIPLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_FRAME_FILENAME_FLAGS_MULTIPLE 1
     * }
     */
    public static int AV_FRAME_FILENAME_FLAGS_MULTIPLE() {
        return AV_FRAME_FILENAME_FLAGS_MULTIPLE;
    }
    private static final int FF_LOSS_RESOLUTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_RESOLUTION 1
     * }
     */
    public static int FF_LOSS_RESOLUTION() {
        return FF_LOSS_RESOLUTION;
    }
    private static final int FF_LOSS_DEPTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_DEPTH 2
     * }
     */
    public static int FF_LOSS_DEPTH() {
        return FF_LOSS_DEPTH;
    }
    private static final int FF_LOSS_COLORSPACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_COLORSPACE 4
     * }
     */
    public static int FF_LOSS_COLORSPACE() {
        return FF_LOSS_COLORSPACE;
    }
    private static final int FF_LOSS_ALPHA = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_ALPHA 8
     * }
     */
    public static int FF_LOSS_ALPHA() {
        return FF_LOSS_ALPHA;
    }
    private static final int FF_LOSS_COLORQUANT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_COLORQUANT 16
     * }
     */
    public static int FF_LOSS_COLORQUANT() {
        return FF_LOSS_COLORQUANT;
    }
    private static final int FF_LOSS_CHROMA = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_CHROMA 32
     * }
     */
    public static int FF_LOSS_CHROMA() {
        return FF_LOSS_CHROMA;
    }
    private static final int FF_LOSS_EXCESS_RESOLUTION = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_EXCESS_RESOLUTION 64
     * }
     */
    public static int FF_LOSS_EXCESS_RESOLUTION() {
        return FF_LOSS_EXCESS_RESOLUTION;
    }
    private static final int FF_LOSS_EXCESS_DEPTH = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_EXCESS_DEPTH 128
     * }
     */
    public static int FF_LOSS_EXCESS_DEPTH() {
        return FF_LOSS_EXCESS_DEPTH;
    }
    private static final int LIBSWSCALE_VERSION_MAJOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MAJOR 9
     * }
     */
    public static int LIBSWSCALE_VERSION_MAJOR() {
        return LIBSWSCALE_VERSION_MAJOR;
    }
    private static final int LIBSWSCALE_VERSION_MINOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MINOR 1
     * }
     */
    public static int LIBSWSCALE_VERSION_MINOR() {
        return LIBSWSCALE_VERSION_MINOR;
    }
    private static final int LIBSWSCALE_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MICRO 100
     * }
     */
    public static int LIBSWSCALE_VERSION_MICRO() {
        return LIBSWSCALE_VERSION_MICRO;
    }
    private static final int SWS_SRC_V_CHR_DROP_MASK = (int)196608L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_MASK 196608
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_MASK() {
        return SWS_SRC_V_CHR_DROP_MASK;
    }
    private static final int SWS_SRC_V_CHR_DROP_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_SHIFT 16
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_SHIFT() {
        return SWS_SRC_V_CHR_DROP_SHIFT;
    }
    private static final int SWS_PARAM_DEFAULT = (int)123456L;
    /**
     * {@snippet lang=c :
     * #define SWS_PARAM_DEFAULT 123456
     * }
     */
    public static int SWS_PARAM_DEFAULT() {
        return SWS_PARAM_DEFAULT;
    }
    private static final int SWS_CS_ITU709 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU709 1
     * }
     */
    public static int SWS_CS_ITU709() {
        return SWS_CS_ITU709;
    }
    private static final int SWS_CS_FCC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_FCC 4
     * }
     */
    public static int SWS_CS_FCC() {
        return SWS_CS_FCC;
    }
    private static final int SWS_CS_ITU601 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU601 5
     * }
     */
    public static int SWS_CS_ITU601() {
        return SWS_CS_ITU601;
    }
    private static final int SWS_CS_ITU624 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU624 5
     * }
     */
    public static int SWS_CS_ITU624() {
        return SWS_CS_ITU624;
    }
    private static final int SWS_CS_SMPTE170M = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE170M 5
     * }
     */
    public static int SWS_CS_SMPTE170M() {
        return SWS_CS_SMPTE170M;
    }
    private static final int SWS_CS_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE240M 7
     * }
     */
    public static int SWS_CS_SMPTE240M() {
        return SWS_CS_SMPTE240M;
    }
    private static final int SWS_CS_DEFAULT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_DEFAULT 5
     * }
     */
    public static int SWS_CS_DEFAULT() {
        return SWS_CS_DEFAULT;
    }
    private static final int SWS_CS_BT2020 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_BT2020 9
     * }
     */
    public static int SWS_CS_BT2020() {
        return SWS_CS_BT2020;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = FFmpeg.C_LONG;
    private static final int AV_SAMPLE_FMT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_NONE = -1
     * }
     */
    public static int AV_SAMPLE_FMT_NONE() {
        return AV_SAMPLE_FMT_NONE;
    }
    private static final int AV_SAMPLE_FMT_U8 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_U8 = 0
     * }
     */
    public static int AV_SAMPLE_FMT_U8() {
        return AV_SAMPLE_FMT_U8;
    }
    private static final int AV_SAMPLE_FMT_S16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S16 = 1
     * }
     */
    public static int AV_SAMPLE_FMT_S16() {
        return AV_SAMPLE_FMT_S16;
    }
    private static final int AV_SAMPLE_FMT_S32 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S32 = 2
     * }
     */
    public static int AV_SAMPLE_FMT_S32() {
        return AV_SAMPLE_FMT_S32;
    }
    private static final int AV_SAMPLE_FMT_FLT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_FLT = 3
     * }
     */
    public static int AV_SAMPLE_FMT_FLT() {
        return AV_SAMPLE_FMT_FLT;
    }
    private static final int AV_SAMPLE_FMT_DBL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_DBL = 4
     * }
     */
    public static int AV_SAMPLE_FMT_DBL() {
        return AV_SAMPLE_FMT_DBL;
    }
    private static final int AV_SAMPLE_FMT_U8P = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_U8P = 5
     * }
     */
    public static int AV_SAMPLE_FMT_U8P() {
        return AV_SAMPLE_FMT_U8P;
    }
    private static final int AV_SAMPLE_FMT_S16P = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S16P = 6
     * }
     */
    public static int AV_SAMPLE_FMT_S16P() {
        return AV_SAMPLE_FMT_S16P;
    }
    private static final int AV_SAMPLE_FMT_S32P = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S32P = 7
     * }
     */
    public static int AV_SAMPLE_FMT_S32P() {
        return AV_SAMPLE_FMT_S32P;
    }
    private static final int AV_SAMPLE_FMT_FLTP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_FLTP = 8
     * }
     */
    public static int AV_SAMPLE_FMT_FLTP() {
        return AV_SAMPLE_FMT_FLTP;
    }
    private static final int AV_SAMPLE_FMT_DBLP = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_DBLP = 9
     * }
     */
    public static int AV_SAMPLE_FMT_DBLP() {
        return AV_SAMPLE_FMT_DBLP;
    }
    private static final int AV_SAMPLE_FMT_S64 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S64 = 10
     * }
     */
    public static int AV_SAMPLE_FMT_S64() {
        return AV_SAMPLE_FMT_S64;
    }
    private static final int AV_SAMPLE_FMT_S64P = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S64P = 11
     * }
     */
    public static int AV_SAMPLE_FMT_S64P() {
        return AV_SAMPLE_FMT_S64P;
    }
    private static final int AV_SAMPLE_FMT_NB = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_NB = 12
     * }
     */
    public static int AV_SAMPLE_FMT_NB() {
        return AV_SAMPLE_FMT_NB;
    }

    private static class av_get_sample_fmt_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_sample_fmt_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_sample_fmt_name$descriptor() {
        return av_get_sample_fmt_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_sample_fmt_name$handle() {
        return av_get_sample_fmt_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_name$address() {
        return av_get_sample_fmt_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_name(int sample_fmt) {
        var mh$ = av_get_sample_fmt_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_sample_fmt_name", sample_fmt);
            }
            return (MemorySegment)mh$.invokeExact(sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static FunctionDescriptor av_get_sample_fmt$descriptor() {
        return av_get_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static MethodHandle av_get_sample_fmt$handle() {
        return av_get_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static MemorySegment av_get_sample_fmt$address() {
        return av_get_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static int av_get_sample_fmt(MemorySegment name) {
        var mh$ = av_get_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_sample_fmt", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_alt_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_alt_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static FunctionDescriptor av_get_alt_sample_fmt$descriptor() {
        return av_get_alt_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static MethodHandle av_get_alt_sample_fmt$handle() {
        return av_get_alt_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static MemorySegment av_get_alt_sample_fmt$address() {
        return av_get_alt_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static int av_get_alt_sample_fmt(int sample_fmt, int planar) {
        var mh$ = av_get_alt_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_alt_sample_fmt", sample_fmt, planar);
            }
            return (int)mh$.invokeExact(sample_fmt, planar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_packed_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_packed_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_packed_sample_fmt$descriptor() {
        return av_get_packed_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_packed_sample_fmt$handle() {
        return av_get_packed_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_packed_sample_fmt$address() {
        return av_get_packed_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_get_packed_sample_fmt(int sample_fmt) {
        var mh$ = av_get_packed_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_packed_sample_fmt", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_planar_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_planar_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_planar_sample_fmt$descriptor() {
        return av_get_planar_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_planar_sample_fmt$handle() {
        return av_get_planar_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_planar_sample_fmt$address() {
        return av_get_planar_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_get_planar_sample_fmt(int sample_fmt) {
        var mh$ = av_get_planar_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_planar_sample_fmt", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_sample_fmt_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_sample_fmt_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_sample_fmt_string$descriptor() {
        return av_get_sample_fmt_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_sample_fmt_string$handle() {
        return av_get_sample_fmt_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_string$address() {
        return av_get_sample_fmt_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_string(MemorySegment buf, int buf_size, int sample_fmt) {
        var mh$ = av_get_sample_fmt_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_sample_fmt_string", buf, buf_size, sample_fmt);
            }
            return (MemorySegment)mh$.invokeExact(buf, buf_size, sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_bytes_per_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_bytes_per_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_bytes_per_sample$descriptor() {
        return av_get_bytes_per_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_bytes_per_sample$handle() {
        return av_get_bytes_per_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_bytes_per_sample$address() {
        return av_get_bytes_per_sample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_get_bytes_per_sample(int sample_fmt) {
        var mh$ = av_get_bytes_per_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_bytes_per_sample", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sample_fmt_is_planar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_sample_fmt_is_planar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_sample_fmt_is_planar$descriptor() {
        return av_sample_fmt_is_planar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_sample_fmt_is_planar$handle() {
        return av_sample_fmt_is_planar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_sample_fmt_is_planar$address() {
        return av_sample_fmt_is_planar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_sample_fmt_is_planar(int sample_fmt) {
        var mh$ = av_sample_fmt_is_planar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sample_fmt_is_planar", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_samples_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_get_buffer_size$descriptor() {
        return av_samples_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_get_buffer_size$handle() {
        return av_samples_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_get_buffer_size$address() {
        return av_samples_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_get_buffer_size(MemorySegment linesize, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_get_buffer_size", linesize, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(linesize, nb_channels, nb_samples, sample_fmt, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_fill_arrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_samples_fill_arrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_fill_arrays$descriptor() {
        return av_samples_fill_arrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_fill_arrays$handle() {
        return av_samples_fill_arrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_fill_arrays$address() {
        return av_samples_fill_arrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_fill_arrays(MemorySegment audio_data, MemorySegment linesize, MemorySegment buf, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_fill_arrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_fill_arrays", audio_data, linesize, buf, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(audio_data, linesize, buf, nb_channels, nb_samples, sample_fmt, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_samples_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_alloc$descriptor() {
        return av_samples_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_alloc$handle() {
        return av_samples_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_alloc$address() {
        return av_samples_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_alloc(MemorySegment audio_data, MemorySegment linesize, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_alloc", audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_alloc_array_and_samples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_samples_alloc_array_and_samples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_alloc_array_and_samples$descriptor() {
        return av_samples_alloc_array_and_samples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_alloc_array_and_samples$handle() {
        return av_samples_alloc_array_and_samples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_alloc_array_and_samples$address() {
        return av_samples_alloc_array_and_samples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_alloc_array_and_samples(MemorySegment audio_data, MemorySegment linesize, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_alloc_array_and_samples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_alloc_array_and_samples", audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_samples_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_samples_copy$descriptor() {
        return av_samples_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_samples_copy$handle() {
        return av_samples_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_samples_copy$address() {
        return av_samples_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_samples_copy(MemorySegment dst, MemorySegment src, int dst_offset, int src_offset, int nb_samples, int nb_channels, int sample_fmt) {
        var mh$ = av_samples_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_copy", dst, src, dst_offset, src_offset, nb_samples, nb_channels, sample_fmt);
            }
            return (int)mh$.invokeExact(dst, src, dst_offset, src_offset, nb_samples, nb_channels, sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_set_silence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_samples_set_silence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_samples_set_silence$descriptor() {
        return av_samples_set_silence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_samples_set_silence$handle() {
        return av_samples_set_silence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_samples_set_silence$address() {
        return av_samples_set_silence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_samples_set_silence(MemorySegment audio_data, int offset, int nb_samples, int nb_channels, int sample_fmt) {
        var mh$ = av_samples_set_silence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_set_silence", audio_data, offset, nb_samples, nb_channels, sample_fmt);
            }
            return (int)mh$.invokeExact(audio_data, offset, nb_samples, nb_channels, sample_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avutil_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static FunctionDescriptor avutil_version$descriptor() {
        return avutil_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MethodHandle avutil_version$handle() {
        return avutil_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MemorySegment avutil_version$address() {
        return avutil_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static int avutil_version() {
        var mh$ = avutil_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_version_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_version_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static FunctionDescriptor av_version_info$descriptor() {
        return av_version_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MethodHandle av_version_info$handle() {
        return av_version_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info$address() {
        return av_version_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info() {
        var mh$ = av_version_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_version_info");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avutil_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static FunctionDescriptor avutil_configuration$descriptor() {
        return avutil_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MethodHandle avutil_configuration$handle() {
        return avutil_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration$address() {
        return avutil_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration() {
        var mh$ = avutil_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avutil_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static FunctionDescriptor avutil_license$descriptor() {
        return avutil_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MethodHandle avutil_license$handle() {
        return avutil_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license$address() {
        return avutil_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license() {
        var mh$ = avutil_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVMEDIA_TYPE_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_UNKNOWN = -1
     * }
     */
    public static int AVMEDIA_TYPE_UNKNOWN() {
        return AVMEDIA_TYPE_UNKNOWN;
    }
    private static final int AVMEDIA_TYPE_VIDEO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_VIDEO = 0
     * }
     */
    public static int AVMEDIA_TYPE_VIDEO() {
        return AVMEDIA_TYPE_VIDEO;
    }
    private static final int AVMEDIA_TYPE_AUDIO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_AUDIO = 1
     * }
     */
    public static int AVMEDIA_TYPE_AUDIO() {
        return AVMEDIA_TYPE_AUDIO;
    }
    private static final int AVMEDIA_TYPE_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_DATA = 2
     * }
     */
    public static int AVMEDIA_TYPE_DATA() {
        return AVMEDIA_TYPE_DATA;
    }
    private static final int AVMEDIA_TYPE_SUBTITLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_SUBTITLE = 3
     * }
     */
    public static int AVMEDIA_TYPE_SUBTITLE() {
        return AVMEDIA_TYPE_SUBTITLE;
    }
    private static final int AVMEDIA_TYPE_ATTACHMENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_ATTACHMENT = 4
     * }
     */
    public static int AVMEDIA_TYPE_ATTACHMENT() {
        return AVMEDIA_TYPE_ATTACHMENT;
    }
    private static final int AVMEDIA_TYPE_NB = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_NB = 5
     * }
     */
    public static int AVMEDIA_TYPE_NB() {
        return AVMEDIA_TYPE_NB;
    }

    private static class av_get_media_type_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_media_type_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static FunctionDescriptor av_get_media_type_string$descriptor() {
        return av_get_media_type_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MethodHandle av_get_media_type_string$handle() {
        return av_get_media_type_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string$address() {
        return av_get_media_type_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string(int media_type) {
        var mh$ = av_get_media_type_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_media_type_string", media_type);
            }
            return (MemorySegment)mh$.invokeExact(media_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PICTURE_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_NONE = 0
     * }
     */
    public static int AV_PICTURE_TYPE_NONE() {
        return AV_PICTURE_TYPE_NONE;
    }
    private static final int AV_PICTURE_TYPE_I = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_I = 1
     * }
     */
    public static int AV_PICTURE_TYPE_I() {
        return AV_PICTURE_TYPE_I;
    }
    private static final int AV_PICTURE_TYPE_P = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_P = 2
     * }
     */
    public static int AV_PICTURE_TYPE_P() {
        return AV_PICTURE_TYPE_P;
    }
    private static final int AV_PICTURE_TYPE_B = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_B = 3
     * }
     */
    public static int AV_PICTURE_TYPE_B() {
        return AV_PICTURE_TYPE_B;
    }
    private static final int AV_PICTURE_TYPE_S = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_S = 4
     * }
     */
    public static int AV_PICTURE_TYPE_S() {
        return AV_PICTURE_TYPE_S;
    }
    private static final int AV_PICTURE_TYPE_SI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SI = 5
     * }
     */
    public static int AV_PICTURE_TYPE_SI() {
        return AV_PICTURE_TYPE_SI;
    }
    private static final int AV_PICTURE_TYPE_SP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SP = 6
     * }
     */
    public static int AV_PICTURE_TYPE_SP() {
        return AV_PICTURE_TYPE_SP;
    }
    private static final int AV_PICTURE_TYPE_BI = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_BI = 7
     * }
     */
    public static int AV_PICTURE_TYPE_BI() {
        return AV_PICTURE_TYPE_BI;
    }

    private static class av_get_picture_type_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_CHAR,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_picture_type_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static FunctionDescriptor av_get_picture_type_char$descriptor() {
        return av_get_picture_type_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MethodHandle av_get_picture_type_char$handle() {
        return av_get_picture_type_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MemorySegment av_get_picture_type_char$address() {
        return av_get_picture_type_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static byte av_get_picture_type_char(int pict_type) {
        var mh$ = av_get_picture_type_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_picture_type_char", pict_type);
            }
            return (byte)mh$.invokeExact(pict_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __errno_location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__errno_location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static FunctionDescriptor __errno_location$descriptor() {
        return __errno_location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MethodHandle __errno_location$handle() {
        return __errno_location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location$address() {
        return __errno_location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location() {
        var mh$ = __errno_location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__errno_location");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = FFmpeg.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = FFmpeg.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = FFmpeg.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = FFmpeg.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = FFmpeg.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = FFmpeg.C_DOUBLE;

    private static class __fpclassify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fpclassify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static FunctionDescriptor __fpclassify$descriptor() {
        return __fpclassify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static MethodHandle __fpclassify$handle() {
        return __fpclassify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static MemorySegment __fpclassify$address() {
        return __fpclassify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassify(double __value)
     * }
     */
    public static int __fpclassify(double __value) {
        var mh$ = __fpclassify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassify", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __signbit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__signbit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static FunctionDescriptor __signbit$descriptor() {
        return __signbit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static MethodHandle __signbit$handle() {
        return __signbit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static MemorySegment __signbit$address() {
        return __signbit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __signbit(double __value)
     * }
     */
    public static int __signbit(double __value) {
        var mh$ = __signbit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__signbit", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__isinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static FunctionDescriptor __isinf$descriptor() {
        return __isinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static MethodHandle __isinf$handle() {
        return __isinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static MemorySegment __isinf$address() {
        return __isinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isinf(double __value)
     * }
     */
    public static int __isinf(double __value) {
        var mh$ = __isinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isinf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __finite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__finite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static FunctionDescriptor __finite$descriptor() {
        return __finite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static MethodHandle __finite$handle() {
        return __finite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static MemorySegment __finite$address() {
        return __finite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __finite(double __value)
     * }
     */
    public static int __finite(double __value) {
        var mh$ = __finite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__finite", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isnan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__isnan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static FunctionDescriptor __isnan$descriptor() {
        return __isnan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static MethodHandle __isnan$handle() {
        return __isnan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static MemorySegment __isnan$address() {
        return __isnan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isnan(double __value)
     * }
     */
    public static int __isnan(double __value) {
        var mh$ = __isnan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isnan", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iseqsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__iseqsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __iseqsig$descriptor() {
        return __iseqsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static MethodHandle __iseqsig$handle() {
        return __iseqsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static MemorySegment __iseqsig$address() {
        return __iseqsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __iseqsig(double __x, double __y)
     * }
     */
    public static int __iseqsig(double __x, double __y) {
        var mh$ = __iseqsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iseqsig", __x, __y);
            }
            return (int)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __issignaling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__issignaling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static FunctionDescriptor __issignaling$descriptor() {
        return __issignaling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static MethodHandle __issignaling$handle() {
        return __issignaling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static MemorySegment __issignaling$address() {
        return __issignaling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __issignaling(double __value)
     * }
     */
    public static int __issignaling(double __value) {
        var mh$ = __issignaling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__issignaling", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acos(double __x)
     * }
     */
    public static double acos(double __x) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static FunctionDescriptor __acos$descriptor() {
        return __acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static MethodHandle __acos$handle() {
        return __acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static MemorySegment __acos$address() {
        return __acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __acos(double __x)
     * }
     */
    public static double __acos(double __x) {
        var mh$ = __acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asin(double __x)
     * }
     */
    public static double asin(double __x) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static FunctionDescriptor __asin$descriptor() {
        return __asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static MethodHandle __asin$handle() {
        return __asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static MemorySegment __asin$address() {
        return __asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __asin(double __x)
     * }
     */
    public static double __asin(double __x) {
        var mh$ = __asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan(double __x)
     * }
     */
    public static double atan(double __x) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static FunctionDescriptor __atan$descriptor() {
        return __atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static MethodHandle __atan$handle() {
        return __atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static MemorySegment __atan$address() {
        return __atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __atan(double __x)
     * }
     */
    public static double __atan(double __x) {
        var mh$ = __atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan2(double __y, double __x)
     * }
     */
    public static double atan2(double __y, double __x) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", __y, __x);
            }
            return (double)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static FunctionDescriptor __atan2$descriptor() {
        return __atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static MethodHandle __atan2$handle() {
        return __atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static MemorySegment __atan2$address() {
        return __atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __atan2(double __y, double __x)
     * }
     */
    public static double __atan2(double __y, double __x) {
        var mh$ = __atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atan2", __y, __x);
            }
            return (double)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cos(double __x)
     * }
     */
    public static double cos(double __x) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static FunctionDescriptor __cos$descriptor() {
        return __cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static MethodHandle __cos$handle() {
        return __cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static MemorySegment __cos$address() {
        return __cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cos(double __x)
     * }
     */
    public static double __cos(double __x) {
        var mh$ = __cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cos", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sin(double __x)
     * }
     */
    public static double sin(double __x) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static FunctionDescriptor __sin$descriptor() {
        return __sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static MethodHandle __sin$handle() {
        return __sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static MemorySegment __sin$address() {
        return __sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sin(double __x)
     * }
     */
    public static double __sin(double __x) {
        var mh$ = __sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sin", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tan(double __x)
     * }
     */
    public static double tan(double __x) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static FunctionDescriptor __tan$descriptor() {
        return __tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static MethodHandle __tan$handle() {
        return __tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static MemorySegment __tan$address() {
        return __tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tan(double __x)
     * }
     */
    public static double __tan(double __x) {
        var mh$ = __tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tan", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cosh(double __x)
     * }
     */
    public static double cosh(double __x) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static FunctionDescriptor __cosh$descriptor() {
        return __cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static MethodHandle __cosh$handle() {
        return __cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static MemorySegment __cosh$address() {
        return __cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cosh(double __x)
     * }
     */
    public static double __cosh(double __x) {
        var mh$ = __cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sinh(double __x)
     * }
     */
    public static double sinh(double __x) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static FunctionDescriptor __sinh$descriptor() {
        return __sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static MethodHandle __sinh$handle() {
        return __sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static MemorySegment __sinh$address() {
        return __sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sinh(double __x)
     * }
     */
    public static double __sinh(double __x) {
        var mh$ = __sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tanh(double __x)
     * }
     */
    public static double tanh(double __x) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static FunctionDescriptor __tanh$descriptor() {
        return __tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static MethodHandle __tanh$handle() {
        return __tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static MemorySegment __tanh$address() {
        return __tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tanh(double __x)
     * }
     */
    public static double __tanh(double __x) {
        var mh$ = __tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acosh(double __x)
     * }
     */
    public static double acosh(double __x) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static FunctionDescriptor __acosh$descriptor() {
        return __acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static MethodHandle __acosh$handle() {
        return __acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static MemorySegment __acosh$address() {
        return __acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __acosh(double __x)
     * }
     */
    public static double __acosh(double __x) {
        var mh$ = __acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acosh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asinh(double __x)
     * }
     */
    public static double asinh(double __x) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static FunctionDescriptor __asinh$descriptor() {
        return __asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static MethodHandle __asinh$handle() {
        return __asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static MemorySegment __asinh$address() {
        return __asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __asinh(double __x)
     * }
     */
    public static double __asinh(double __x) {
        var mh$ = __asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atanh(double __x)
     * }
     */
    public static double atanh(double __x) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static FunctionDescriptor __atanh$descriptor() {
        return __atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static MethodHandle __atanh$handle() {
        return __atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static MemorySegment __atanh$address() {
        return __atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __atanh(double __x)
     * }
     */
    public static double __atanh(double __x) {
        var mh$ = __atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanh", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static double exp(double __x) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static FunctionDescriptor __exp$descriptor() {
        return __exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static MethodHandle __exp$handle() {
        return __exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static MemorySegment __exp$address() {
        return __exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static double __exp(double __x) {
        var mh$ = __exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static double frexp(double __x, MemorySegment __exponent) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor __frexp$descriptor() {
        return __frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static MethodHandle __frexp$handle() {
        return __frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static MemorySegment __frexp$address() {
        return __frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static double __frexp(double __x, MemorySegment __exponent) {
        var mh$ = __frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__frexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static double ldexp(double __x, int __exponent) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static FunctionDescriptor __ldexp$descriptor() {
        return __ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static MethodHandle __ldexp$handle() {
        return __ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static MemorySegment __ldexp$address() {
        return __ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static double __ldexp(double __x, int __exponent) {
        var mh$ = __ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ldexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static double log(double __x) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static FunctionDescriptor __log$descriptor() {
        return __log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static MethodHandle __log$handle() {
        return __log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static MemorySegment __log$address() {
        return __log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static double __log(double __x) {
        var mh$ = __log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static double log10(double __x) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static FunctionDescriptor __log10$descriptor() {
        return __log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static MethodHandle __log10$handle() {
        return __log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static MemorySegment __log10$address() {
        return __log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static double __log10(double __x) {
        var mh$ = __log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log10", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static double modf(double __x, MemorySegment __iptr) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", __x, __iptr);
            }
            return (double)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static FunctionDescriptor __modf$descriptor() {
        return __modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static MethodHandle __modf$handle() {
        return __modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static MemorySegment __modf$address() {
        return __modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static double __modf(double __x, MemorySegment __iptr) {
        var mh$ = __modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__modf", __x, __iptr);
            }
            return (double)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static double expm1(double __x) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static FunctionDescriptor __expm1$descriptor() {
        return __expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static MethodHandle __expm1$handle() {
        return __expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static MemorySegment __expm1$address() {
        return __expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static double __expm1(double __x) {
        var mh$ = __expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expm1", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static double log1p(double __x) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static FunctionDescriptor __log1p$descriptor() {
        return __log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static MethodHandle __log1p$handle() {
        return __log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static MemorySegment __log1p$address() {
        return __log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static double __log1p(double __x) {
        var mh$ = __log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log1p", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static double logb(double __x) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static FunctionDescriptor __logb$descriptor() {
        return __logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static MethodHandle __logb$handle() {
        return __logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static MemorySegment __logb$address() {
        return __logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static double __logb(double __x) {
        var mh$ = __logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logb", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static double exp2(double __x) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static FunctionDescriptor __exp2$descriptor() {
        return __exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static MethodHandle __exp2$handle() {
        return __exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static MemorySegment __exp2$address() {
        return __exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static double __exp2(double __x) {
        var mh$ = __exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static double log2(double __x) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static FunctionDescriptor __log2$descriptor() {
        return __log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static MethodHandle __log2$handle() {
        return __log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static MemorySegment __log2$address() {
        return __log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static double __log2(double __x) {
        var mh$ = __log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static double pow(double __x, double __y) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __pow$descriptor() {
        return __pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static MethodHandle __pow$handle() {
        return __pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static MemorySegment __pow$address() {
        return __pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static double __pow(double __x, double __y) {
        var mh$ = __pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static double sqrt(double __x) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static FunctionDescriptor __sqrt$descriptor() {
        return __sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static MethodHandle __sqrt$handle() {
        return __sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static MemorySegment __sqrt$address() {
        return __sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static double __sqrt(double __x) {
        var mh$ = __sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sqrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static double hypot(double __x, double __y) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __hypot$descriptor() {
        return __hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static MethodHandle __hypot$handle() {
        return __hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static MemorySegment __hypot$address() {
        return __hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static double __hypot(double __x, double __y) {
        var mh$ = __hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__hypot", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static double cbrt(double __x) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static FunctionDescriptor __cbrt$descriptor() {
        return __cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static MethodHandle __cbrt$handle() {
        return __cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static MemorySegment __cbrt$address() {
        return __cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static double __cbrt(double __x) {
        var mh$ = __cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cbrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static double ceil(double __x) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static double fabs(double __x) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static double floor(double __x) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static double fmod(double __x, double __y) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmod$descriptor() {
        return __fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static MethodHandle __fmod$handle() {
        return __fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static MemorySegment __fmod$address() {
        return __fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static double __fmod(double __x, double __y) {
        var mh$ = __fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmod", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("isinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static FunctionDescriptor isinf$descriptor() {
        return isinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static MethodHandle isinf$handle() {
        return isinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static MemorySegment isinf$address() {
        return isinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static int isinf(double __value) {
        var mh$ = isinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isinf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class finite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("finite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static FunctionDescriptor finite$descriptor() {
        return finite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static MethodHandle finite$handle() {
        return finite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static MemorySegment finite$address() {
        return finite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static int finite(double __value) {
        var mh$ = finite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("finite", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("drem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static FunctionDescriptor drem$descriptor() {
        return drem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static MethodHandle drem$handle() {
        return drem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static MemorySegment drem$address() {
        return drem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static double drem(double __x, double __y) {
        var mh$ = drem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drem", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __drem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__drem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __drem$descriptor() {
        return __drem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static MethodHandle __drem$handle() {
        return __drem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static MemorySegment __drem$address() {
        return __drem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static double __drem(double __x, double __y) {
        var mh$ = __drem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__drem", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class significand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("significand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static FunctionDescriptor significand$descriptor() {
        return significand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static MethodHandle significand$handle() {
        return significand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static MemorySegment significand$address() {
        return significand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static double significand(double __x) {
        var mh$ = significand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("significand", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __significand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__significand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static FunctionDescriptor __significand$descriptor() {
        return __significand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static MethodHandle __significand$handle() {
        return __significand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static MemorySegment __significand$address() {
        return __significand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static double __significand(double __x) {
        var mh$ = __significand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__significand", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static double copysign(double __x, double __y) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static double nan(MemorySegment __tagb) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", __tagb);
            }
            return (double)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static FunctionDescriptor __nan$descriptor() {
        return __nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static MethodHandle __nan$handle() {
        return __nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static MemorySegment __nan$address() {
        return __nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static double __nan(MemorySegment __tagb) {
        var mh$ = __nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nan", __tagb);
            }
            return (double)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isnan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("isnan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static FunctionDescriptor isnan$descriptor() {
        return isnan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static MethodHandle isnan$handle() {
        return isnan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static MemorySegment isnan$address() {
        return isnan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static int isnan(double __value) {
        var mh$ = isnan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isnan", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static FunctionDescriptor __j0$descriptor() {
        return __j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static MethodHandle __j0$handle() {
        return __j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static MemorySegment __j0$address() {
        return __j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static double __j0(double x0) {
        var mh$ = __j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static FunctionDescriptor __j1$descriptor() {
        return __j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static MethodHandle __j1$handle() {
        return __j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static MemorySegment __j1$address() {
        return __j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static double __j1(double x0) {
        var mh$ = __j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static FunctionDescriptor __jn$descriptor() {
        return __jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static MethodHandle __jn$handle() {
        return __jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static MemorySegment __jn$address() {
        return __jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static double __jn(int x0, double x1) {
        var mh$ = __jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static FunctionDescriptor __y0$descriptor() {
        return __y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static MethodHandle __y0$handle() {
        return __y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static MemorySegment __y0$address() {
        return __y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static double __y0(double x0) {
        var mh$ = __y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static FunctionDescriptor __y1$descriptor() {
        return __y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static MethodHandle __y1$handle() {
        return __y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static MemorySegment __y1$address() {
        return __y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static double __y1(double x0) {
        var mh$ = __y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static FunctionDescriptor __yn$descriptor() {
        return __yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static MethodHandle __yn$handle() {
        return __yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static MemorySegment __yn$address() {
        return __yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static double __yn(int x0, double x1) {
        var mh$ = __yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static FunctionDescriptor __erf$descriptor() {
        return __erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static MethodHandle __erf$handle() {
        return __erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static MemorySegment __erf$address() {
        return __erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static double __erf(double x0) {
        var mh$ = __erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static FunctionDescriptor __erfc$descriptor() {
        return __erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static MethodHandle __erfc$handle() {
        return __erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static MemorySegment __erfc$address() {
        return __erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static double __erfc(double x0) {
        var mh$ = __erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static FunctionDescriptor __lgamma$descriptor() {
        return __lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static MethodHandle __lgamma$handle() {
        return __lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static MemorySegment __lgamma$address() {
        return __lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static double __lgamma(double x0) {
        var mh$ = __lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static FunctionDescriptor __tgamma$descriptor() {
        return __tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static MethodHandle __tgamma$handle() {
        return __tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static MemorySegment __tgamma$address() {
        return __tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static double __tgamma(double x0) {
        var mh$ = __tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("gamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static FunctionDescriptor gamma$descriptor() {
        return gamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static MethodHandle gamma$handle() {
        return gamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static MemorySegment gamma$address() {
        return gamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static double gamma(double x0) {
        var mh$ = gamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__gamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static FunctionDescriptor __gamma$descriptor() {
        return __gamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static MethodHandle __gamma$handle() {
        return __gamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static MemorySegment __gamma$address() {
        return __gamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static double __gamma(double x0) {
        var mh$ = __gamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static FunctionDescriptor lgamma_r$descriptor() {
        return lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static MethodHandle lgamma_r$handle() {
        return lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static MemorySegment lgamma_r$address() {
        return lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static double lgamma_r(double x0, MemorySegment __signgamp) {
        var mh$ = lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma_r", x0, __signgamp);
            }
            return (double)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static FunctionDescriptor __lgamma_r$descriptor() {
        return __lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static MethodHandle __lgamma_r$handle() {
        return __lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static MemorySegment __lgamma_r$address() {
        return __lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static double __lgamma_r(double x0, MemorySegment __signgamp) {
        var mh$ = __lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgamma_r", x0, __signgamp);
            }
            return (double)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static double rint(double __x) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static FunctionDescriptor __rint$descriptor() {
        return __rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static MethodHandle __rint$handle() {
        return __rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static MemorySegment __rint$address() {
        return __rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static double __rint(double __x) {
        var mh$ = __rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__rint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static double nextafter(double __x, double __y) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __nextafter$descriptor() {
        return __nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static MethodHandle __nextafter$handle() {
        return __nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static MemorySegment __nextafter$address() {
        return __nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static double __nextafter(double __x, double __y) {
        var mh$ = __nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nextafter", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static double remainder(double __x, double __y) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __remainder$descriptor() {
        return __remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static MethodHandle __remainder$handle() {
        return __remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static MemorySegment __remainder$address() {
        return __remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static double __remainder(double __x, double __y) {
        var mh$ = __remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remainder", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static double scalbn(double __x, int __n) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static FunctionDescriptor __scalbn$descriptor() {
        return __scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static MethodHandle __scalbn$handle() {
        return __scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static MemorySegment __scalbn$address() {
        return __scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static double __scalbn(double __x, int __n) {
        var mh$ = __scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbn", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static int ilogb(double __x) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static FunctionDescriptor __ilogb$descriptor() {
        return __ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static MethodHandle __ilogb$handle() {
        return __ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static MemorySegment __ilogb$address() {
        return __ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static int __ilogb(double __x) {
        var mh$ = __ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ilogb", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static double scalbln(double __x, long __n) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static FunctionDescriptor __scalbln$descriptor() {
        return __scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static MethodHandle __scalbln$handle() {
        return __scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static MemorySegment __scalbln$address() {
        return __scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static double __scalbln(double __x, long __n) {
        var mh$ = __scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbln", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static double nearbyint(double __x) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static FunctionDescriptor __nearbyint$descriptor() {
        return __nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static MethodHandle __nearbyint$handle() {
        return __nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static MemorySegment __nearbyint$address() {
        return __nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static double __nearbyint(double __x) {
        var mh$ = __nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nearbyint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static double round(double __x) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static double trunc(double __x) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static double remquo(double __x, double __y, MemorySegment __quo) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", __x, __y, __quo);
            }
            return (double)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static FunctionDescriptor __remquo$descriptor() {
        return __remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MethodHandle __remquo$handle() {
        return __remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MemorySegment __remquo$address() {
        return __remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static double __remquo(double __x, double __y, MemorySegment __quo) {
        var mh$ = __remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remquo", __x, __y, __quo);
            }
            return (double)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static long lrint(double __x) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static FunctionDescriptor __lrint$descriptor() {
        return __lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static MethodHandle __lrint$handle() {
        return __lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static MemorySegment __lrint$address() {
        return __lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static long __lrint(double __x) {
        var mh$ = __lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static long llrint(double __x) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static FunctionDescriptor __llrint$descriptor() {
        return __llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static MethodHandle __llrint$handle() {
        return __llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static MemorySegment __llrint$address() {
        return __llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static long __llrint(double __x) {
        var mh$ = __llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static long lround(double __x) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static FunctionDescriptor __lround$descriptor() {
        return __lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static MethodHandle __lround$handle() {
        return __lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static MemorySegment __lround$address() {
        return __lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static long __lround(double __x) {
        var mh$ = __lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static long llround(double __x) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static FunctionDescriptor __llround$descriptor() {
        return __llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static MethodHandle __llround$handle() {
        return __llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static MemorySegment __llround$address() {
        return __llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static long __llround(double __x) {
        var mh$ = __llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static double fdim(double __x, double __y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fdim$descriptor() {
        return __fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static MethodHandle __fdim$handle() {
        return __fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static MemorySegment __fdim$address() {
        return __fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static double __fdim(double __x, double __y) {
        var mh$ = __fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static double fmax(double __x, double __y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static double fmin(double __x, double __y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static double fma(double __x, double __y, double __z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor __fma$descriptor() {
        return __fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle __fma$handle() {
        return __fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static MemorySegment __fma$address() {
        return __fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static double __fma(double __x, double __y, double __z) {
        var mh$ = __fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static double scalb(double __x, double __n) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor __scalb$descriptor() {
        return __scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static MethodHandle __scalb$handle() {
        return __scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static MemorySegment __scalb$address() {
        return __scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static double __scalb(double __x, double __n) {
        var mh$ = __scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static int __fpclassifyf(float __value) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __signbitf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__signbitf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static FunctionDescriptor __signbitf$descriptor() {
        return __signbitf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static MethodHandle __signbitf$handle() {
        return __signbitf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static MemorySegment __signbitf$address() {
        return __signbitf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static int __signbitf(float __value) {
        var mh$ = __signbitf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__signbitf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isinff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__isinff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static FunctionDescriptor __isinff$descriptor() {
        return __isinff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static MethodHandle __isinff$handle() {
        return __isinff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static MemorySegment __isinff$address() {
        return __isinff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static int __isinff(float __value) {
        var mh$ = __isinff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isinff", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static FunctionDescriptor __finitef$descriptor() {
        return __finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static MethodHandle __finitef$handle() {
        return __finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static MemorySegment __finitef$address() {
        return __finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static int __finitef(float __value) {
        var mh$ = __finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__finitef", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static FunctionDescriptor __isnanf$descriptor() {
        return __isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static MethodHandle __isnanf$handle() {
        return __isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static MemorySegment __isnanf$address() {
        return __isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static int __isnanf(float __value) {
        var mh$ = __isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isnanf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

