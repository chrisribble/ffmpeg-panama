// Generated by jextract

package io.github.chrisribble.ffmpeg8;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct AVRTCPSenderReport {
 *     uint32_t ssrc;
 *     uint64_t ntp_timestamp;
 *     uint32_t rtp_timestamp;
 *     uint32_t sender_nb_packets;
 *     uint32_t sender_nb_bytes;
 * }
 * }
 */
public class AVRTCPSenderReport {

    AVRTCPSenderReport() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        FFmpeg.C_INT.withName("ssrc"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_LONG.withName("ntp_timestamp"),
        FFmpeg.C_INT.withName("rtp_timestamp"),
        FFmpeg.C_INT.withName("sender_nb_packets"),
        FFmpeg.C_INT.withName("sender_nb_bytes"),
        MemoryLayout.paddingLayout(4)
    ).withName("AVRTCPSenderReport");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt ssrc$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ssrc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t ssrc
     * }
     */
    public static final OfInt ssrc$layout() {
        return ssrc$LAYOUT;
    }

    private static final long ssrc$OFFSET = $LAYOUT.byteOffset(groupElement("ssrc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t ssrc
     * }
     */
    public static final long ssrc$offset() {
        return ssrc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t ssrc
     * }
     */
    public static int ssrc(MemorySegment struct) {
        return struct.get(ssrc$LAYOUT, ssrc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t ssrc
     * }
     */
    public static void ssrc(MemorySegment struct, int fieldValue) {
        struct.set(ssrc$LAYOUT, ssrc$OFFSET, fieldValue);
    }

    private static final OfLong ntp_timestamp$LAYOUT = (OfLong)$LAYOUT.select(groupElement("ntp_timestamp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t ntp_timestamp
     * }
     */
    public static final OfLong ntp_timestamp$layout() {
        return ntp_timestamp$LAYOUT;
    }

    private static final long ntp_timestamp$OFFSET = $LAYOUT.byteOffset(groupElement("ntp_timestamp"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t ntp_timestamp
     * }
     */
    public static final long ntp_timestamp$offset() {
        return ntp_timestamp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t ntp_timestamp
     * }
     */
    public static long ntp_timestamp(MemorySegment struct) {
        return struct.get(ntp_timestamp$LAYOUT, ntp_timestamp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t ntp_timestamp
     * }
     */
    public static void ntp_timestamp(MemorySegment struct, long fieldValue) {
        struct.set(ntp_timestamp$LAYOUT, ntp_timestamp$OFFSET, fieldValue);
    }

    private static final OfInt rtp_timestamp$LAYOUT = (OfInt)$LAYOUT.select(groupElement("rtp_timestamp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t rtp_timestamp
     * }
     */
    public static final OfInt rtp_timestamp$layout() {
        return rtp_timestamp$LAYOUT;
    }

    private static final long rtp_timestamp$OFFSET = $LAYOUT.byteOffset(groupElement("rtp_timestamp"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t rtp_timestamp
     * }
     */
    public static final long rtp_timestamp$offset() {
        return rtp_timestamp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t rtp_timestamp
     * }
     */
    public static int rtp_timestamp(MemorySegment struct) {
        return struct.get(rtp_timestamp$LAYOUT, rtp_timestamp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t rtp_timestamp
     * }
     */
    public static void rtp_timestamp(MemorySegment struct, int fieldValue) {
        struct.set(rtp_timestamp$LAYOUT, rtp_timestamp$OFFSET, fieldValue);
    }

    private static final OfInt sender_nb_packets$LAYOUT = (OfInt)$LAYOUT.select(groupElement("sender_nb_packets"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_packets
     * }
     */
    public static final OfInt sender_nb_packets$layout() {
        return sender_nb_packets$LAYOUT;
    }

    private static final long sender_nb_packets$OFFSET = $LAYOUT.byteOffset(groupElement("sender_nb_packets"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_packets
     * }
     */
    public static final long sender_nb_packets$offset() {
        return sender_nb_packets$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_packets
     * }
     */
    public static int sender_nb_packets(MemorySegment struct) {
        return struct.get(sender_nb_packets$LAYOUT, sender_nb_packets$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_packets
     * }
     */
    public static void sender_nb_packets(MemorySegment struct, int fieldValue) {
        struct.set(sender_nb_packets$LAYOUT, sender_nb_packets$OFFSET, fieldValue);
    }

    private static final OfInt sender_nb_bytes$LAYOUT = (OfInt)$LAYOUT.select(groupElement("sender_nb_bytes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_bytes
     * }
     */
    public static final OfInt sender_nb_bytes$layout() {
        return sender_nb_bytes$LAYOUT;
    }

    private static final long sender_nb_bytes$OFFSET = $LAYOUT.byteOffset(groupElement("sender_nb_bytes"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_bytes
     * }
     */
    public static final long sender_nb_bytes$offset() {
        return sender_nb_bytes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_bytes
     * }
     */
    public static int sender_nb_bytes(MemorySegment struct) {
        return struct.get(sender_nb_bytes$LAYOUT, sender_nb_bytes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t sender_nb_bytes
     * }
     */
    public static void sender_nb_bytes(MemorySegment struct, int fieldValue) {
        struct.set(sender_nb_bytes$LAYOUT, sender_nb_bytes$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

