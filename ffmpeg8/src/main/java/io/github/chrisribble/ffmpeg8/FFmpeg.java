// Generated by jextract

package io.github.chrisribble.ffmpeg8;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class FFmpeg extends FFmpeg$shared {

    FFmpeg() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("avcodec"), LIBRARY_ARENA)
            .or(SymbolLookup.libraryLookup(System.mapLibraryName("avformat"), LIBRARY_ARENA))
            .or(SymbolLookup.libraryLookup(System.mapLibraryName("avutil"), LIBRARY_ARENA))
            .or(SymbolLookup.libraryLookup(System.mapLibraryName("swscale"), LIBRARY_ARENA))
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    private static final int AV_TIME_BASE = (int)1000000L;
    /**
     * {@snippet lang=c :
     * #define AV_TIME_BASE 1000000
     * }
     */
    public static int AV_TIME_BASE() {
        return AV_TIME_BASE;
    }
    private static final int AV_ERROR_MAX_STRING_SIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_ERROR_MAX_STRING_SIZE 64
     * }
     */
    public static int AV_ERROR_MAX_STRING_SIZE() {
        return AV_ERROR_MAX_STRING_SIZE;
    }
    private static final int AV_LOG_PANIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PANIC 0
     * }
     */
    public static int AV_LOG_PANIC() {
        return AV_LOG_PANIC;
    }
    private static final int AV_LOG_FATAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_FATAL 8
     * }
     */
    public static int AV_LOG_FATAL() {
        return AV_LOG_FATAL;
    }
    private static final int AV_LOG_ERROR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_ERROR 16
     * }
     */
    public static int AV_LOG_ERROR() {
        return AV_LOG_ERROR;
    }
    private static final int AV_LOG_WARNING = (int)24L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_WARNING 24
     * }
     */
    public static int AV_LOG_WARNING() {
        return AV_LOG_WARNING;
    }
    private static final int AV_LOG_INFO = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_INFO 32
     * }
     */
    public static int AV_LOG_INFO() {
        return AV_LOG_INFO;
    }
    private static final int AV_LOG_VERBOSE = (int)40L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_VERBOSE 40
     * }
     */
    public static int AV_LOG_VERBOSE() {
        return AV_LOG_VERBOSE;
    }
    private static final int AV_LOG_DEBUG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_DEBUG 48
     * }
     */
    public static int AV_LOG_DEBUG() {
        return AV_LOG_DEBUG;
    }
    private static final int AV_LOG_TRACE = (int)56L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_TRACE 56
     * }
     */
    public static int AV_LOG_TRACE() {
        return AV_LOG_TRACE;
    }
    private static final int AV_LOG_SKIP_REPEATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_SKIP_REPEATED 1
     * }
     */
    public static int AV_LOG_SKIP_REPEATED() {
        return AV_LOG_SKIP_REPEATED;
    }
    private static final int AV_LOG_PRINT_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PRINT_LEVEL 2
     * }
     */
    public static int AV_LOG_PRINT_LEVEL() {
        return AV_LOG_PRINT_LEVEL;
    }
    private static final int AV_FOURCC_MAX_STRING_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_FOURCC_MAX_STRING_SIZE 32
     * }
     */
    public static int AV_FOURCC_MAX_STRING_SIZE() {
        return AV_FOURCC_MAX_STRING_SIZE;
    }
    private static final int SWS_SRC_V_CHR_DROP_MASK = (int)196608L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_MASK 196608
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_MASK() {
        return SWS_SRC_V_CHR_DROP_MASK;
    }
    private static final int SWS_SRC_V_CHR_DROP_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_SHIFT 16
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_SHIFT() {
        return SWS_SRC_V_CHR_DROP_SHIFT;
    }
    private static final int SWS_PARAM_DEFAULT = (int)123456L;
    /**
     * {@snippet lang=c :
     * #define SWS_PARAM_DEFAULT 123456
     * }
     */
    public static int SWS_PARAM_DEFAULT() {
        return SWS_PARAM_DEFAULT;
    }
    private static final int SWS_CS_ITU709 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU709 1
     * }
     */
    public static int SWS_CS_ITU709() {
        return SWS_CS_ITU709;
    }
    private static final int SWS_CS_FCC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_FCC 4
     * }
     */
    public static int SWS_CS_FCC() {
        return SWS_CS_FCC;
    }
    private static final int SWS_CS_ITU601 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU601 5
     * }
     */
    public static int SWS_CS_ITU601() {
        return SWS_CS_ITU601;
    }
    private static final int SWS_CS_ITU624 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU624 5
     * }
     */
    public static int SWS_CS_ITU624() {
        return SWS_CS_ITU624;
    }
    private static final int SWS_CS_SMPTE170M = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE170M 5
     * }
     */
    public static int SWS_CS_SMPTE170M() {
        return SWS_CS_SMPTE170M;
    }
    private static final int SWS_CS_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE240M 7
     * }
     */
    public static int SWS_CS_SMPTE240M() {
        return SWS_CS_SMPTE240M;
    }
    private static final int SWS_CS_DEFAULT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_DEFAULT 5
     * }
     */
    public static int SWS_CS_DEFAULT() {
        return SWS_CS_DEFAULT;
    }
    private static final int SWS_CS_BT2020 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_BT2020 9
     * }
     */
    public static int SWS_CS_BT2020() {
        return SWS_CS_BT2020;
    }

    private static class avutil_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static FunctionDescriptor avutil_version$descriptor() {
        return avutil_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MethodHandle avutil_version$handle() {
        return avutil_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MemorySegment avutil_version$address() {
        return avutil_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static int avutil_version() {
        var mh$ = avutil_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_version_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_version_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static FunctionDescriptor av_version_info$descriptor() {
        return av_version_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MethodHandle av_version_info$handle() {
        return av_version_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info$address() {
        return av_version_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info() {
        var mh$ = av_version_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_version_info");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static FunctionDescriptor avutil_configuration$descriptor() {
        return avutil_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MethodHandle avutil_configuration$handle() {
        return avutil_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration$address() {
        return avutil_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration() {
        var mh$ = avutil_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static FunctionDescriptor avutil_license$descriptor() {
        return avutil_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MethodHandle avutil_license$handle() {
        return avutil_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license$address() {
        return avutil_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license() {
        var mh$ = avutil_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVMEDIA_TYPE_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_UNKNOWN = -1
     * }
     */
    public static int AVMEDIA_TYPE_UNKNOWN() {
        return AVMEDIA_TYPE_UNKNOWN;
    }
    private static final int AVMEDIA_TYPE_VIDEO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_VIDEO = 0
     * }
     */
    public static int AVMEDIA_TYPE_VIDEO() {
        return AVMEDIA_TYPE_VIDEO;
    }
    private static final int AVMEDIA_TYPE_AUDIO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_AUDIO = 1
     * }
     */
    public static int AVMEDIA_TYPE_AUDIO() {
        return AVMEDIA_TYPE_AUDIO;
    }
    private static final int AVMEDIA_TYPE_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_DATA = 2
     * }
     */
    public static int AVMEDIA_TYPE_DATA() {
        return AVMEDIA_TYPE_DATA;
    }
    private static final int AVMEDIA_TYPE_SUBTITLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_SUBTITLE = 3
     * }
     */
    public static int AVMEDIA_TYPE_SUBTITLE() {
        return AVMEDIA_TYPE_SUBTITLE;
    }
    private static final int AVMEDIA_TYPE_ATTACHMENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_ATTACHMENT = 4
     * }
     */
    public static int AVMEDIA_TYPE_ATTACHMENT() {
        return AVMEDIA_TYPE_ATTACHMENT;
    }
    private static final int AVMEDIA_TYPE_NB = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_NB = 5
     * }
     */
    public static int AVMEDIA_TYPE_NB() {
        return AVMEDIA_TYPE_NB;
    }

    private static class av_get_media_type_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_media_type_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static FunctionDescriptor av_get_media_type_string$descriptor() {
        return av_get_media_type_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MethodHandle av_get_media_type_string$handle() {
        return av_get_media_type_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string$address() {
        return av_get_media_type_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string(int media_type) {
        var mh$ = av_get_media_type_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_media_type_string", media_type);
            }
            return (MemorySegment)mh$.invokeExact(media_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PICTURE_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_NONE = 0
     * }
     */
    public static int AV_PICTURE_TYPE_NONE() {
        return AV_PICTURE_TYPE_NONE;
    }
    private static final int AV_PICTURE_TYPE_I = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_I = 1
     * }
     */
    public static int AV_PICTURE_TYPE_I() {
        return AV_PICTURE_TYPE_I;
    }
    private static final int AV_PICTURE_TYPE_P = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_P = 2
     * }
     */
    public static int AV_PICTURE_TYPE_P() {
        return AV_PICTURE_TYPE_P;
    }
    private static final int AV_PICTURE_TYPE_B = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_B = 3
     * }
     */
    public static int AV_PICTURE_TYPE_B() {
        return AV_PICTURE_TYPE_B;
    }
    private static final int AV_PICTURE_TYPE_S = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_S = 4
     * }
     */
    public static int AV_PICTURE_TYPE_S() {
        return AV_PICTURE_TYPE_S;
    }
    private static final int AV_PICTURE_TYPE_SI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SI = 5
     * }
     */
    public static int AV_PICTURE_TYPE_SI() {
        return AV_PICTURE_TYPE_SI;
    }
    private static final int AV_PICTURE_TYPE_SP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SP = 6
     * }
     */
    public static int AV_PICTURE_TYPE_SP() {
        return AV_PICTURE_TYPE_SP;
    }
    private static final int AV_PICTURE_TYPE_BI = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_BI = 7
     * }
     */
    public static int AV_PICTURE_TYPE_BI() {
        return AV_PICTURE_TYPE_BI;
    }

    private static class av_get_picture_type_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_CHAR,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_picture_type_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static FunctionDescriptor av_get_picture_type_char$descriptor() {
        return av_get_picture_type_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MethodHandle av_get_picture_type_char$handle() {
        return av_get_picture_type_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MemorySegment av_get_picture_type_char$address() {
        return av_get_picture_type_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static byte av_get_picture_type_char(int pict_type) {
        var mh$ = av_get_picture_type_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_picture_type_char", pict_type);
            }
            return (byte)mh$.invokeExact(pict_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static FunctionDescriptor av_strerror$descriptor() {
        return av_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MethodHandle av_strerror$handle() {
        return av_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MemorySegment av_strerror$address() {
        return av_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static int av_strerror(int errnum, MemorySegment errbuf, long errbuf_size) {
        var mh$ = av_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strerror", errnum, errbuf, errbuf_size);
            }
            return (int)mh$.invokeExact(errnum, errbuf, errbuf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc$descriptor() {
        return av_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MethodHandle av_malloc$handle() {
        return av_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc$address() {
        return av_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc(long size) {
        var mh$ = av_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_mallocz$descriptor() {
        return av_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MethodHandle av_mallocz$handle() {
        return av_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz$address() {
        return av_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz(long size) {
        var mh$ = av_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mallocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_malloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc_array$descriptor() {
        return av_malloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_malloc_array$handle() {
        return av_malloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array$address() {
        return av_malloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array(long nmemb, long size) {
        var mh$ = av_malloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc_array", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_calloc$descriptor() {
        return av_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_calloc$handle() {
        return av_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc$address() {
        return av_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc(long nmemb, long size) {
        var mh$ = av_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_calloc", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc$descriptor() {
        return av_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_realloc$handle() {
        return av_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc$address() {
        return av_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc(MemorySegment ptr, long size) {
        var mh$ = av_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reallocp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp$descriptor() {
        return av_reallocp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_reallocp$handle() {
        return av_reallocp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_reallocp$address() {
        return av_reallocp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static int av_reallocp(MemorySegment ptr, long size) {
        var mh$ = av_reallocp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp", ptr, size);
            }
            return (int)mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor av_realloc_f$descriptor() {
        return av_realloc_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle av_realloc_f$handle() {
        return av_realloc_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f$address() {
        return av_realloc_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f(MemorySegment ptr, long nelem, long elsize) {
        var mh$ = av_realloc_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_f", ptr, nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nelem, elsize);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc_array$descriptor() {
        return av_realloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_realloc_array$handle() {
        return av_realloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array$address() {
        return av_realloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_realloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_array", ptr, nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reallocp_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp_array$descriptor() {
        return av_reallocp_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_reallocp_array$handle() {
        return av_reallocp_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_reallocp_array$address() {
        return av_reallocp_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static int av_reallocp_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_reallocp_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp_array", ptr, nmemb, size);
            }
            return (int)mh$.invokeExact(ptr, nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_realloc$descriptor() {
        return av_fast_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_realloc$handle() {
        return av_fast_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc$address() {
        return av_fast_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_realloc", ptr, size, min_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_malloc$descriptor() {
        return av_fast_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_malloc$handle() {
        return av_fast_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_malloc$address() {
        return av_fast_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_mallocz$descriptor() {
        return av_fast_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_mallocz$handle() {
        return av_fast_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_mallocz$address() {
        return av_fast_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static FunctionDescriptor av_free$descriptor() {
        return av_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MethodHandle av_free$handle() {
        return av_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MemorySegment av_free$address() {
        return av_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static void av_free(MemorySegment ptr) {
        var mh$ = av_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_freep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_freep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static FunctionDescriptor av_freep$descriptor() {
        return av_freep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MethodHandle av_freep$handle() {
        return av_freep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MemorySegment av_freep$address() {
        return av_freep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static void av_freep(MemorySegment ptr) {
        var mh$ = av_freep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_freep", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static FunctionDescriptor av_strdup$descriptor() {
        return av_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MethodHandle av_strdup$handle() {
        return av_strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup$address() {
        return av_strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup(MemorySegment s) {
        var mh$ = av_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strdup", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static FunctionDescriptor av_strndup$descriptor() {
        return av_strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MethodHandle av_strndup$handle() {
        return av_strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup$address() {
        return av_strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup(MemorySegment s, long len) {
        var mh$ = av_strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strndup", s, len);
            }
            return (MemorySegment)mh$.invokeExact(s, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_memdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static FunctionDescriptor av_memdup$descriptor() {
        return av_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MethodHandle av_memdup$handle() {
        return av_memdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup$address() {
        return av_memdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup(MemorySegment p, long size) {
        var mh$ = av_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memdup", p, size);
            }
            return (MemorySegment)mh$.invokeExact(p, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memcpy_backptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_memcpy_backptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static FunctionDescriptor av_memcpy_backptr$descriptor() {
        return av_memcpy_backptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MethodHandle av_memcpy_backptr$handle() {
        return av_memcpy_backptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MemorySegment av_memcpy_backptr$address() {
        return av_memcpy_backptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static void av_memcpy_backptr(MemorySegment dst, int back, int cnt) {
        var mh$ = av_memcpy_backptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memcpy_backptr", dst, back, cnt);
            }
            mh$.invokeExact(dst, back, cnt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add$descriptor() {
        return av_dynarray_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add$handle() {
        return av_dynarray_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add$address() {
        return av_dynarray_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static void av_dynarray_add(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add", tab_ptr, nb_ptr, elem);
            }
            mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add_nofree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray_add_nofree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add_nofree$descriptor() {
        return av_dynarray_add_nofree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add_nofree$handle() {
        return av_dynarray_add_nofree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add_nofree$address() {
        return av_dynarray_add_nofree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static int av_dynarray_add_nofree(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add_nofree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add_nofree", tab_ptr, nb_ptr, elem);
            }
            return (int)mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray2_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray2_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static FunctionDescriptor av_dynarray2_add$descriptor() {
        return av_dynarray2_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MethodHandle av_dynarray2_add$handle() {
        return av_dynarray2_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add$address() {
        return av_dynarray2_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add(MemorySegment tab_ptr, MemorySegment nb_ptr, long elem_size, MemorySegment elem_data) {
        var mh$ = av_dynarray2_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray2_add", tab_ptr, nb_ptr, elem_size, elem_data);
            }
            return (MemorySegment)mh$.invokeExact(tab_ptr, nb_ptr, elem_size, elem_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_size_mult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_size_mult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static FunctionDescriptor av_size_mult$descriptor() {
        return av_size_mult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MethodHandle av_size_mult$handle() {
        return av_size_mult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MemorySegment av_size_mult$address() {
        return av_size_mult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static int av_size_mult(long a, long b, MemorySegment r) {
        var mh$ = av_size_mult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_size_mult", a, b, r);
            }
            return (int)mh$.invokeExact(a, b, r);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_max_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_max_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static FunctionDescriptor av_max_alloc$descriptor() {
        return av_max_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MethodHandle av_max_alloc$handle() {
        return av_max_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MemorySegment av_max_alloc$address() {
        return av_max_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static void av_max_alloc(long max) {
        var mh$ = av_max_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_max_alloc", max);
            }
            mh$.invokeExact(max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_set_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static FunctionDescriptor av_log_set_level$descriptor() {
        return av_log_set_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MethodHandle av_log_set_level$handle() {
        return av_log_set_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MemorySegment av_log_set_level$address() {
        return av_log_set_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static void av_log_set_level(int level) {
        var mh$ = av_log_set_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_level", level);
            }
            mh$.invokeExact(level);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PIX_FMT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NONE = -1
     * }
     */
    public static int AV_PIX_FMT_NONE() {
        return AV_PIX_FMT_NONE;
    }
    private static final int AV_PIX_FMT_YUV420P = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P = 0
     * }
     */
    public static int AV_PIX_FMT_YUV420P() {
        return AV_PIX_FMT_YUV420P;
    }
    private static final int AV_PIX_FMT_YUYV422 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUYV422 = 1
     * }
     */
    public static int AV_PIX_FMT_YUYV422() {
        return AV_PIX_FMT_YUYV422;
    }
    private static final int AV_PIX_FMT_RGB24 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB24 = 2
     * }
     */
    public static int AV_PIX_FMT_RGB24() {
        return AV_PIX_FMT_RGB24;
    }
    private static final int AV_PIX_FMT_BGR24 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR24 = 3
     * }
     */
    public static int AV_PIX_FMT_BGR24() {
        return AV_PIX_FMT_BGR24;
    }
    private static final int AV_PIX_FMT_YUV422P = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P = 4
     * }
     */
    public static int AV_PIX_FMT_YUV422P() {
        return AV_PIX_FMT_YUV422P;
    }
    private static final int AV_PIX_FMT_YUV444P = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P = 5
     * }
     */
    public static int AV_PIX_FMT_YUV444P() {
        return AV_PIX_FMT_YUV444P;
    }
    private static final int AV_PIX_FMT_YUV410P = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV410P = 6
     * }
     */
    public static int AV_PIX_FMT_YUV410P() {
        return AV_PIX_FMT_YUV410P;
    }
    private static final int AV_PIX_FMT_YUV411P = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV411P = 7
     * }
     */
    public static int AV_PIX_FMT_YUV411P() {
        return AV_PIX_FMT_YUV411P;
    }
    private static final int AV_PIX_FMT_GRAY8 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8 = 8
     * }
     */
    public static int AV_PIX_FMT_GRAY8() {
        return AV_PIX_FMT_GRAY8;
    }
    private static final int AV_PIX_FMT_MONOWHITE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOWHITE = 9
     * }
     */
    public static int AV_PIX_FMT_MONOWHITE() {
        return AV_PIX_FMT_MONOWHITE;
    }
    private static final int AV_PIX_FMT_MONOBLACK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOBLACK = 10
     * }
     */
    public static int AV_PIX_FMT_MONOBLACK() {
        return AV_PIX_FMT_MONOBLACK;
    }
    private static final int AV_PIX_FMT_PAL8 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_PAL8 = 11
     * }
     */
    public static int AV_PIX_FMT_PAL8() {
        return AV_PIX_FMT_PAL8;
    }
    private static final int AV_PIX_FMT_YUVJ420P = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ420P = 12
     * }
     */
    public static int AV_PIX_FMT_YUVJ420P() {
        return AV_PIX_FMT_YUVJ420P;
    }
    private static final int AV_PIX_FMT_YUVJ422P = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ422P = 13
     * }
     */
    public static int AV_PIX_FMT_YUVJ422P() {
        return AV_PIX_FMT_YUVJ422P;
    }
    private static final int AV_PIX_FMT_YUVJ444P = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ444P = 14
     * }
     */
    public static int AV_PIX_FMT_YUVJ444P() {
        return AV_PIX_FMT_YUVJ444P;
    }
    private static final int AV_PIX_FMT_UYVY422 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYVY422 = 15
     * }
     */
    public static int AV_PIX_FMT_UYVY422() {
        return AV_PIX_FMT_UYVY422;
    }
    private static final int AV_PIX_FMT_UYYVYY411 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYYVYY411 = 16
     * }
     */
    public static int AV_PIX_FMT_UYYVYY411() {
        return AV_PIX_FMT_UYYVYY411;
    }
    private static final int AV_PIX_FMT_BGR8 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR8 = 17
     * }
     */
    public static int AV_PIX_FMT_BGR8() {
        return AV_PIX_FMT_BGR8;
    }
    private static final int AV_PIX_FMT_BGR4 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4 = 18
     * }
     */
    public static int AV_PIX_FMT_BGR4() {
        return AV_PIX_FMT_BGR4;
    }
    private static final int AV_PIX_FMT_BGR4_BYTE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4_BYTE = 19
     * }
     */
    public static int AV_PIX_FMT_BGR4_BYTE() {
        return AV_PIX_FMT_BGR4_BYTE;
    }
    private static final int AV_PIX_FMT_RGB8 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB8 = 20
     * }
     */
    public static int AV_PIX_FMT_RGB8() {
        return AV_PIX_FMT_RGB8;
    }
    private static final int AV_PIX_FMT_RGB4 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4 = 21
     * }
     */
    public static int AV_PIX_FMT_RGB4() {
        return AV_PIX_FMT_RGB4;
    }
    private static final int AV_PIX_FMT_RGB4_BYTE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4_BYTE = 22
     * }
     */
    public static int AV_PIX_FMT_RGB4_BYTE() {
        return AV_PIX_FMT_RGB4_BYTE;
    }
    private static final int AV_PIX_FMT_NV12 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV12 = 23
     * }
     */
    public static int AV_PIX_FMT_NV12() {
        return AV_PIX_FMT_NV12;
    }
    private static final int AV_PIX_FMT_NV21 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV21 = 24
     * }
     */
    public static int AV_PIX_FMT_NV21() {
        return AV_PIX_FMT_NV21;
    }
    private static final int AV_PIX_FMT_ARGB = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ARGB = 25
     * }
     */
    public static int AV_PIX_FMT_ARGB() {
        return AV_PIX_FMT_ARGB;
    }
    private static final int AV_PIX_FMT_RGBA = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA = 26
     * }
     */
    public static int AV_PIX_FMT_RGBA() {
        return AV_PIX_FMT_RGBA;
    }
    private static final int AV_PIX_FMT_ABGR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ABGR = 27
     * }
     */
    public static int AV_PIX_FMT_ABGR() {
        return AV_PIX_FMT_ABGR;
    }
    private static final int AV_PIX_FMT_BGRA = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA = 28
     * }
     */
    public static int AV_PIX_FMT_BGRA() {
        return AV_PIX_FMT_BGRA;
    }
    private static final int AV_PIX_FMT_GRAY16BE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16BE = 29
     * }
     */
    public static int AV_PIX_FMT_GRAY16BE() {
        return AV_PIX_FMT_GRAY16BE;
    }
    private static final int AV_PIX_FMT_GRAY16LE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16LE = 30
     * }
     */
    public static int AV_PIX_FMT_GRAY16LE() {
        return AV_PIX_FMT_GRAY16LE;
    }
    private static final int AV_PIX_FMT_YUV440P = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P = 31
     * }
     */
    public static int AV_PIX_FMT_YUV440P() {
        return AV_PIX_FMT_YUV440P;
    }
    private static final int AV_PIX_FMT_YUVJ440P = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ440P = 32
     * }
     */
    public static int AV_PIX_FMT_YUVJ440P() {
        return AV_PIX_FMT_YUVJ440P;
    }
    private static final int AV_PIX_FMT_YUVA420P = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P = 33
     * }
     */
    public static int AV_PIX_FMT_YUVA420P() {
        return AV_PIX_FMT_YUVA420P;
    }
    private static final int AV_PIX_FMT_RGB48BE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48BE = 34
     * }
     */
    public static int AV_PIX_FMT_RGB48BE() {
        return AV_PIX_FMT_RGB48BE;
    }
    private static final int AV_PIX_FMT_RGB48LE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48LE = 35
     * }
     */
    public static int AV_PIX_FMT_RGB48LE() {
        return AV_PIX_FMT_RGB48LE;
    }
    private static final int AV_PIX_FMT_RGB565BE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565BE = 36
     * }
     */
    public static int AV_PIX_FMT_RGB565BE() {
        return AV_PIX_FMT_RGB565BE;
    }
    private static final int AV_PIX_FMT_RGB565LE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565LE = 37
     * }
     */
    public static int AV_PIX_FMT_RGB565LE() {
        return AV_PIX_FMT_RGB565LE;
    }
    private static final int AV_PIX_FMT_RGB555BE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555BE = 38
     * }
     */
    public static int AV_PIX_FMT_RGB555BE() {
        return AV_PIX_FMT_RGB555BE;
    }
    private static final int AV_PIX_FMT_RGB555LE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555LE = 39
     * }
     */
    public static int AV_PIX_FMT_RGB555LE() {
        return AV_PIX_FMT_RGB555LE;
    }
    private static final int AV_PIX_FMT_BGR565BE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565BE = 40
     * }
     */
    public static int AV_PIX_FMT_BGR565BE() {
        return AV_PIX_FMT_BGR565BE;
    }
    private static final int AV_PIX_FMT_BGR565LE = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565LE = 41
     * }
     */
    public static int AV_PIX_FMT_BGR565LE() {
        return AV_PIX_FMT_BGR565LE;
    }
    private static final int AV_PIX_FMT_BGR555BE = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555BE = 42
     * }
     */
    public static int AV_PIX_FMT_BGR555BE() {
        return AV_PIX_FMT_BGR555BE;
    }
    private static final int AV_PIX_FMT_BGR555LE = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555LE = 43
     * }
     */
    public static int AV_PIX_FMT_BGR555LE() {
        return AV_PIX_FMT_BGR555LE;
    }
    private static final int AV_PIX_FMT_VAAPI = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VAAPI = 44
     * }
     */
    public static int AV_PIX_FMT_VAAPI() {
        return AV_PIX_FMT_VAAPI;
    }
    private static final int AV_PIX_FMT_YUV420P16LE = (int)45L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16LE = 45
     * }
     */
    public static int AV_PIX_FMT_YUV420P16LE() {
        return AV_PIX_FMT_YUV420P16LE;
    }
    private static final int AV_PIX_FMT_YUV420P16BE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16BE = 46
     * }
     */
    public static int AV_PIX_FMT_YUV420P16BE() {
        return AV_PIX_FMT_YUV420P16BE;
    }
    private static final int AV_PIX_FMT_YUV422P16LE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16LE = 47
     * }
     */
    public static int AV_PIX_FMT_YUV422P16LE() {
        return AV_PIX_FMT_YUV422P16LE;
    }
    private static final int AV_PIX_FMT_YUV422P16BE = (int)48L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16BE = 48
     * }
     */
    public static int AV_PIX_FMT_YUV422P16BE() {
        return AV_PIX_FMT_YUV422P16BE;
    }
    private static final int AV_PIX_FMT_YUV444P16LE = (int)49L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16LE = 49
     * }
     */
    public static int AV_PIX_FMT_YUV444P16LE() {
        return AV_PIX_FMT_YUV444P16LE;
    }
    private static final int AV_PIX_FMT_YUV444P16BE = (int)50L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16BE = 50
     * }
     */
    public static int AV_PIX_FMT_YUV444P16BE() {
        return AV_PIX_FMT_YUV444P16BE;
    }
    private static final int AV_PIX_FMT_DXVA2_VLD = (int)51L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DXVA2_VLD = 51
     * }
     */
    public static int AV_PIX_FMT_DXVA2_VLD() {
        return AV_PIX_FMT_DXVA2_VLD;
    }
    private static final int AV_PIX_FMT_RGB444LE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444LE = 52
     * }
     */
    public static int AV_PIX_FMT_RGB444LE() {
        return AV_PIX_FMT_RGB444LE;
    }
    private static final int AV_PIX_FMT_RGB444BE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444BE = 53
     * }
     */
    public static int AV_PIX_FMT_RGB444BE() {
        return AV_PIX_FMT_RGB444BE;
    }
    private static final int AV_PIX_FMT_BGR444LE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444LE = 54
     * }
     */
    public static int AV_PIX_FMT_BGR444LE() {
        return AV_PIX_FMT_BGR444LE;
    }
    private static final int AV_PIX_FMT_BGR444BE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444BE = 55
     * }
     */
    public static int AV_PIX_FMT_BGR444BE() {
        return AV_PIX_FMT_BGR444BE;
    }
    private static final int AV_PIX_FMT_YA8 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA8 = 56
     * }
     */
    public static int AV_PIX_FMT_YA8() {
        return AV_PIX_FMT_YA8;
    }
    private static final int AV_PIX_FMT_Y400A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y400A = 56
     * }
     */
    public static int AV_PIX_FMT_Y400A() {
        return AV_PIX_FMT_Y400A;
    }
    private static final int AV_PIX_FMT_GRAY8A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8A = 56
     * }
     */
    public static int AV_PIX_FMT_GRAY8A() {
        return AV_PIX_FMT_GRAY8A;
    }
    private static final int AV_PIX_FMT_BGR48BE = (int)57L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48BE = 57
     * }
     */
    public static int AV_PIX_FMT_BGR48BE() {
        return AV_PIX_FMT_BGR48BE;
    }
    private static final int AV_PIX_FMT_BGR48LE = (int)58L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48LE = 58
     * }
     */
    public static int AV_PIX_FMT_BGR48LE() {
        return AV_PIX_FMT_BGR48LE;
    }
    private static final int AV_PIX_FMT_YUV420P9BE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9BE = 59
     * }
     */
    public static int AV_PIX_FMT_YUV420P9BE() {
        return AV_PIX_FMT_YUV420P9BE;
    }
    private static final int AV_PIX_FMT_YUV420P9LE = (int)60L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9LE = 60
     * }
     */
    public static int AV_PIX_FMT_YUV420P9LE() {
        return AV_PIX_FMT_YUV420P9LE;
    }
    private static final int AV_PIX_FMT_YUV420P10BE = (int)61L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10BE = 61
     * }
     */
    public static int AV_PIX_FMT_YUV420P10BE() {
        return AV_PIX_FMT_YUV420P10BE;
    }
    private static final int AV_PIX_FMT_YUV420P10LE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10LE = 62
     * }
     */
    public static int AV_PIX_FMT_YUV420P10LE() {
        return AV_PIX_FMT_YUV420P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P10BE = (int)63L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10BE = 63
     * }
     */
    public static int AV_PIX_FMT_YUV422P10BE() {
        return AV_PIX_FMT_YUV422P10BE;
    }
    private static final int AV_PIX_FMT_YUV422P10LE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10LE = 64
     * }
     */
    public static int AV_PIX_FMT_YUV422P10LE() {
        return AV_PIX_FMT_YUV422P10LE;
    }
    private static final int AV_PIX_FMT_YUV444P9BE = (int)65L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9BE = 65
     * }
     */
    public static int AV_PIX_FMT_YUV444P9BE() {
        return AV_PIX_FMT_YUV444P9BE;
    }
    private static final int AV_PIX_FMT_YUV444P9LE = (int)66L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9LE = 66
     * }
     */
    public static int AV_PIX_FMT_YUV444P9LE() {
        return AV_PIX_FMT_YUV444P9LE;
    }
    private static final int AV_PIX_FMT_YUV444P10BE = (int)67L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10BE = 67
     * }
     */
    public static int AV_PIX_FMT_YUV444P10BE() {
        return AV_PIX_FMT_YUV444P10BE;
    }
    private static final int AV_PIX_FMT_YUV444P10LE = (int)68L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10LE = 68
     * }
     */
    public static int AV_PIX_FMT_YUV444P10LE() {
        return AV_PIX_FMT_YUV444P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P9BE = (int)69L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9BE = 69
     * }
     */
    public static int AV_PIX_FMT_YUV422P9BE() {
        return AV_PIX_FMT_YUV422P9BE;
    }
    private static final int AV_PIX_FMT_YUV422P9LE = (int)70L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9LE = 70
     * }
     */
    public static int AV_PIX_FMT_YUV422P9LE() {
        return AV_PIX_FMT_YUV422P9LE;
    }
    private static final int AV_PIX_FMT_GBRP = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP = 71
     * }
     */
    public static int AV_PIX_FMT_GBRP() {
        return AV_PIX_FMT_GBRP;
    }
    private static final int AV_PIX_FMT_GBR24P = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBR24P = 71
     * }
     */
    public static int AV_PIX_FMT_GBR24P() {
        return AV_PIX_FMT_GBR24P;
    }
    private static final int AV_PIX_FMT_GBRP9BE = (int)72L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9BE = 72
     * }
     */
    public static int AV_PIX_FMT_GBRP9BE() {
        return AV_PIX_FMT_GBRP9BE;
    }
    private static final int AV_PIX_FMT_GBRP9LE = (int)73L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9LE = 73
     * }
     */
    public static int AV_PIX_FMT_GBRP9LE() {
        return AV_PIX_FMT_GBRP9LE;
    }
    private static final int AV_PIX_FMT_GBRP10BE = (int)74L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10BE = 74
     * }
     */
    public static int AV_PIX_FMT_GBRP10BE() {
        return AV_PIX_FMT_GBRP10BE;
    }
    private static final int AV_PIX_FMT_GBRP10LE = (int)75L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10LE = 75
     * }
     */
    public static int AV_PIX_FMT_GBRP10LE() {
        return AV_PIX_FMT_GBRP10LE;
    }
    private static final int AV_PIX_FMT_GBRP16BE = (int)76L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16BE = 76
     * }
     */
    public static int AV_PIX_FMT_GBRP16BE() {
        return AV_PIX_FMT_GBRP16BE;
    }
    private static final int AV_PIX_FMT_GBRP16LE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16LE = 77
     * }
     */
    public static int AV_PIX_FMT_GBRP16LE() {
        return AV_PIX_FMT_GBRP16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P = (int)78L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P = 78
     * }
     */
    public static int AV_PIX_FMT_YUVA422P() {
        return AV_PIX_FMT_YUVA422P;
    }
    private static final int AV_PIX_FMT_YUVA444P = (int)79L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P = 79
     * }
     */
    public static int AV_PIX_FMT_YUVA444P() {
        return AV_PIX_FMT_YUVA444P;
    }
    private static final int AV_PIX_FMT_YUVA420P9BE = (int)80L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9BE = 80
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9BE() {
        return AV_PIX_FMT_YUVA420P9BE;
    }
    private static final int AV_PIX_FMT_YUVA420P9LE = (int)81L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9LE = 81
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9LE() {
        return AV_PIX_FMT_YUVA420P9LE;
    }
    private static final int AV_PIX_FMT_YUVA422P9BE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9BE = 82
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9BE() {
        return AV_PIX_FMT_YUVA422P9BE;
    }
    private static final int AV_PIX_FMT_YUVA422P9LE = (int)83L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9LE = 83
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9LE() {
        return AV_PIX_FMT_YUVA422P9LE;
    }
    private static final int AV_PIX_FMT_YUVA444P9BE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9BE = 84
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9BE() {
        return AV_PIX_FMT_YUVA444P9BE;
    }
    private static final int AV_PIX_FMT_YUVA444P9LE = (int)85L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9LE = 85
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9LE() {
        return AV_PIX_FMT_YUVA444P9LE;
    }
    private static final int AV_PIX_FMT_YUVA420P10BE = (int)86L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10BE = 86
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10BE() {
        return AV_PIX_FMT_YUVA420P10BE;
    }
    private static final int AV_PIX_FMT_YUVA420P10LE = (int)87L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10LE = 87
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10LE() {
        return AV_PIX_FMT_YUVA420P10LE;
    }
    private static final int AV_PIX_FMT_YUVA422P10BE = (int)88L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10BE = 88
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10BE() {
        return AV_PIX_FMT_YUVA422P10BE;
    }
    private static final int AV_PIX_FMT_YUVA422P10LE = (int)89L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10LE = 89
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10LE() {
        return AV_PIX_FMT_YUVA422P10LE;
    }
    private static final int AV_PIX_FMT_YUVA444P10BE = (int)90L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10BE = 90
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10BE() {
        return AV_PIX_FMT_YUVA444P10BE;
    }
    private static final int AV_PIX_FMT_YUVA444P10LE = (int)91L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10LE = 91
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10LE() {
        return AV_PIX_FMT_YUVA444P10LE;
    }
    private static final int AV_PIX_FMT_YUVA420P16BE = (int)92L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16BE = 92
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16BE() {
        return AV_PIX_FMT_YUVA420P16BE;
    }
    private static final int AV_PIX_FMT_YUVA420P16LE = (int)93L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16LE = 93
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16LE() {
        return AV_PIX_FMT_YUVA420P16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P16BE = (int)94L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16BE = 94
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16BE() {
        return AV_PIX_FMT_YUVA422P16BE;
    }
    private static final int AV_PIX_FMT_YUVA422P16LE = (int)95L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16LE = 95
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16LE() {
        return AV_PIX_FMT_YUVA422P16LE;
    }
    private static final int AV_PIX_FMT_YUVA444P16BE = (int)96L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16BE = 96
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16BE() {
        return AV_PIX_FMT_YUVA444P16BE;
    }
    private static final int AV_PIX_FMT_YUVA444P16LE = (int)97L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16LE = 97
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16LE() {
        return AV_PIX_FMT_YUVA444P16LE;
    }
    private static final int AV_PIX_FMT_VDPAU = (int)98L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VDPAU = 98
     * }
     */
    public static int AV_PIX_FMT_VDPAU() {
        return AV_PIX_FMT_VDPAU;
    }
    private static final int AV_PIX_FMT_XYZ12LE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12LE = 99
     * }
     */
    public static int AV_PIX_FMT_XYZ12LE() {
        return AV_PIX_FMT_XYZ12LE;
    }
    private static final int AV_PIX_FMT_XYZ12BE = (int)100L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12BE = 100
     * }
     */
    public static int AV_PIX_FMT_XYZ12BE() {
        return AV_PIX_FMT_XYZ12BE;
    }
    private static final int AV_PIX_FMT_NV16 = (int)101L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV16 = 101
     * }
     */
    public static int AV_PIX_FMT_NV16() {
        return AV_PIX_FMT_NV16;
    }
    private static final int AV_PIX_FMT_NV20LE = (int)102L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20LE = 102
     * }
     */
    public static int AV_PIX_FMT_NV20LE() {
        return AV_PIX_FMT_NV20LE;
    }
    private static final int AV_PIX_FMT_NV20BE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20BE = 103
     * }
     */
    public static int AV_PIX_FMT_NV20BE() {
        return AV_PIX_FMT_NV20BE;
    }
    private static final int AV_PIX_FMT_RGBA64BE = (int)104L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64BE = 104
     * }
     */
    public static int AV_PIX_FMT_RGBA64BE() {
        return AV_PIX_FMT_RGBA64BE;
    }
    private static final int AV_PIX_FMT_RGBA64LE = (int)105L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64LE = 105
     * }
     */
    public static int AV_PIX_FMT_RGBA64LE() {
        return AV_PIX_FMT_RGBA64LE;
    }
    private static final int AV_PIX_FMT_BGRA64BE = (int)106L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64BE = 106
     * }
     */
    public static int AV_PIX_FMT_BGRA64BE() {
        return AV_PIX_FMT_BGRA64BE;
    }
    private static final int AV_PIX_FMT_BGRA64LE = (int)107L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64LE = 107
     * }
     */
    public static int AV_PIX_FMT_BGRA64LE() {
        return AV_PIX_FMT_BGRA64LE;
    }
    private static final int AV_PIX_FMT_YVYU422 = (int)108L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YVYU422 = 108
     * }
     */
    public static int AV_PIX_FMT_YVYU422() {
        return AV_PIX_FMT_YVYU422;
    }
    private static final int AV_PIX_FMT_YA16BE = (int)109L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16BE = 109
     * }
     */
    public static int AV_PIX_FMT_YA16BE() {
        return AV_PIX_FMT_YA16BE;
    }
    private static final int AV_PIX_FMT_YA16LE = (int)110L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16LE = 110
     * }
     */
    public static int AV_PIX_FMT_YA16LE() {
        return AV_PIX_FMT_YA16LE;
    }
    private static final int AV_PIX_FMT_GBRAP = (int)111L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP = 111
     * }
     */
    public static int AV_PIX_FMT_GBRAP() {
        return AV_PIX_FMT_GBRAP;
    }
    private static final int AV_PIX_FMT_GBRAP16BE = (int)112L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16BE = 112
     * }
     */
    public static int AV_PIX_FMT_GBRAP16BE() {
        return AV_PIX_FMT_GBRAP16BE;
    }
    private static final int AV_PIX_FMT_GBRAP16LE = (int)113L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16LE = 113
     * }
     */
    public static int AV_PIX_FMT_GBRAP16LE() {
        return AV_PIX_FMT_GBRAP16LE;
    }
    private static final int AV_PIX_FMT_QSV = (int)114L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_QSV = 114
     * }
     */
    public static int AV_PIX_FMT_QSV() {
        return AV_PIX_FMT_QSV;
    }
    private static final int AV_PIX_FMT_MMAL = (int)115L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MMAL = 115
     * }
     */
    public static int AV_PIX_FMT_MMAL() {
        return AV_PIX_FMT_MMAL;
    }
    private static final int AV_PIX_FMT_D3D11VA_VLD = (int)116L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11VA_VLD = 116
     * }
     */
    public static int AV_PIX_FMT_D3D11VA_VLD() {
        return AV_PIX_FMT_D3D11VA_VLD;
    }
    private static final int AV_PIX_FMT_CUDA = (int)117L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_CUDA = 117
     * }
     */
    public static int AV_PIX_FMT_CUDA() {
        return AV_PIX_FMT_CUDA;
    }
    private static final int AV_PIX_FMT_0RGB = (int)118L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0RGB = 118
     * }
     */
    public static int AV_PIX_FMT_0RGB() {
        return AV_PIX_FMT_0RGB;
    }
    private static final int AV_PIX_FMT_RGB0 = (int)119L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB0 = 119
     * }
     */
    public static int AV_PIX_FMT_RGB0() {
        return AV_PIX_FMT_RGB0;
    }
    private static final int AV_PIX_FMT_0BGR = (int)120L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0BGR = 120
     * }
     */
    public static int AV_PIX_FMT_0BGR() {
        return AV_PIX_FMT_0BGR;
    }
    private static final int AV_PIX_FMT_BGR0 = (int)121L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR0 = 121
     * }
     */
    public static int AV_PIX_FMT_BGR0() {
        return AV_PIX_FMT_BGR0;
    }
    private static final int AV_PIX_FMT_YUV420P12BE = (int)122L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12BE = 122
     * }
     */
    public static int AV_PIX_FMT_YUV420P12BE() {
        return AV_PIX_FMT_YUV420P12BE;
    }
    private static final int AV_PIX_FMT_YUV420P12LE = (int)123L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12LE = 123
     * }
     */
    public static int AV_PIX_FMT_YUV420P12LE() {
        return AV_PIX_FMT_YUV420P12LE;
    }
    private static final int AV_PIX_FMT_YUV420P14BE = (int)124L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14BE = 124
     * }
     */
    public static int AV_PIX_FMT_YUV420P14BE() {
        return AV_PIX_FMT_YUV420P14BE;
    }
    private static final int AV_PIX_FMT_YUV420P14LE = (int)125L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14LE = 125
     * }
     */
    public static int AV_PIX_FMT_YUV420P14LE() {
        return AV_PIX_FMT_YUV420P14LE;
    }
    private static final int AV_PIX_FMT_YUV422P12BE = (int)126L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12BE = 126
     * }
     */
    public static int AV_PIX_FMT_YUV422P12BE() {
        return AV_PIX_FMT_YUV422P12BE;
    }
    private static final int AV_PIX_FMT_YUV422P12LE = (int)127L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12LE = 127
     * }
     */
    public static int AV_PIX_FMT_YUV422P12LE() {
        return AV_PIX_FMT_YUV422P12LE;
    }
    private static final int AV_PIX_FMT_YUV422P14BE = (int)128L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14BE = 128
     * }
     */
    public static int AV_PIX_FMT_YUV422P14BE() {
        return AV_PIX_FMT_YUV422P14BE;
    }
    private static final int AV_PIX_FMT_YUV422P14LE = (int)129L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14LE = 129
     * }
     */
    public static int AV_PIX_FMT_YUV422P14LE() {
        return AV_PIX_FMT_YUV422P14LE;
    }
    private static final int AV_PIX_FMT_YUV444P12BE = (int)130L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12BE = 130
     * }
     */
    public static int AV_PIX_FMT_YUV444P12BE() {
        return AV_PIX_FMT_YUV444P12BE;
    }
    private static final int AV_PIX_FMT_YUV444P12LE = (int)131L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12LE = 131
     * }
     */
    public static int AV_PIX_FMT_YUV444P12LE() {
        return AV_PIX_FMT_YUV444P12LE;
    }
    private static final int AV_PIX_FMT_YUV444P14BE = (int)132L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14BE = 132
     * }
     */
    public static int AV_PIX_FMT_YUV444P14BE() {
        return AV_PIX_FMT_YUV444P14BE;
    }
    private static final int AV_PIX_FMT_YUV444P14LE = (int)133L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14LE = 133
     * }
     */
    public static int AV_PIX_FMT_YUV444P14LE() {
        return AV_PIX_FMT_YUV444P14LE;
    }
    private static final int AV_PIX_FMT_GBRP12BE = (int)134L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12BE = 134
     * }
     */
    public static int AV_PIX_FMT_GBRP12BE() {
        return AV_PIX_FMT_GBRP12BE;
    }
    private static final int AV_PIX_FMT_GBRP12LE = (int)135L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12LE = 135
     * }
     */
    public static int AV_PIX_FMT_GBRP12LE() {
        return AV_PIX_FMT_GBRP12LE;
    }
    private static final int AV_PIX_FMT_GBRP14BE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14BE = 136
     * }
     */
    public static int AV_PIX_FMT_GBRP14BE() {
        return AV_PIX_FMT_GBRP14BE;
    }
    private static final int AV_PIX_FMT_GBRP14LE = (int)137L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14LE = 137
     * }
     */
    public static int AV_PIX_FMT_GBRP14LE() {
        return AV_PIX_FMT_GBRP14LE;
    }
    private static final int AV_PIX_FMT_YUVJ411P = (int)138L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ411P = 138
     * }
     */
    public static int AV_PIX_FMT_YUVJ411P() {
        return AV_PIX_FMT_YUVJ411P;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR8 = (int)139L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR8 = 139
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR8() {
        return AV_PIX_FMT_BAYER_BGGR8;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB8 = (int)140L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB8 = 140
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB8() {
        return AV_PIX_FMT_BAYER_RGGB8;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG8 = (int)141L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG8 = 141
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG8() {
        return AV_PIX_FMT_BAYER_GBRG8;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG8 = (int)142L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG8 = 142
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG8() {
        return AV_PIX_FMT_BAYER_GRBG8;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16LE = (int)143L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16LE = 143
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16LE() {
        return AV_PIX_FMT_BAYER_BGGR16LE;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16BE = (int)144L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16BE = 144
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16BE() {
        return AV_PIX_FMT_BAYER_BGGR16BE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16LE = (int)145L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16LE = 145
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16LE() {
        return AV_PIX_FMT_BAYER_RGGB16LE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16BE = (int)146L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16BE = 146
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16BE() {
        return AV_PIX_FMT_BAYER_RGGB16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16LE = (int)147L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16LE = 147
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16LE() {
        return AV_PIX_FMT_BAYER_GBRG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16BE = (int)148L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16BE = 148
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16BE() {
        return AV_PIX_FMT_BAYER_GBRG16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16LE = (int)149L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16LE = 149
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16LE() {
        return AV_PIX_FMT_BAYER_GRBG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16BE = (int)150L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16BE = 150
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16BE() {
        return AV_PIX_FMT_BAYER_GRBG16BE;
    }
    private static final int AV_PIX_FMT_YUV440P10LE = (int)151L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10LE = 151
     * }
     */
    public static int AV_PIX_FMT_YUV440P10LE() {
        return AV_PIX_FMT_YUV440P10LE;
    }
    private static final int AV_PIX_FMT_YUV440P10BE = (int)152L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10BE = 152
     * }
     */
    public static int AV_PIX_FMT_YUV440P10BE() {
        return AV_PIX_FMT_YUV440P10BE;
    }
    private static final int AV_PIX_FMT_YUV440P12LE = (int)153L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12LE = 153
     * }
     */
    public static int AV_PIX_FMT_YUV440P12LE() {
        return AV_PIX_FMT_YUV440P12LE;
    }
    private static final int AV_PIX_FMT_YUV440P12BE = (int)154L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12BE = 154
     * }
     */
    public static int AV_PIX_FMT_YUV440P12BE() {
        return AV_PIX_FMT_YUV440P12BE;
    }
    private static final int AV_PIX_FMT_AYUV64LE = (int)155L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64LE = 155
     * }
     */
    public static int AV_PIX_FMT_AYUV64LE() {
        return AV_PIX_FMT_AYUV64LE;
    }
    private static final int AV_PIX_FMT_AYUV64BE = (int)156L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64BE = 156
     * }
     */
    public static int AV_PIX_FMT_AYUV64BE() {
        return AV_PIX_FMT_AYUV64BE;
    }
    private static final int AV_PIX_FMT_VIDEOTOOLBOX = (int)157L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VIDEOTOOLBOX = 157
     * }
     */
    public static int AV_PIX_FMT_VIDEOTOOLBOX() {
        return AV_PIX_FMT_VIDEOTOOLBOX;
    }
    private static final int AV_PIX_FMT_P010LE = (int)158L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010LE = 158
     * }
     */
    public static int AV_PIX_FMT_P010LE() {
        return AV_PIX_FMT_P010LE;
    }
    private static final int AV_PIX_FMT_P010BE = (int)159L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010BE = 159
     * }
     */
    public static int AV_PIX_FMT_P010BE() {
        return AV_PIX_FMT_P010BE;
    }
    private static final int AV_PIX_FMT_GBRAP12BE = (int)160L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12BE = 160
     * }
     */
    public static int AV_PIX_FMT_GBRAP12BE() {
        return AV_PIX_FMT_GBRAP12BE;
    }
    private static final int AV_PIX_FMT_GBRAP12LE = (int)161L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12LE = 161
     * }
     */
    public static int AV_PIX_FMT_GBRAP12LE() {
        return AV_PIX_FMT_GBRAP12LE;
    }
    private static final int AV_PIX_FMT_GBRAP10BE = (int)162L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10BE = 162
     * }
     */
    public static int AV_PIX_FMT_GBRAP10BE() {
        return AV_PIX_FMT_GBRAP10BE;
    }
    private static final int AV_PIX_FMT_GBRAP10LE = (int)163L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10LE = 163
     * }
     */
    public static int AV_PIX_FMT_GBRAP10LE() {
        return AV_PIX_FMT_GBRAP10LE;
    }
    private static final int AV_PIX_FMT_MEDIACODEC = (int)164L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MEDIACODEC = 164
     * }
     */
    public static int AV_PIX_FMT_MEDIACODEC() {
        return AV_PIX_FMT_MEDIACODEC;
    }
    private static final int AV_PIX_FMT_GRAY12BE = (int)165L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12BE = 165
     * }
     */
    public static int AV_PIX_FMT_GRAY12BE() {
        return AV_PIX_FMT_GRAY12BE;
    }
    private static final int AV_PIX_FMT_GRAY12LE = (int)166L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12LE = 166
     * }
     */
    public static int AV_PIX_FMT_GRAY12LE() {
        return AV_PIX_FMT_GRAY12LE;
    }
    private static final int AV_PIX_FMT_GRAY10BE = (int)167L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10BE = 167
     * }
     */
    public static int AV_PIX_FMT_GRAY10BE() {
        return AV_PIX_FMT_GRAY10BE;
    }
    private static final int AV_PIX_FMT_GRAY10LE = (int)168L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10LE = 168
     * }
     */
    public static int AV_PIX_FMT_GRAY10LE() {
        return AV_PIX_FMT_GRAY10LE;
    }
    private static final int AV_PIX_FMT_P016LE = (int)169L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016LE = 169
     * }
     */
    public static int AV_PIX_FMT_P016LE() {
        return AV_PIX_FMT_P016LE;
    }
    private static final int AV_PIX_FMT_P016BE = (int)170L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016BE = 170
     * }
     */
    public static int AV_PIX_FMT_P016BE() {
        return AV_PIX_FMT_P016BE;
    }
    private static final int AV_PIX_FMT_D3D11 = (int)171L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11 = 171
     * }
     */
    public static int AV_PIX_FMT_D3D11() {
        return AV_PIX_FMT_D3D11;
    }
    private static final int AV_PIX_FMT_GRAY9BE = (int)172L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9BE = 172
     * }
     */
    public static int AV_PIX_FMT_GRAY9BE() {
        return AV_PIX_FMT_GRAY9BE;
    }
    private static final int AV_PIX_FMT_GRAY9LE = (int)173L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9LE = 173
     * }
     */
    public static int AV_PIX_FMT_GRAY9LE() {
        return AV_PIX_FMT_GRAY9LE;
    }
    private static final int AV_PIX_FMT_GBRPF32BE = (int)174L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32BE = 174
     * }
     */
    public static int AV_PIX_FMT_GBRPF32BE() {
        return AV_PIX_FMT_GBRPF32BE;
    }
    private static final int AV_PIX_FMT_GBRPF32LE = (int)175L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32LE = 175
     * }
     */
    public static int AV_PIX_FMT_GBRPF32LE() {
        return AV_PIX_FMT_GBRPF32LE;
    }
    private static final int AV_PIX_FMT_GBRAPF32BE = (int)176L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32BE = 176
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32BE() {
        return AV_PIX_FMT_GBRAPF32BE;
    }
    private static final int AV_PIX_FMT_GBRAPF32LE = (int)177L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32LE = 177
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32LE() {
        return AV_PIX_FMT_GBRAPF32LE;
    }
    private static final int AV_PIX_FMT_DRM_PRIME = (int)178L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DRM_PRIME = 178
     * }
     */
    public static int AV_PIX_FMT_DRM_PRIME() {
        return AV_PIX_FMT_DRM_PRIME;
    }
    private static final int AV_PIX_FMT_OPENCL = (int)179L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_OPENCL = 179
     * }
     */
    public static int AV_PIX_FMT_OPENCL() {
        return AV_PIX_FMT_OPENCL;
    }
    private static final int AV_PIX_FMT_GRAY14BE = (int)180L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14BE = 180
     * }
     */
    public static int AV_PIX_FMT_GRAY14BE() {
        return AV_PIX_FMT_GRAY14BE;
    }
    private static final int AV_PIX_FMT_GRAY14LE = (int)181L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14LE = 181
     * }
     */
    public static int AV_PIX_FMT_GRAY14LE() {
        return AV_PIX_FMT_GRAY14LE;
    }
    private static final int AV_PIX_FMT_GRAYF32BE = (int)182L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32BE = 182
     * }
     */
    public static int AV_PIX_FMT_GRAYF32BE() {
        return AV_PIX_FMT_GRAYF32BE;
    }
    private static final int AV_PIX_FMT_GRAYF32LE = (int)183L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32LE = 183
     * }
     */
    public static int AV_PIX_FMT_GRAYF32LE() {
        return AV_PIX_FMT_GRAYF32LE;
    }
    private static final int AV_PIX_FMT_YUVA422P12BE = (int)184L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12BE = 184
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12BE() {
        return AV_PIX_FMT_YUVA422P12BE;
    }
    private static final int AV_PIX_FMT_YUVA422P12LE = (int)185L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12LE = 185
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12LE() {
        return AV_PIX_FMT_YUVA422P12LE;
    }
    private static final int AV_PIX_FMT_YUVA444P12BE = (int)186L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12BE = 186
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12BE() {
        return AV_PIX_FMT_YUVA444P12BE;
    }
    private static final int AV_PIX_FMT_YUVA444P12LE = (int)187L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12LE = 187
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12LE() {
        return AV_PIX_FMT_YUVA444P12LE;
    }
    private static final int AV_PIX_FMT_NV24 = (int)188L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV24 = 188
     * }
     */
    public static int AV_PIX_FMT_NV24() {
        return AV_PIX_FMT_NV24;
    }
    private static final int AV_PIX_FMT_NV42 = (int)189L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV42 = 189
     * }
     */
    public static int AV_PIX_FMT_NV42() {
        return AV_PIX_FMT_NV42;
    }
    private static final int AV_PIX_FMT_VULKAN = (int)190L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VULKAN = 190
     * }
     */
    public static int AV_PIX_FMT_VULKAN() {
        return AV_PIX_FMT_VULKAN;
    }
    private static final int AV_PIX_FMT_Y210BE = (int)191L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210BE = 191
     * }
     */
    public static int AV_PIX_FMT_Y210BE() {
        return AV_PIX_FMT_Y210BE;
    }
    private static final int AV_PIX_FMT_Y210LE = (int)192L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210LE = 192
     * }
     */
    public static int AV_PIX_FMT_Y210LE() {
        return AV_PIX_FMT_Y210LE;
    }
    private static final int AV_PIX_FMT_X2RGB10LE = (int)193L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10LE = 193
     * }
     */
    public static int AV_PIX_FMT_X2RGB10LE() {
        return AV_PIX_FMT_X2RGB10LE;
    }
    private static final int AV_PIX_FMT_X2RGB10BE = (int)194L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10BE = 194
     * }
     */
    public static int AV_PIX_FMT_X2RGB10BE() {
        return AV_PIX_FMT_X2RGB10BE;
    }
    private static final int AV_PIX_FMT_X2BGR10LE = (int)195L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10LE = 195
     * }
     */
    public static int AV_PIX_FMT_X2BGR10LE() {
        return AV_PIX_FMT_X2BGR10LE;
    }
    private static final int AV_PIX_FMT_X2BGR10BE = (int)196L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10BE = 196
     * }
     */
    public static int AV_PIX_FMT_X2BGR10BE() {
        return AV_PIX_FMT_X2BGR10BE;
    }
    private static final int AV_PIX_FMT_P210BE = (int)197L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210BE = 197
     * }
     */
    public static int AV_PIX_FMT_P210BE() {
        return AV_PIX_FMT_P210BE;
    }
    private static final int AV_PIX_FMT_P210LE = (int)198L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210LE = 198
     * }
     */
    public static int AV_PIX_FMT_P210LE() {
        return AV_PIX_FMT_P210LE;
    }
    private static final int AV_PIX_FMT_P410BE = (int)199L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410BE = 199
     * }
     */
    public static int AV_PIX_FMT_P410BE() {
        return AV_PIX_FMT_P410BE;
    }
    private static final int AV_PIX_FMT_P410LE = (int)200L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410LE = 200
     * }
     */
    public static int AV_PIX_FMT_P410LE() {
        return AV_PIX_FMT_P410LE;
    }
    private static final int AV_PIX_FMT_P216BE = (int)201L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216BE = 201
     * }
     */
    public static int AV_PIX_FMT_P216BE() {
        return AV_PIX_FMT_P216BE;
    }
    private static final int AV_PIX_FMT_P216LE = (int)202L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216LE = 202
     * }
     */
    public static int AV_PIX_FMT_P216LE() {
        return AV_PIX_FMT_P216LE;
    }
    private static final int AV_PIX_FMT_P416BE = (int)203L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416BE = 203
     * }
     */
    public static int AV_PIX_FMT_P416BE() {
        return AV_PIX_FMT_P416BE;
    }
    private static final int AV_PIX_FMT_P416LE = (int)204L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416LE = 204
     * }
     */
    public static int AV_PIX_FMT_P416LE() {
        return AV_PIX_FMT_P416LE;
    }
    private static final int AV_PIX_FMT_VUYA = (int)205L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYA = 205
     * }
     */
    public static int AV_PIX_FMT_VUYA() {
        return AV_PIX_FMT_VUYA;
    }
    private static final int AV_PIX_FMT_RGBAF16BE = (int)206L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16BE = 206
     * }
     */
    public static int AV_PIX_FMT_RGBAF16BE() {
        return AV_PIX_FMT_RGBAF16BE;
    }
    private static final int AV_PIX_FMT_RGBAF16LE = (int)207L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16LE = 207
     * }
     */
    public static int AV_PIX_FMT_RGBAF16LE() {
        return AV_PIX_FMT_RGBAF16LE;
    }
    private static final int AV_PIX_FMT_VUYX = (int)208L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYX = 208
     * }
     */
    public static int AV_PIX_FMT_VUYX() {
        return AV_PIX_FMT_VUYX;
    }
    private static final int AV_PIX_FMT_P012LE = (int)209L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012LE = 209
     * }
     */
    public static int AV_PIX_FMT_P012LE() {
        return AV_PIX_FMT_P012LE;
    }
    private static final int AV_PIX_FMT_P012BE = (int)210L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012BE = 210
     * }
     */
    public static int AV_PIX_FMT_P012BE() {
        return AV_PIX_FMT_P012BE;
    }
    private static final int AV_PIX_FMT_Y212BE = (int)211L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212BE = 211
     * }
     */
    public static int AV_PIX_FMT_Y212BE() {
        return AV_PIX_FMT_Y212BE;
    }
    private static final int AV_PIX_FMT_Y212LE = (int)212L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212LE = 212
     * }
     */
    public static int AV_PIX_FMT_Y212LE() {
        return AV_PIX_FMT_Y212LE;
    }
    private static final int AV_PIX_FMT_XV30BE = (int)213L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30BE = 213
     * }
     */
    public static int AV_PIX_FMT_XV30BE() {
        return AV_PIX_FMT_XV30BE;
    }
    private static final int AV_PIX_FMT_XV30LE = (int)214L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30LE = 214
     * }
     */
    public static int AV_PIX_FMT_XV30LE() {
        return AV_PIX_FMT_XV30LE;
    }
    private static final int AV_PIX_FMT_XV36BE = (int)215L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36BE = 215
     * }
     */
    public static int AV_PIX_FMT_XV36BE() {
        return AV_PIX_FMT_XV36BE;
    }
    private static final int AV_PIX_FMT_XV36LE = (int)216L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36LE = 216
     * }
     */
    public static int AV_PIX_FMT_XV36LE() {
        return AV_PIX_FMT_XV36LE;
    }
    private static final int AV_PIX_FMT_RGBF32BE = (int)217L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32BE = 217
     * }
     */
    public static int AV_PIX_FMT_RGBF32BE() {
        return AV_PIX_FMT_RGBF32BE;
    }
    private static final int AV_PIX_FMT_RGBF32LE = (int)218L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32LE = 218
     * }
     */
    public static int AV_PIX_FMT_RGBF32LE() {
        return AV_PIX_FMT_RGBF32LE;
    }
    private static final int AV_PIX_FMT_RGBAF32BE = (int)219L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32BE = 219
     * }
     */
    public static int AV_PIX_FMT_RGBAF32BE() {
        return AV_PIX_FMT_RGBAF32BE;
    }
    private static final int AV_PIX_FMT_RGBAF32LE = (int)220L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32LE = 220
     * }
     */
    public static int AV_PIX_FMT_RGBAF32LE() {
        return AV_PIX_FMT_RGBAF32LE;
    }
    private static final int AV_PIX_FMT_P212BE = (int)221L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P212BE = 221
     * }
     */
    public static int AV_PIX_FMT_P212BE() {
        return AV_PIX_FMT_P212BE;
    }
    private static final int AV_PIX_FMT_P212LE = (int)222L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P212LE = 222
     * }
     */
    public static int AV_PIX_FMT_P212LE() {
        return AV_PIX_FMT_P212LE;
    }
    private static final int AV_PIX_FMT_P412BE = (int)223L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P412BE = 223
     * }
     */
    public static int AV_PIX_FMT_P412BE() {
        return AV_PIX_FMT_P412BE;
    }
    private static final int AV_PIX_FMT_P412LE = (int)224L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P412LE = 224
     * }
     */
    public static int AV_PIX_FMT_P412LE() {
        return AV_PIX_FMT_P412LE;
    }
    private static final int AV_PIX_FMT_GBRAP14BE = (int)225L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP14BE = 225
     * }
     */
    public static int AV_PIX_FMT_GBRAP14BE() {
        return AV_PIX_FMT_GBRAP14BE;
    }
    private static final int AV_PIX_FMT_GBRAP14LE = (int)226L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP14LE = 226
     * }
     */
    public static int AV_PIX_FMT_GBRAP14LE() {
        return AV_PIX_FMT_GBRAP14LE;
    }
    private static final int AV_PIX_FMT_D3D12 = (int)227L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D12 = 227
     * }
     */
    public static int AV_PIX_FMT_D3D12() {
        return AV_PIX_FMT_D3D12;
    }
    private static final int AV_PIX_FMT_NB = (int)267L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NB = 267
     * }
     */
    public static int AV_PIX_FMT_NB() {
        return AV_PIX_FMT_NB;
    }

    private static class av_int_list_length_for_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_int_list_length_for_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static FunctionDescriptor av_int_list_length_for_size$descriptor() {
        return av_int_list_length_for_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static MethodHandle av_int_list_length_for_size$handle() {
        return av_int_list_length_for_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static MemorySegment av_int_list_length_for_size$address() {
        return av_int_list_length_for_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static int av_int_list_length_for_size(int elsize, MemorySegment list, long term) {
        var mh$ = av_int_list_length_for_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_int_list_length_for_size", elsize, list, term);
            }
            return (int)mh$.invokeExact(elsize, list, term);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_time_base_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_time_base_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static FunctionDescriptor av_get_time_base_q$descriptor() {
        return av_get_time_base_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MethodHandle av_get_time_base_q$handle() {
        return av_get_time_base_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MemorySegment av_get_time_base_q$address() {
        return av_get_time_base_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MemorySegment av_get_time_base_q(SegmentAllocator allocator) {
        var mh$ = av_get_time_base_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_time_base_q", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fourcc_make_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fourcc_make_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static FunctionDescriptor av_fourcc_make_string$descriptor() {
        return av_fourcc_make_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MethodHandle av_fourcc_make_string$handle() {
        return av_fourcc_make_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MemorySegment av_fourcc_make_string$address() {
        return av_fourcc_make_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MemorySegment av_fourcc_make_string(MemorySegment buf, int fourcc) {
        var mh$ = av_fourcc_make_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fourcc_make_string", buf, fourcc);
            }
            return (MemorySegment)mh$.invokeExact(buf, fourcc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static FunctionDescriptor av_frame_alloc$descriptor() {
        return av_frame_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MethodHandle av_frame_alloc$handle() {
        return av_frame_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MemorySegment av_frame_alloc$address() {
        return av_frame_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MemorySegment av_frame_alloc() {
        var mh$ = av_frame_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static FunctionDescriptor av_frame_free$descriptor() {
        return av_frame_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static MethodHandle av_frame_free$handle() {
        return av_frame_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static MemorySegment av_frame_free$address() {
        return av_frame_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static void av_frame_free(MemorySegment frame) {
        var mh$ = av_frame_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_free", frame);
            }
            mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_ref$descriptor() {
        return av_frame_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_ref$handle() {
        return av_frame_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_ref$address() {
        return av_frame_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_ref", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_replace$descriptor() {
        return av_frame_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_replace$handle() {
        return av_frame_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_replace$address() {
        return av_frame_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_replace(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_replace", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_clone$descriptor() {
        return av_frame_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_clone$handle() {
        return av_frame_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_clone$address() {
        return av_frame_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_clone(MemorySegment src) {
        var mh$ = av_frame_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_clone", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_unref$descriptor() {
        return av_frame_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_unref$handle() {
        return av_frame_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_unref$address() {
        return av_frame_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static void av_frame_unref(MemorySegment frame) {
        var mh$ = av_frame_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_unref", frame);
            }
            mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_move_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_move_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_move_ref$descriptor() {
        return av_frame_move_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_move_ref$handle() {
        return av_frame_move_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_move_ref$address() {
        return av_frame_move_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static void av_frame_move_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_move_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_move_ref", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static FunctionDescriptor av_frame_get_buffer$descriptor() {
        return av_frame_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static MethodHandle av_frame_get_buffer$handle() {
        return av_frame_get_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static MemorySegment av_frame_get_buffer$address() {
        return av_frame_get_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static int av_frame_get_buffer(MemorySegment frame, int align) {
        var mh$ = av_frame_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_buffer", frame, align);
            }
            return (int)mh$.invokeExact(frame, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_is_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_is_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_is_writable$descriptor() {
        return av_frame_is_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_is_writable$handle() {
        return av_frame_is_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_is_writable$address() {
        return av_frame_is_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_is_writable(MemorySegment frame) {
        var mh$ = av_frame_is_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_is_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_make_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_make_writable$descriptor() {
        return av_frame_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_make_writable$handle() {
        return av_frame_make_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_make_writable$address() {
        return av_frame_make_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_make_writable(MemorySegment frame) {
        var mh$ = av_frame_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_make_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy$descriptor() {
        return av_frame_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy$handle() {
        return av_frame_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_copy$address() {
        return av_frame_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_copy_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy_props$descriptor() {
        return av_frame_copy_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy_props$handle() {
        return av_frame_copy_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_copy_props$address() {
        return av_frame_copy_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy_props(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy_props", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_plane_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_plane_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static FunctionDescriptor av_frame_get_plane_buffer$descriptor() {
        return av_frame_get_plane_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MethodHandle av_frame_get_plane_buffer$handle() {
        return av_frame_get_plane_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MemorySegment av_frame_get_plane_buffer$address() {
        return av_frame_get_plane_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MemorySegment av_frame_get_plane_buffer(MemorySegment frame, int plane) {
        var mh$ = av_frame_get_plane_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_plane_buffer", frame, plane);
            }
            return (MemorySegment)mh$.invokeExact(frame, plane);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_new_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data$descriptor() {
        return av_frame_new_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_frame_new_side_data$handle() {
        return av_frame_new_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_frame_new_side_data$address() {
        return av_frame_new_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_frame_new_side_data(MemorySegment frame, int type, long size) {
        var mh$ = av_frame_new_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data", frame, type, size);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data_from_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_new_side_data_from_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data_from_buf$descriptor() {
        return av_frame_new_side_data_from_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_frame_new_side_data_from_buf$handle() {
        return av_frame_new_side_data_from_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_frame_new_side_data_from_buf$address() {
        return av_frame_new_side_data_from_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_frame_new_side_data_from_buf(MemorySegment frame, int type, MemorySegment buf) {
        var mh$ = av_frame_new_side_data_from_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data_from_buf", frame, type, buf);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_get_side_data$descriptor() {
        return av_frame_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_get_side_data$handle() {
        return av_frame_get_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_get_side_data$address() {
        return av_frame_get_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_get_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_side_data", frame, type);
            }
            return (MemorySegment)mh$.invokeExact(frame, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_remove_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_remove_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_remove_side_data$descriptor() {
        return av_frame_remove_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_remove_side_data$handle() {
        return av_frame_remove_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_remove_side_data$address() {
        return av_frame_remove_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static void av_frame_remove_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_remove_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_remove_side_data", frame, type);
            }
            mh$.invokeExact(frame, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_apply_cropping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_apply_cropping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_frame_apply_cropping$descriptor() {
        return av_frame_apply_cropping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_frame_apply_cropping$handle() {
        return av_frame_apply_cropping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment av_frame_apply_cropping$address() {
        return av_frame_apply_cropping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static int av_frame_apply_cropping(MemorySegment frame, int flags) {
        var mh$ = av_frame_apply_cropping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_apply_cropping", frame, flags);
            }
            return (int)mh$.invokeExact(frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_name$descriptor() {
        return av_frame_side_data_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_name$handle() {
        return av_frame_side_data_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_name$address() {
        return av_frame_side_data_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_name(int type) {
        var mh$ = av_frame_side_data_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_desc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_desc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_desc$descriptor() {
        return av_frame_side_data_desc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_desc$handle() {
        return av_frame_side_data_desc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_desc$address() {
        return av_frame_side_data_desc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_desc(int type) {
        var mh$ = av_frame_side_data_desc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_desc", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_free$descriptor() {
        return av_frame_side_data_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static MethodHandle av_frame_side_data_free$handle() {
        return av_frame_side_data_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static MemorySegment av_frame_side_data_free$address() {
        return av_frame_side_data_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static void av_frame_side_data_free(MemorySegment sd, MemorySegment nb_sd) {
        var mh$ = av_frame_side_data_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_free", sd, nb_sd);
            }
            mh$.invokeExact(sd, nb_sd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_new$descriptor() {
        return av_frame_side_data_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_new$handle() {
        return av_frame_side_data_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_new$address() {
        return av_frame_side_data_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_new(MemorySegment sd, MemorySegment nb_sd, int type, long size, int flags) {
        var mh$ = av_frame_side_data_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_new", sd, nb_sd, type, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type, size, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_add$descriptor() {
        return av_frame_side_data_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_add$handle() {
        return av_frame_side_data_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_add$address() {
        return av_frame_side_data_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_add(MemorySegment sd, MemorySegment nb_sd, int type, MemorySegment buf, int flags) {
        var mh$ = av_frame_side_data_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_add", sd, nb_sd, type, buf, flags);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type, buf, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_clone$descriptor() {
        return av_frame_side_data_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_clone$handle() {
        return av_frame_side_data_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_clone$address() {
        return av_frame_side_data_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static int av_frame_side_data_clone(MemorySegment sd, MemorySegment nb_sd, MemorySegment src, int flags) {
        var mh$ = av_frame_side_data_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_clone", sd, nb_sd, src, flags);
            }
            return (int)mh$.invokeExact(sd, nb_sd, src, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_get_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_get_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_get_c$descriptor() {
        return av_frame_side_data_get_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_get_c$handle() {
        return av_frame_side_data_get_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_get_c$address() {
        return av_frame_side_data_get_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_get_c(MemorySegment sd, int nb_sd, int type) {
        var mh$ = av_frame_side_data_get_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_get_c", sd, nb_sd, type);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_remove$descriptor() {
        return av_frame_side_data_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_remove$handle() {
        return av_frame_side_data_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_remove$address() {
        return av_frame_side_data_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static void av_frame_side_data_remove(MemorySegment sd, MemorySegment nb_sd, int type) {
        var mh$ = av_frame_side_data_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_remove", sd, nb_sd, type);
            }
            mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_codec_iterate$descriptor() {
        return av_codec_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_codec_iterate$handle() {
        return av_codec_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_codec_iterate$address() {
        return av_codec_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_codec_iterate(MemorySegment opaque) {
        var mh$ = av_codec_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_find_decoder$descriptor() {
        return avcodec_find_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_find_decoder$handle() {
        return avcodec_find_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_decoder$address() {
        return avcodec_find_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_decoder(int id) {
        var mh$ = avcodec_find_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_decoder", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_decoder_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_decoder_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_find_decoder_by_name$descriptor() {
        return avcodec_find_decoder_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_find_decoder_by_name$handle() {
        return avcodec_find_decoder_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_decoder_by_name$address() {
        return avcodec_find_decoder_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_decoder_by_name(MemorySegment name) {
        var mh$ = avcodec_find_decoder_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_decoder_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_find_encoder$descriptor() {
        return avcodec_find_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_find_encoder$handle() {
        return avcodec_find_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_encoder$address() {
        return avcodec_find_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_encoder(int id) {
        var mh$ = avcodec_find_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_encoder", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_encoder_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_encoder_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_find_encoder_by_name$descriptor() {
        return avcodec_find_encoder_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_find_encoder_by_name$handle() {
        return avcodec_find_encoder_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_encoder_by_name$address() {
        return avcodec_find_encoder_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_encoder_by_name(MemorySegment name) {
        var mh$ = avcodec_find_encoder_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_encoder_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_is_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_is_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor av_codec_is_encoder$descriptor() {
        return av_codec_is_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static MethodHandle av_codec_is_encoder$handle() {
        return av_codec_is_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static MemorySegment av_codec_is_encoder$address() {
        return av_codec_is_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static int av_codec_is_encoder(MemorySegment codec) {
        var mh$ = av_codec_is_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_is_encoder", codec);
            }
            return (int)mh$.invokeExact(codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_is_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_is_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor av_codec_is_decoder$descriptor() {
        return av_codec_is_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static MethodHandle av_codec_is_decoder$handle() {
        return av_codec_is_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static MemorySegment av_codec_is_decoder$address() {
        return av_codec_is_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static int av_codec_is_decoder(MemorySegment codec) {
        var mh$ = av_codec_is_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_is_decoder", codec);
            }
            return (int)mh$.invokeExact(codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_profile_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_profile_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static FunctionDescriptor av_get_profile_name$descriptor() {
        return av_get_profile_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MethodHandle av_get_profile_name$handle() {
        return av_get_profile_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MemorySegment av_get_profile_name$address() {
        return av_get_profile_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MemorySegment av_get_profile_name(MemorySegment codec, int profile) {
        var mh$ = av_get_profile_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_profile_name", codec, profile);
            }
            return (MemorySegment)mh$.invokeExact(codec, profile);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_hw_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_hw_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static FunctionDescriptor avcodec_get_hw_config$descriptor() {
        return avcodec_get_hw_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MethodHandle avcodec_get_hw_config$handle() {
        return avcodec_get_hw_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MemorySegment avcodec_get_hw_config$address() {
        return avcodec_get_hw_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MemorySegment avcodec_get_hw_config(MemorySegment codec, int index) {
        var mh$ = avcodec_get_hw_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_hw_config", codec, index);
            }
            return (MemorySegment)mh$.invokeExact(codec, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_side_data_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_side_data_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_new(AVPacketSideData **psd, int *pnb_sd, enum AVPacketSideDataType type, size_t size, int flags)
     * }
     */
    public static FunctionDescriptor av_packet_side_data_new$descriptor() {
        return av_packet_side_data_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_new(AVPacketSideData **psd, int *pnb_sd, enum AVPacketSideDataType type, size_t size, int flags)
     * }
     */
    public static MethodHandle av_packet_side_data_new$handle() {
        return av_packet_side_data_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_new(AVPacketSideData **psd, int *pnb_sd, enum AVPacketSideDataType type, size_t size, int flags)
     * }
     */
    public static MemorySegment av_packet_side_data_new$address() {
        return av_packet_side_data_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_new(AVPacketSideData **psd, int *pnb_sd, enum AVPacketSideDataType type, size_t size, int flags)
     * }
     */
    public static MemorySegment av_packet_side_data_new(MemorySegment psd, MemorySegment pnb_sd, int type, long size, int flags) {
        var mh$ = av_packet_side_data_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_side_data_new", psd, pnb_sd, type, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(psd, pnb_sd, type, size, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_side_data_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_side_data_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_add(AVPacketSideData **sd, int *nb_sd, enum AVPacketSideDataType type, void *data, size_t size, int flags)
     * }
     */
    public static FunctionDescriptor av_packet_side_data_add$descriptor() {
        return av_packet_side_data_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_add(AVPacketSideData **sd, int *nb_sd, enum AVPacketSideDataType type, void *data, size_t size, int flags)
     * }
     */
    public static MethodHandle av_packet_side_data_add$handle() {
        return av_packet_side_data_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_add(AVPacketSideData **sd, int *nb_sd, enum AVPacketSideDataType type, void *data, size_t size, int flags)
     * }
     */
    public static MemorySegment av_packet_side_data_add$address() {
        return av_packet_side_data_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVPacketSideData *av_packet_side_data_add(AVPacketSideData **sd, int *nb_sd, enum AVPacketSideDataType type, void *data, size_t size, int flags)
     * }
     */
    public static MemorySegment av_packet_side_data_add(MemorySegment sd, MemorySegment nb_sd, int type, MemorySegment data, long size, int flags) {
        var mh$ = av_packet_side_data_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_side_data_add", sd, nb_sd, type, data, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type, data, size, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_side_data_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_side_data_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVPacketSideData *av_packet_side_data_get(const AVPacketSideData *sd, int nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static FunctionDescriptor av_packet_side_data_get$descriptor() {
        return av_packet_side_data_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVPacketSideData *av_packet_side_data_get(const AVPacketSideData *sd, int nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static MethodHandle av_packet_side_data_get$handle() {
        return av_packet_side_data_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVPacketSideData *av_packet_side_data_get(const AVPacketSideData *sd, int nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static MemorySegment av_packet_side_data_get$address() {
        return av_packet_side_data_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVPacketSideData *av_packet_side_data_get(const AVPacketSideData *sd, int nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static MemorySegment av_packet_side_data_get(MemorySegment sd, int nb_sd, int type) {
        var mh$ = av_packet_side_data_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_side_data_get", sd, nb_sd, type);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_side_data_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_side_data_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_side_data_remove(AVPacketSideData *sd, int *nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static FunctionDescriptor av_packet_side_data_remove$descriptor() {
        return av_packet_side_data_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_side_data_remove(AVPacketSideData *sd, int *nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static MethodHandle av_packet_side_data_remove$handle() {
        return av_packet_side_data_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_side_data_remove(AVPacketSideData *sd, int *nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static MemorySegment av_packet_side_data_remove$address() {
        return av_packet_side_data_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_side_data_remove(AVPacketSideData *sd, int *nb_sd, enum AVPacketSideDataType type)
     * }
     */
    public static void av_packet_side_data_remove(MemorySegment sd, MemorySegment nb_sd, int type) {
        var mh$ = av_packet_side_data_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_side_data_remove", sd, nb_sd, type);
            }
            mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_side_data_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_side_data_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_side_data_free(AVPacketSideData **sd, int *nb_sd)
     * }
     */
    public static FunctionDescriptor av_packet_side_data_free$descriptor() {
        return av_packet_side_data_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_side_data_free(AVPacketSideData **sd, int *nb_sd)
     * }
     */
    public static MethodHandle av_packet_side_data_free$handle() {
        return av_packet_side_data_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_side_data_free(AVPacketSideData **sd, int *nb_sd)
     * }
     */
    public static MemorySegment av_packet_side_data_free$address() {
        return av_packet_side_data_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_side_data_free(AVPacketSideData **sd, int *nb_sd)
     * }
     */
    public static void av_packet_side_data_free(MemorySegment sd, MemorySegment nb_sd) {
        var mh$ = av_packet_side_data_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_side_data_free", sd, nb_sd);
            }
            mh$.invokeExact(sd, nb_sd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_side_data_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_side_data_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static FunctionDescriptor av_packet_side_data_name$descriptor() {
        return av_packet_side_data_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static MethodHandle av_packet_side_data_name$handle() {
        return av_packet_side_data_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static MemorySegment av_packet_side_data_name$address() {
        return av_packet_side_data_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static MemorySegment av_packet_side_data_name(int type) {
        var mh$ = av_packet_side_data_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_side_data_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static FunctionDescriptor av_packet_alloc$descriptor() {
        return av_packet_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static MethodHandle av_packet_alloc$handle() {
        return av_packet_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static MemorySegment av_packet_alloc$address() {
        return av_packet_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static MemorySegment av_packet_alloc() {
        var mh$ = av_packet_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_clone$descriptor() {
        return av_packet_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_clone$handle() {
        return av_packet_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_clone$address() {
        return av_packet_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_clone(MemorySegment src) {
        var mh$ = av_packet_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_clone", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static FunctionDescriptor av_packet_free$descriptor() {
        return av_packet_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static MethodHandle av_packet_free$handle() {
        return av_packet_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static MemorySegment av_packet_free$address() {
        return av_packet_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static void av_packet_free(MemorySegment pkt) {
        var mh$ = av_packet_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_free", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_init_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_init_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_init_packet$descriptor() {
        return av_init_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_init_packet$handle() {
        return av_init_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_init_packet$address() {
        return av_init_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static void av_init_packet(MemorySegment pkt) {
        var mh$ = av_init_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_init_packet", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_new_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_new_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_new_packet$descriptor() {
        return av_new_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_new_packet$handle() {
        return av_new_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_new_packet$address() {
        return av_new_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static int av_new_packet(MemorySegment pkt, int size) {
        var mh$ = av_new_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_new_packet", pkt, size);
            }
            return (int)mh$.invokeExact(pkt, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_shrink_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_shrink_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_shrink_packet$descriptor() {
        return av_shrink_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_shrink_packet$handle() {
        return av_shrink_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_shrink_packet$address() {
        return av_shrink_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static void av_shrink_packet(MemorySegment pkt, int size) {
        var mh$ = av_shrink_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_shrink_packet", pkt, size);
            }
            mh$.invokeExact(pkt, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_grow_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_grow_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static FunctionDescriptor av_grow_packet$descriptor() {
        return av_grow_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static MethodHandle av_grow_packet$handle() {
        return av_grow_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static MemorySegment av_grow_packet$address() {
        return av_grow_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static int av_grow_packet(MemorySegment pkt, int grow_by) {
        var mh$ = av_grow_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_grow_packet", pkt, grow_by);
            }
            return (int)mh$.invokeExact(pkt, grow_by);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_from_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_from_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static FunctionDescriptor av_packet_from_data$descriptor() {
        return av_packet_from_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static MethodHandle av_packet_from_data$handle() {
        return av_packet_from_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static MemorySegment av_packet_from_data$address() {
        return av_packet_from_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static int av_packet_from_data(MemorySegment pkt, MemorySegment data, int size) {
        var mh$ = av_packet_from_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_from_data", pkt, data, size);
            }
            return (int)mh$.invokeExact(pkt, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_new_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_new_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_packet_new_side_data$descriptor() {
        return av_packet_new_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_packet_new_side_data$handle() {
        return av_packet_new_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_packet_new_side_data$address() {
        return av_packet_new_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_packet_new_side_data(MemorySegment pkt, int type, long size) {
        var mh$ = av_packet_new_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_new_side_data", pkt, type, size);
            }
            return (MemorySegment)mh$.invokeExact(pkt, type, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_add_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_add_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static FunctionDescriptor av_packet_add_side_data$descriptor() {
        return av_packet_add_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static MethodHandle av_packet_add_side_data$handle() {
        return av_packet_add_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static MemorySegment av_packet_add_side_data$address() {
        return av_packet_add_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static int av_packet_add_side_data(MemorySegment pkt, int type, MemorySegment data, long size) {
        var mh$ = av_packet_add_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_add_side_data", pkt, type, data, size);
            }
            return (int)mh$.invokeExact(pkt, type, data, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_shrink_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_shrink_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_packet_shrink_side_data$descriptor() {
        return av_packet_shrink_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_packet_shrink_side_data$handle() {
        return av_packet_shrink_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_packet_shrink_side_data$address() {
        return av_packet_shrink_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static int av_packet_shrink_side_data(MemorySegment pkt, int type, long size) {
        var mh$ = av_packet_shrink_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_shrink_side_data", pkt, type, size);
            }
            return (int)mh$.invokeExact(pkt, type, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_get_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static FunctionDescriptor av_packet_get_side_data$descriptor() {
        return av_packet_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MethodHandle av_packet_get_side_data$handle() {
        return av_packet_get_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MemorySegment av_packet_get_side_data$address() {
        return av_packet_get_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MemorySegment av_packet_get_side_data(MemorySegment pkt, int type, MemorySegment size) {
        var mh$ = av_packet_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_get_side_data", pkt, type, size);
            }
            return (MemorySegment)mh$.invokeExact(pkt, type, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_pack_dictionary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_pack_dictionary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static FunctionDescriptor av_packet_pack_dictionary$descriptor() {
        return av_packet_pack_dictionary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static MethodHandle av_packet_pack_dictionary$handle() {
        return av_packet_pack_dictionary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static MemorySegment av_packet_pack_dictionary$address() {
        return av_packet_pack_dictionary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static MemorySegment av_packet_pack_dictionary(MemorySegment dict, MemorySegment size) {
        var mh$ = av_packet_pack_dictionary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_pack_dictionary", dict, size);
            }
            return (MemorySegment)mh$.invokeExact(dict, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_unpack_dictionary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_unpack_dictionary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static FunctionDescriptor av_packet_unpack_dictionary$descriptor() {
        return av_packet_unpack_dictionary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static MethodHandle av_packet_unpack_dictionary$handle() {
        return av_packet_unpack_dictionary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static MemorySegment av_packet_unpack_dictionary$address() {
        return av_packet_unpack_dictionary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static int av_packet_unpack_dictionary(MemorySegment data, long size, MemorySegment dict) {
        var mh$ = av_packet_unpack_dictionary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_unpack_dictionary", data, size, dict);
            }
            return (int)mh$.invokeExact(data, size, dict);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_free_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_free_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_free_side_data$descriptor() {
        return av_packet_free_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_free_side_data$handle() {
        return av_packet_free_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_free_side_data$address() {
        return av_packet_free_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static void av_packet_free_side_data(MemorySegment pkt) {
        var mh$ = av_packet_free_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_free_side_data", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_ref$descriptor() {
        return av_packet_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_ref$handle() {
        return av_packet_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_ref$address() {
        return av_packet_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static int av_packet_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_packet_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_ref", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_unref$descriptor() {
        return av_packet_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_unref$handle() {
        return av_packet_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_unref$address() {
        return av_packet_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static void av_packet_unref(MemorySegment pkt) {
        var mh$ = av_packet_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_unref", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_move_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_move_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_move_ref$descriptor() {
        return av_packet_move_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_move_ref$handle() {
        return av_packet_move_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_move_ref$address() {
        return av_packet_move_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static void av_packet_move_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_packet_move_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_move_ref", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_copy_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_copy_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_copy_props$descriptor() {
        return av_packet_copy_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_copy_props$handle() {
        return av_packet_copy_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_copy_props$address() {
        return av_packet_copy_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static int av_packet_copy_props(MemorySegment dst, MemorySegment src) {
        var mh$ = av_packet_copy_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_copy_props", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_make_refcounted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_make_refcounted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_make_refcounted$descriptor() {
        return av_packet_make_refcounted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_make_refcounted$handle() {
        return av_packet_make_refcounted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_make_refcounted$address() {
        return av_packet_make_refcounted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static int av_packet_make_refcounted(MemorySegment pkt) {
        var mh$ = av_packet_make_refcounted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_make_refcounted", pkt);
            }
            return (int)mh$.invokeExact(pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_make_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_make_writable$descriptor() {
        return av_packet_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_make_writable$handle() {
        return av_packet_make_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_make_writable$address() {
        return av_packet_make_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static int av_packet_make_writable(MemorySegment pkt) {
        var mh$ = av_packet_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_make_writable", pkt);
            }
            return (int)mh$.invokeExact(pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_rescale_ts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_packet_rescale_ts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static FunctionDescriptor av_packet_rescale_ts$descriptor() {
        return av_packet_rescale_ts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static MethodHandle av_packet_rescale_ts$handle() {
        return av_packet_rescale_ts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static MemorySegment av_packet_rescale_ts$address() {
        return av_packet_rescale_ts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static void av_packet_rescale_ts(MemorySegment pkt, MemorySegment tb_src, MemorySegment tb_dst) {
        var mh$ = av_packet_rescale_ts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_rescale_ts", pkt, tb_src, tb_dst);
            }
            mh$.invokeExact(pkt, tb_src, tb_dst);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_parameters_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static FunctionDescriptor avcodec_parameters_alloc$descriptor() {
        return avcodec_parameters_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static MethodHandle avcodec_parameters_alloc$handle() {
        return avcodec_parameters_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static MemorySegment avcodec_parameters_alloc$address() {
        return avcodec_parameters_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static MemorySegment avcodec_parameters_alloc() {
        var mh$ = avcodec_parameters_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_parameters_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_free$descriptor() {
        return avcodec_parameters_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static MethodHandle avcodec_parameters_free$handle() {
        return avcodec_parameters_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static MemorySegment avcodec_parameters_free$address() {
        return avcodec_parameters_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static void avcodec_parameters_free(MemorySegment par) {
        var mh$ = avcodec_parameters_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_free", par);
            }
            mh$.invokeExact(par);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_parameters_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_copy$descriptor() {
        return avcodec_parameters_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static MethodHandle avcodec_parameters_copy$handle() {
        return avcodec_parameters_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static MemorySegment avcodec_parameters_copy$address() {
        return avcodec_parameters_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static int avcodec_parameters_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = avcodec_parameters_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_audio_frame_duration2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_audio_frame_duration2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static FunctionDescriptor av_get_audio_frame_duration2$descriptor() {
        return av_get_audio_frame_duration2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static MethodHandle av_get_audio_frame_duration2$handle() {
        return av_get_audio_frame_duration2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static MemorySegment av_get_audio_frame_duration2$address() {
        return av_get_audio_frame_duration2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static int av_get_audio_frame_duration2(MemorySegment par, int frame_bytes) {
        var mh$ = av_get_audio_frame_duration2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_audio_frame_duration2", par, frame_bytes);
            }
            return (int)mh$.invokeExact(par, frame_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static FunctionDescriptor avcodec_version$descriptor() {
        return avcodec_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static MethodHandle avcodec_version$handle() {
        return avcodec_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static MemorySegment avcodec_version$address() {
        return avcodec_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static int avcodec_version() {
        var mh$ = avcodec_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static FunctionDescriptor avcodec_configuration$descriptor() {
        return avcodec_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MethodHandle avcodec_configuration$handle() {
        return avcodec_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MemorySegment avcodec_configuration$address() {
        return avcodec_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MemorySegment avcodec_configuration() {
        var mh$ = avcodec_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static FunctionDescriptor avcodec_license$descriptor() {
        return avcodec_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MethodHandle avcodec_license$handle() {
        return avcodec_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MemorySegment avcodec_license$address() {
        return avcodec_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MemorySegment avcodec_license() {
        var mh$ = avcodec_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_alloc_context3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_alloc_context3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor avcodec_alloc_context3$descriptor() {
        return avcodec_alloc_context3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MethodHandle avcodec_alloc_context3$handle() {
        return avcodec_alloc_context3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MemorySegment avcodec_alloc_context3$address() {
        return avcodec_alloc_context3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MemorySegment avcodec_alloc_context3(MemorySegment codec) {
        var mh$ = avcodec_alloc_context3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_alloc_context3", codec);
            }
            return (MemorySegment)mh$.invokeExact(codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_free_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_free_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static FunctionDescriptor avcodec_free_context$descriptor() {
        return avcodec_free_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static MethodHandle avcodec_free_context$handle() {
        return avcodec_free_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static MemorySegment avcodec_free_context$address() {
        return avcodec_free_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static void avcodec_free_context(MemorySegment avctx) {
        var mh$ = avcodec_free_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_free_context", avctx);
            }
            mh$.invokeExact(avctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static FunctionDescriptor avcodec_get_class$descriptor() {
        return avcodec_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MethodHandle avcodec_get_class$handle() {
        return avcodec_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MemorySegment avcodec_get_class$address() {
        return avcodec_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MemorySegment avcodec_get_class() {
        var mh$ = avcodec_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_subtitle_rect_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_subtitle_rect_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static FunctionDescriptor avcodec_get_subtitle_rect_class$descriptor() {
        return avcodec_get_subtitle_rect_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MethodHandle avcodec_get_subtitle_rect_class$handle() {
        return avcodec_get_subtitle_rect_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MemorySegment avcodec_get_subtitle_rect_class$address() {
        return avcodec_get_subtitle_rect_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MemorySegment avcodec_get_subtitle_rect_class() {
        var mh$ = avcodec_get_subtitle_rect_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_subtitle_rect_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_from_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_parameters_from_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_from_context$descriptor() {
        return avcodec_parameters_from_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static MethodHandle avcodec_parameters_from_context$handle() {
        return avcodec_parameters_from_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static MemorySegment avcodec_parameters_from_context$address() {
        return avcodec_parameters_from_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static int avcodec_parameters_from_context(MemorySegment par, MemorySegment codec) {
        var mh$ = avcodec_parameters_from_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_from_context", par, codec);
            }
            return (int)mh$.invokeExact(par, codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_to_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_parameters_to_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_to_context$descriptor() {
        return avcodec_parameters_to_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static MethodHandle avcodec_parameters_to_context$handle() {
        return avcodec_parameters_to_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static MemorySegment avcodec_parameters_to_context$address() {
        return avcodec_parameters_to_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static int avcodec_parameters_to_context(MemorySegment codec, MemorySegment par) {
        var mh$ = avcodec_parameters_to_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_to_context", codec, par);
            }
            return (int)mh$.invokeExact(codec, par);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_open2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_open2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avcodec_open2$descriptor() {
        return avcodec_open2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static MethodHandle avcodec_open2$handle() {
        return avcodec_open2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static MemorySegment avcodec_open2$address() {
        return avcodec_open2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static int avcodec_open2(MemorySegment avctx, MemorySegment codec, MemorySegment options) {
        var mh$ = avcodec_open2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_open2", avctx, codec, options);
            }
            return (int)mh$.invokeExact(avctx, codec, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avsubtitle_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avsubtitle_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static FunctionDescriptor avsubtitle_free$descriptor() {
        return avsubtitle_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static MethodHandle avsubtitle_free$handle() {
        return avsubtitle_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static MemorySegment avsubtitle_free$address() {
        return avsubtitle_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static void avsubtitle_free(MemorySegment sub) {
        var mh$ = avsubtitle_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avsubtitle_free", sub);
            }
            mh$.invokeExact(sub);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_buffer2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_get_buffer2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_buffer2$descriptor() {
        return avcodec_default_get_buffer2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle avcodec_default_get_buffer2$handle() {
        return avcodec_default_get_buffer2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment avcodec_default_get_buffer2$address() {
        return avcodec_default_get_buffer2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static int avcodec_default_get_buffer2(MemorySegment s, MemorySegment frame, int flags) {
        var mh$ = avcodec_default_get_buffer2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_buffer2", s, frame, flags);
            }
            return (int)mh$.invokeExact(s, frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_encode_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_get_encode_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_encode_buffer$descriptor() {
        return avcodec_default_get_encode_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static MethodHandle avcodec_default_get_encode_buffer$handle() {
        return avcodec_default_get_encode_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static MemorySegment avcodec_default_get_encode_buffer$address() {
        return avcodec_default_get_encode_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static int avcodec_default_get_encode_buffer(MemorySegment s, MemorySegment pkt, int flags) {
        var mh$ = avcodec_default_get_encode_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_encode_buffer", s, pkt, flags);
            }
            return (int)mh$.invokeExact(s, pkt, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_align_dimensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_align_dimensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static FunctionDescriptor avcodec_align_dimensions$descriptor() {
        return avcodec_align_dimensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static MethodHandle avcodec_align_dimensions$handle() {
        return avcodec_align_dimensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static MemorySegment avcodec_align_dimensions$address() {
        return avcodec_align_dimensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static void avcodec_align_dimensions(MemorySegment s, MemorySegment width, MemorySegment height) {
        var mh$ = avcodec_align_dimensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_align_dimensions", s, width, height);
            }
            mh$.invokeExact(s, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_align_dimensions2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_align_dimensions2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static FunctionDescriptor avcodec_align_dimensions2$descriptor() {
        return avcodec_align_dimensions2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static MethodHandle avcodec_align_dimensions2$handle() {
        return avcodec_align_dimensions2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static MemorySegment avcodec_align_dimensions2$address() {
        return avcodec_align_dimensions2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static void avcodec_align_dimensions2(MemorySegment s, MemorySegment width, MemorySegment height, MemorySegment linesize_align) {
        var mh$ = avcodec_align_dimensions2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_align_dimensions2", s, width, height, linesize_align);
            }
            mh$.invokeExact(s, width, height, linesize_align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_decode_subtitle2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_decode_subtitle2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_decode_subtitle2$descriptor() {
        return avcodec_decode_subtitle2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_decode_subtitle2$handle() {
        return avcodec_decode_subtitle2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_decode_subtitle2$address() {
        return avcodec_decode_subtitle2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static int avcodec_decode_subtitle2(MemorySegment avctx, MemorySegment sub, MemorySegment got_sub_ptr, MemorySegment avpkt) {
        var mh$ = avcodec_decode_subtitle2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_decode_subtitle2", avctx, sub, got_sub_ptr, avpkt);
            }
            return (int)mh$.invokeExact(avctx, sub, got_sub_ptr, avpkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_send_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_send_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_send_packet$descriptor() {
        return avcodec_send_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_send_packet$handle() {
        return avcodec_send_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_send_packet$address() {
        return avcodec_send_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static int avcodec_send_packet(MemorySegment avctx, MemorySegment avpkt) {
        var mh$ = avcodec_send_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_send_packet", avctx, avpkt);
            }
            return (int)mh$.invokeExact(avctx, avpkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_receive_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_receive_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor avcodec_receive_frame$descriptor() {
        return avcodec_receive_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static MethodHandle avcodec_receive_frame$handle() {
        return avcodec_receive_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static MemorySegment avcodec_receive_frame$address() {
        return avcodec_receive_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static int avcodec_receive_frame(MemorySegment avctx, MemorySegment frame) {
        var mh$ = avcodec_receive_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_receive_frame", avctx, frame);
            }
            return (int)mh$.invokeExact(avctx, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_send_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_send_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static FunctionDescriptor avcodec_send_frame$descriptor() {
        return avcodec_send_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static MethodHandle avcodec_send_frame$handle() {
        return avcodec_send_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static MemorySegment avcodec_send_frame$address() {
        return avcodec_send_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static int avcodec_send_frame(MemorySegment avctx, MemorySegment frame) {
        var mh$ = avcodec_send_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_send_frame", avctx, frame);
            }
            return (int)mh$.invokeExact(avctx, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_receive_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_receive_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_receive_packet$descriptor() {
        return avcodec_receive_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_receive_packet$handle() {
        return avcodec_receive_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_receive_packet$address() {
        return avcodec_receive_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static int avcodec_receive_packet(MemorySegment avctx, MemorySegment avpkt) {
        var mh$ = avcodec_receive_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_receive_packet", avctx, avpkt);
            }
            return (int)mh$.invokeExact(avctx, avpkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_hw_frames_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_hw_frames_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static FunctionDescriptor avcodec_get_hw_frames_parameters$descriptor() {
        return avcodec_get_hw_frames_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static MethodHandle avcodec_get_hw_frames_parameters$handle() {
        return avcodec_get_hw_frames_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static MemorySegment avcodec_get_hw_frames_parameters$address() {
        return avcodec_get_hw_frames_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static int avcodec_get_hw_frames_parameters(MemorySegment avctx, MemorySegment device_ref, int hw_pix_fmt, MemorySegment out_frames_ref) {
        var mh$ = avcodec_get_hw_frames_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_hw_frames_parameters", avctx, device_ref, hw_pix_fmt, out_frames_ref);
            }
            return (int)mh$.invokeExact(avctx, device_ref, hw_pix_fmt, out_frames_ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_supported_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_supported_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static FunctionDescriptor avcodec_get_supported_config$descriptor() {
        return avcodec_get_supported_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static MethodHandle avcodec_get_supported_config$handle() {
        return avcodec_get_supported_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static MemorySegment avcodec_get_supported_config$address() {
        return avcodec_get_supported_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static int avcodec_get_supported_config(MemorySegment avctx, MemorySegment codec, int config, int flags, MemorySegment out_configs, MemorySegment out_num_configs) {
        var mh$ = avcodec_get_supported_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_supported_config", avctx, codec, config, flags, out_configs, out_num_configs);
            }
            return (int)mh$.invokeExact(avctx, codec, config, flags, out_configs, out_num_configs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_parser_iterate$descriptor() {
        return av_parser_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_parser_iterate$handle() {
        return av_parser_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_parser_iterate$address() {
        return av_parser_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_parser_iterate(MemorySegment opaque) {
        var mh$ = av_parser_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static FunctionDescriptor av_parser_init$descriptor() {
        return av_parser_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MethodHandle av_parser_init$handle() {
        return av_parser_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MemorySegment av_parser_init$address() {
        return av_parser_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MemorySegment av_parser_init(int codec_id) {
        var mh$ = av_parser_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_init", codec_id);
            }
            return (MemorySegment)mh$.invokeExact(codec_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_parse2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_parse2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static FunctionDescriptor av_parser_parse2$descriptor() {
        return av_parser_parse2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static MethodHandle av_parser_parse2$handle() {
        return av_parser_parse2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static MemorySegment av_parser_parse2$address() {
        return av_parser_parse2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static int av_parser_parse2(MemorySegment s, MemorySegment avctx, MemorySegment poutbuf, MemorySegment poutbuf_size, MemorySegment buf, int buf_size, long pts, long dts, long pos) {
        var mh$ = av_parser_parse2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_parse2", s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
            }
            return (int)mh$.invokeExact(s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static FunctionDescriptor av_parser_close$descriptor() {
        return av_parser_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static MethodHandle av_parser_close$handle() {
        return av_parser_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static MemorySegment av_parser_close$address() {
        return av_parser_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static void av_parser_close(MemorySegment s) {
        var mh$ = av_parser_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_close", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_encode_subtitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_encode_subtitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static FunctionDescriptor avcodec_encode_subtitle$descriptor() {
        return avcodec_encode_subtitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static MethodHandle avcodec_encode_subtitle$handle() {
        return avcodec_encode_subtitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static MemorySegment avcodec_encode_subtitle$address() {
        return avcodec_encode_subtitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static int avcodec_encode_subtitle(MemorySegment avctx, MemorySegment buf, int buf_size, MemorySegment sub) {
        var mh$ = avcodec_encode_subtitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_encode_subtitle", avctx, buf, buf_size, sub);
            }
            return (int)mh$.invokeExact(avctx, buf, buf_size, sub);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_pix_fmt_to_codec_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_pix_fmt_to_codec_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor avcodec_pix_fmt_to_codec_tag$descriptor() {
        return avcodec_pix_fmt_to_codec_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle avcodec_pix_fmt_to_codec_tag$handle() {
        return avcodec_pix_fmt_to_codec_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment avcodec_pix_fmt_to_codec_tag$address() {
        return avcodec_pix_fmt_to_codec_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int avcodec_pix_fmt_to_codec_tag(int pix_fmt) {
        var mh$ = avcodec_pix_fmt_to_codec_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_pix_fmt_to_codec_tag", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_best_pix_fmt_of_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_best_pix_fmt_of_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static FunctionDescriptor avcodec_find_best_pix_fmt_of_list$descriptor() {
        return avcodec_find_best_pix_fmt_of_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MethodHandle avcodec_find_best_pix_fmt_of_list$handle() {
        return avcodec_find_best_pix_fmt_of_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MemorySegment avcodec_find_best_pix_fmt_of_list$address() {
        return avcodec_find_best_pix_fmt_of_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static int avcodec_find_best_pix_fmt_of_list(MemorySegment pix_fmt_list, int src_pix_fmt, int has_alpha, MemorySegment loss_ptr) {
        var mh$ = avcodec_find_best_pix_fmt_of_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_best_pix_fmt_of_list", pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr);
            }
            return (int)mh$.invokeExact(pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_get_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_format$descriptor() {
        return avcodec_default_get_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static MethodHandle avcodec_default_get_format$handle() {
        return avcodec_default_get_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static MemorySegment avcodec_default_get_format$address() {
        return avcodec_default_get_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static int avcodec_default_get_format(MemorySegment s, MemorySegment fmt) {
        var mh$ = avcodec_default_get_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_format", s, fmt);
            }
            return (int)mh$.invokeExact(s, fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static FunctionDescriptor avcodec_string$descriptor() {
        return avcodec_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static MethodHandle avcodec_string$handle() {
        return avcodec_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static MemorySegment avcodec_string$address() {
        return avcodec_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static void avcodec_string(MemorySegment buf, int buf_size, MemorySegment enc, int encode) {
        var mh$ = avcodec_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_string", buf, buf_size, enc, encode);
            }
            mh$.invokeExact(buf, buf_size, enc, encode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_execute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_execute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static FunctionDescriptor avcodec_default_execute$descriptor() {
        return avcodec_default_execute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static MethodHandle avcodec_default_execute$handle() {
        return avcodec_default_execute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static MemorySegment avcodec_default_execute$address() {
        return avcodec_default_execute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static int avcodec_default_execute(MemorySegment c, MemorySegment func, MemorySegment arg, MemorySegment ret, int count, int size) {
        var mh$ = avcodec_default_execute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_execute", c, func, arg, ret, count, size);
            }
            return (int)mh$.invokeExact(c, func, arg, ret, count, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_execute2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_execute2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static FunctionDescriptor avcodec_default_execute2$descriptor() {
        return avcodec_default_execute2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static MethodHandle avcodec_default_execute2$handle() {
        return avcodec_default_execute2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static MemorySegment avcodec_default_execute2$address() {
        return avcodec_default_execute2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static int avcodec_default_execute2(MemorySegment c, MemorySegment func, MemorySegment arg, MemorySegment ret, int count) {
        var mh$ = avcodec_default_execute2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_execute2", c, func, arg, ret, count);
            }
            return (int)mh$.invokeExact(c, func, arg, ret, count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_fill_audio_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_fill_audio_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static FunctionDescriptor avcodec_fill_audio_frame$descriptor() {
        return avcodec_fill_audio_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static MethodHandle avcodec_fill_audio_frame$handle() {
        return avcodec_fill_audio_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static MemorySegment avcodec_fill_audio_frame$address() {
        return avcodec_fill_audio_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static int avcodec_fill_audio_frame(MemorySegment frame, int nb_channels, int sample_fmt, MemorySegment buf, int buf_size, int align) {
        var mh$ = avcodec_fill_audio_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_fill_audio_frame", frame, nb_channels, sample_fmt, buf, buf_size, align);
            }
            return (int)mh$.invokeExact(frame, nb_channels, sample_fmt, buf, buf_size, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_flush_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_flush_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static FunctionDescriptor avcodec_flush_buffers$descriptor() {
        return avcodec_flush_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static MethodHandle avcodec_flush_buffers$handle() {
        return avcodec_flush_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static MemorySegment avcodec_flush_buffers$address() {
        return avcodec_flush_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static void avcodec_flush_buffers(MemorySegment avctx) {
        var mh$ = avcodec_flush_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_flush_buffers", avctx);
            }
            mh$.invokeExact(avctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_audio_frame_duration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_audio_frame_duration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static FunctionDescriptor av_get_audio_frame_duration$descriptor() {
        return av_get_audio_frame_duration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static MethodHandle av_get_audio_frame_duration$handle() {
        return av_get_audio_frame_duration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static MemorySegment av_get_audio_frame_duration$address() {
        return av_get_audio_frame_duration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static int av_get_audio_frame_duration(MemorySegment avctx, int frame_bytes) {
        var mh$ = av_get_audio_frame_duration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_audio_frame_duration", avctx, frame_bytes);
            }
            return (int)mh$.invokeExact(avctx, frame_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_padded_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_padded_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_padded_malloc$descriptor() {
        return av_fast_padded_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_padded_malloc$handle() {
        return av_fast_padded_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_padded_malloc$address() {
        return av_fast_padded_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_padded_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_padded_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_padded_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_padded_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_padded_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_padded_mallocz$descriptor() {
        return av_fast_padded_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_padded_mallocz$handle() {
        return av_fast_padded_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_padded_mallocz$address() {
        return av_fast_padded_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_padded_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_padded_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_padded_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_is_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_is_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static FunctionDescriptor avcodec_is_open$descriptor() {
        return avcodec_is_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static MethodHandle avcodec_is_open$handle() {
        return avcodec_is_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static MemorySegment avcodec_is_open$address() {
        return avcodec_is_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static int avcodec_is_open(MemorySegment s) {
        var mh$ = avcodec_is_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_is_open", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_get_packet$descriptor() {
        return av_get_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_get_packet$handle() {
        return av_get_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_get_packet$address() {
        return av_get_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static int av_get_packet(MemorySegment s, MemorySegment pkt, int size) {
        var mh$ = av_get_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_packet", s, pkt, size);
            }
            return (int)mh$.invokeExact(s, pkt, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_append_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_append_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_append_packet$descriptor() {
        return av_append_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_append_packet$handle() {
        return av_append_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_append_packet$address() {
        return av_append_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static int av_append_packet(MemorySegment s, MemorySegment pkt, int size) {
        var mh$ = av_append_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_append_packet", s, pkt, size);
            }
            return (int)mh$.invokeExact(s, pkt, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_disposition_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_disposition_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static FunctionDescriptor av_disposition_from_string$descriptor() {
        return av_disposition_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static MethodHandle av_disposition_from_string$handle() {
        return av_disposition_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static MemorySegment av_disposition_from_string$address() {
        return av_disposition_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static int av_disposition_from_string(MemorySegment disp) {
        var mh$ = av_disposition_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_disposition_from_string", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_disposition_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_disposition_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static FunctionDescriptor av_disposition_to_string$descriptor() {
        return av_disposition_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MethodHandle av_disposition_to_string$handle() {
        return av_disposition_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MemorySegment av_disposition_to_string$address() {
        return av_disposition_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MemorySegment av_disposition_to_string(int disposition) {
        var mh$ = av_disposition_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_disposition_to_string", disposition);
            }
            return (MemorySegment)mh$.invokeExact(disposition);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_parser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_get_parser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static FunctionDescriptor av_stream_get_parser$descriptor() {
        return av_stream_get_parser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MethodHandle av_stream_get_parser$handle() {
        return av_stream_get_parser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MemorySegment av_stream_get_parser$address() {
        return av_stream_get_parser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MemorySegment av_stream_get_parser(MemorySegment s) {
        var mh$ = av_stream_get_parser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_parser", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static FunctionDescriptor avformat_version$descriptor() {
        return avformat_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static MethodHandle avformat_version$handle() {
        return avformat_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static MemorySegment avformat_version$address() {
        return avformat_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static int avformat_version() {
        var mh$ = avformat_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static FunctionDescriptor avformat_configuration$descriptor() {
        return avformat_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MethodHandle avformat_configuration$handle() {
        return avformat_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MemorySegment avformat_configuration$address() {
        return avformat_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MemorySegment avformat_configuration() {
        var mh$ = avformat_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static FunctionDescriptor avformat_license$descriptor() {
        return avformat_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MethodHandle avformat_license$handle() {
        return avformat_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MemorySegment avformat_license$address() {
        return avformat_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MemorySegment avformat_license() {
        var mh$ = avformat_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_network_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_network_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static FunctionDescriptor avformat_network_init$descriptor() {
        return avformat_network_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static MethodHandle avformat_network_init$handle() {
        return avformat_network_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static MemorySegment avformat_network_init$address() {
        return avformat_network_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static int avformat_network_init() {
        var mh$ = avformat_network_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_network_init");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_network_deinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_network_deinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static FunctionDescriptor avformat_network_deinit$descriptor() {
        return avformat_network_deinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static MethodHandle avformat_network_deinit$handle() {
        return avformat_network_deinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static MemorySegment avformat_network_deinit$address() {
        return avformat_network_deinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static int avformat_network_deinit() {
        var mh$ = avformat_network_deinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_network_deinit");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_muxer_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_muxer_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_muxer_iterate$descriptor() {
        return av_muxer_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_muxer_iterate$handle() {
        return av_muxer_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_muxer_iterate$address() {
        return av_muxer_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_muxer_iterate(MemorySegment opaque) {
        var mh$ = av_muxer_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_muxer_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_demuxer_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_demuxer_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_demuxer_iterate$descriptor() {
        return av_demuxer_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_demuxer_iterate$handle() {
        return av_demuxer_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_demuxer_iterate$address() {
        return av_demuxer_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_demuxer_iterate(MemorySegment opaque) {
        var mh$ = av_demuxer_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_demuxer_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static FunctionDescriptor avformat_alloc_context$descriptor() {
        return avformat_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MethodHandle avformat_alloc_context$handle() {
        return avformat_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MemorySegment avformat_alloc_context$address() {
        return avformat_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MemorySegment avformat_alloc_context() {
        var mh$ = avformat_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_alloc_context");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_free_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_free_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_free_context$descriptor() {
        return avformat_free_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_free_context$handle() {
        return avformat_free_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_free_context$address() {
        return avformat_free_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static void avformat_free_context(MemorySegment s) {
        var mh$ = avformat_free_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_free_context", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static FunctionDescriptor avformat_get_class$descriptor() {
        return avformat_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MethodHandle avformat_get_class$handle() {
        return avformat_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MemorySegment avformat_get_class$address() {
        return avformat_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MemorySegment avformat_get_class() {
        var mh$ = avformat_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static FunctionDescriptor av_stream_get_class$descriptor() {
        return av_stream_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MethodHandle av_stream_get_class$handle() {
        return av_stream_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MemorySegment av_stream_get_class$address() {
        return av_stream_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MemorySegment av_stream_get_class() {
        var mh$ = av_stream_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_group_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_group_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static FunctionDescriptor av_stream_group_get_class$descriptor() {
        return av_stream_group_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static MethodHandle av_stream_group_get_class$handle() {
        return av_stream_group_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static MemorySegment av_stream_group_get_class$address() {
        return av_stream_group_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static MemorySegment av_stream_group_get_class() {
        var mh$ = av_stream_group_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_group_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_stream_group_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_stream_group_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static FunctionDescriptor avformat_stream_group_name$descriptor() {
        return avformat_stream_group_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static MethodHandle avformat_stream_group_name$handle() {
        return avformat_stream_group_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static MemorySegment avformat_stream_group_name$address() {
        return avformat_stream_group_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static MemorySegment avformat_stream_group_name(int type) {
        var mh$ = avformat_stream_group_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_stream_group_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_stream_group_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_stream_group_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_stream_group_create$descriptor() {
        return avformat_stream_group_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_stream_group_create$handle() {
        return avformat_stream_group_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_stream_group_create$address() {
        return avformat_stream_group_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_stream_group_create(MemorySegment s, int type, MemorySegment options) {
        var mh$ = avformat_stream_group_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_stream_group_create", s, type, options);
            }
            return (MemorySegment)mh$.invokeExact(s, type, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_new_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_new_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static FunctionDescriptor avformat_new_stream$descriptor() {
        return avformat_new_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static MethodHandle avformat_new_stream$handle() {
        return avformat_new_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static MemorySegment avformat_new_stream$address() {
        return avformat_new_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static MemorySegment avformat_new_stream(MemorySegment s, MemorySegment c) {
        var mh$ = avformat_new_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_new_stream", s, c);
            }
            return (MemorySegment)mh$.invokeExact(s, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_stream_group_add_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_stream_group_add_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static FunctionDescriptor avformat_stream_group_add_stream$descriptor() {
        return avformat_stream_group_add_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static MethodHandle avformat_stream_group_add_stream$handle() {
        return avformat_stream_group_add_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static MemorySegment avformat_stream_group_add_stream$address() {
        return avformat_stream_group_add_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static int avformat_stream_group_add_stream(MemorySegment stg, MemorySegment st) {
        var mh$ = avformat_stream_group_add_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_stream_group_add_stream", stg, st);
            }
            return (int)mh$.invokeExact(stg, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_new_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_new_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static FunctionDescriptor av_new_program$descriptor() {
        return av_new_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MethodHandle av_new_program$handle() {
        return av_new_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MemorySegment av_new_program$address() {
        return av_new_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MemorySegment av_new_program(MemorySegment s, int id) {
        var mh$ = av_new_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_new_program", s, id);
            }
            return (MemorySegment)mh$.invokeExact(s, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_alloc_output_context2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_alloc_output_context2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static FunctionDescriptor avformat_alloc_output_context2$descriptor() {
        return avformat_alloc_output_context2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static MethodHandle avformat_alloc_output_context2$handle() {
        return avformat_alloc_output_context2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static MemorySegment avformat_alloc_output_context2$address() {
        return avformat_alloc_output_context2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static int avformat_alloc_output_context2(MemorySegment ctx, MemorySegment oformat, MemorySegment format_name, MemorySegment filename) {
        var mh$ = avformat_alloc_output_context2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_alloc_output_context2", ctx, oformat, format_name, filename);
            }
            return (int)mh$.invokeExact(ctx, oformat, format_name, filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_input_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_input_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static FunctionDescriptor av_find_input_format$descriptor() {
        return av_find_input_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MethodHandle av_find_input_format$handle() {
        return av_find_input_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MemorySegment av_find_input_format$address() {
        return av_find_input_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MemorySegment av_find_input_format(MemorySegment short_name) {
        var mh$ = av_find_input_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_input_format", short_name);
            }
            return (MemorySegment)mh$.invokeExact(short_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static FunctionDescriptor av_probe_input_format$descriptor() {
        return av_probe_input_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MethodHandle av_probe_input_format$handle() {
        return av_probe_input_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MemorySegment av_probe_input_format$address() {
        return av_probe_input_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MemorySegment av_probe_input_format(MemorySegment pd, int is_opened) {
        var mh$ = av_probe_input_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format", pd, is_opened);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_format2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static FunctionDescriptor av_probe_input_format2$descriptor() {
        return av_probe_input_format2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MethodHandle av_probe_input_format2$handle() {
        return av_probe_input_format2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MemorySegment av_probe_input_format2$address() {
        return av_probe_input_format2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MemorySegment av_probe_input_format2(MemorySegment pd, int is_opened, MemorySegment score_max) {
        var mh$ = av_probe_input_format2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format2", pd, is_opened, score_max);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened, score_max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_format3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static FunctionDescriptor av_probe_input_format3$descriptor() {
        return av_probe_input_format3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MethodHandle av_probe_input_format3$handle() {
        return av_probe_input_format3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MemorySegment av_probe_input_format3$address() {
        return av_probe_input_format3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MemorySegment av_probe_input_format3(MemorySegment pd, int is_opened, MemorySegment score_ret) {
        var mh$ = av_probe_input_format3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format3", pd, is_opened, score_ret);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened, score_ret);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_buffer2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_buffer2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static FunctionDescriptor av_probe_input_buffer2$descriptor() {
        return av_probe_input_buffer2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MethodHandle av_probe_input_buffer2$handle() {
        return av_probe_input_buffer2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MemorySegment av_probe_input_buffer2$address() {
        return av_probe_input_buffer2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static int av_probe_input_buffer2(MemorySegment pb, MemorySegment fmt, MemorySegment url, MemorySegment logctx, int offset, int max_probe_size) {
        var mh$ = av_probe_input_buffer2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_buffer2", pb, fmt, url, logctx, offset, max_probe_size);
            }
            return (int)mh$.invokeExact(pb, fmt, url, logctx, offset, max_probe_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static FunctionDescriptor av_probe_input_buffer$descriptor() {
        return av_probe_input_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MethodHandle av_probe_input_buffer$handle() {
        return av_probe_input_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MemorySegment av_probe_input_buffer$address() {
        return av_probe_input_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static int av_probe_input_buffer(MemorySegment pb, MemorySegment fmt, MemorySegment url, MemorySegment logctx, int offset, int max_probe_size) {
        var mh$ = av_probe_input_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_buffer", pb, fmt, url, logctx, offset, max_probe_size);
            }
            return (int)mh$.invokeExact(pb, fmt, url, logctx, offset, max_probe_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_open_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_open_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_open_input$descriptor() {
        return avformat_open_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_open_input$handle() {
        return avformat_open_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_open_input$address() {
        return avformat_open_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static int avformat_open_input(MemorySegment ps, MemorySegment url, MemorySegment fmt, MemorySegment options) {
        var mh$ = avformat_open_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_open_input", ps, url, fmt, options);
            }
            return (int)mh$.invokeExact(ps, url, fmt, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_find_stream_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_find_stream_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_find_stream_info$descriptor() {
        return avformat_find_stream_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_find_stream_info$handle() {
        return avformat_find_stream_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_find_stream_info$address() {
        return avformat_find_stream_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static int avformat_find_stream_info(MemorySegment ic, MemorySegment options) {
        var mh$ = avformat_find_stream_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_find_stream_info", ic, options);
            }
            return (int)mh$.invokeExact(ic, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_program_from_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_program_from_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static FunctionDescriptor av_find_program_from_stream$descriptor() {
        return av_find_program_from_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MethodHandle av_find_program_from_stream$handle() {
        return av_find_program_from_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MemorySegment av_find_program_from_stream$address() {
        return av_find_program_from_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MemorySegment av_find_program_from_stream(MemorySegment ic, MemorySegment last, int s) {
        var mh$ = av_find_program_from_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_program_from_stream", ic, last, s);
            }
            return (MemorySegment)mh$.invokeExact(ic, last, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_program_add_stream_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_program_add_stream_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static FunctionDescriptor av_program_add_stream_index$descriptor() {
        return av_program_add_stream_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static MethodHandle av_program_add_stream_index$handle() {
        return av_program_add_stream_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static MemorySegment av_program_add_stream_index$address() {
        return av_program_add_stream_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static void av_program_add_stream_index(MemorySegment ac, int progid, int idx) {
        var mh$ = av_program_add_stream_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_program_add_stream_index", ac, progid, idx);
            }
            mh$.invokeExact(ac, progid, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_best_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_best_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static FunctionDescriptor av_find_best_stream$descriptor() {
        return av_find_best_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static MethodHandle av_find_best_stream$handle() {
        return av_find_best_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static MemorySegment av_find_best_stream$address() {
        return av_find_best_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static int av_find_best_stream(MemorySegment ic, int type, int wanted_stream_nb, int related_stream, MemorySegment decoder_ret, int flags) {
        var mh$ = av_find_best_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_best_stream", ic, type, wanted_stream_nb, related_stream, decoder_ret, flags);
            }
            return (int)mh$.invokeExact(ic, type, wanted_stream_nb, related_stream, decoder_ret, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_read_frame$descriptor() {
        return av_read_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_read_frame$handle() {
        return av_read_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_read_frame$address() {
        return av_read_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_read_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_read_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_seek_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_seek_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor av_seek_frame$descriptor() {
        return av_seek_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle av_seek_frame$handle() {
        return av_seek_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment av_seek_frame$address() {
        return av_seek_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static int av_seek_frame(MemorySegment s, int stream_index, long timestamp, int flags) {
        var mh$ = av_seek_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_seek_frame", s, stream_index, timestamp, flags);
            }
            return (int)mh$.invokeExact(s, stream_index, timestamp, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_seek_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_seek_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static FunctionDescriptor avformat_seek_file$descriptor() {
        return avformat_seek_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static MethodHandle avformat_seek_file$handle() {
        return avformat_seek_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static MemorySegment avformat_seek_file$address() {
        return avformat_seek_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static int avformat_seek_file(MemorySegment s, int stream_index, long min_ts, long ts, long max_ts, int flags) {
        var mh$ = avformat_seek_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_seek_file", s, stream_index, min_ts, ts, max_ts, flags);
            }
            return (int)mh$.invokeExact(s, stream_index, min_ts, ts, max_ts, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_flush$descriptor() {
        return avformat_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_flush$handle() {
        return avformat_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_flush$address() {
        return avformat_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static int avformat_flush(MemorySegment s) {
        var mh$ = avformat_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_flush", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_play {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_play");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_read_play$descriptor() {
        return av_read_play.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_read_play$handle() {
        return av_read_play.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_read_play$address() {
        return av_read_play.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static int av_read_play(MemorySegment s) {
        var mh$ = av_read_play.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_play", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_read_pause$descriptor() {
        return av_read_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_read_pause$handle() {
        return av_read_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_read_pause$address() {
        return av_read_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static int av_read_pause(MemorySegment s) {
        var mh$ = av_read_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_pause", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_close_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_close_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static FunctionDescriptor avformat_close_input$descriptor() {
        return avformat_close_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static MethodHandle avformat_close_input$handle() {
        return avformat_close_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static MemorySegment avformat_close_input$address() {
        return avformat_close_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static void avformat_close_input(MemorySegment s) {
        var mh$ = avformat_close_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_close_input", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_write_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_write_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_write_header$descriptor() {
        return avformat_write_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_write_header$handle() {
        return avformat_write_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_write_header$address() {
        return avformat_write_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static int avformat_write_header(MemorySegment s, MemorySegment options) {
        var mh$ = avformat_write_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_write_header", s, options);
            }
            return (int)mh$.invokeExact(s, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_init_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_init_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_init_output$descriptor() {
        return avformat_init_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_init_output$handle() {
        return avformat_init_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_init_output$address() {
        return avformat_init_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static int avformat_init_output(MemorySegment s, MemorySegment options) {
        var mh$ = avformat_init_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_init_output", s, options);
            }
            return (int)mh$.invokeExact(s, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_write_frame$descriptor() {
        return av_write_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_write_frame$handle() {
        return av_write_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_write_frame$address() {
        return av_write_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_write_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_write_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_interleaved_write_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_interleaved_write_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_interleaved_write_frame$descriptor() {
        return av_interleaved_write_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_interleaved_write_frame$handle() {
        return av_interleaved_write_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_interleaved_write_frame$address() {
        return av_interleaved_write_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_interleaved_write_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_interleaved_write_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_interleaved_write_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_uncoded_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_uncoded_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_write_uncoded_frame$descriptor() {
        return av_write_uncoded_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_write_uncoded_frame$handle() {
        return av_write_uncoded_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_write_uncoded_frame$address() {
        return av_write_uncoded_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static int av_write_uncoded_frame(MemorySegment s, int stream_index, MemorySegment frame) {
        var mh$ = av_write_uncoded_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_uncoded_frame", s, stream_index, frame);
            }
            return (int)mh$.invokeExact(s, stream_index, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_interleaved_write_uncoded_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_interleaved_write_uncoded_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_interleaved_write_uncoded_frame$descriptor() {
        return av_interleaved_write_uncoded_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_interleaved_write_uncoded_frame$handle() {
        return av_interleaved_write_uncoded_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_interleaved_write_uncoded_frame$address() {
        return av_interleaved_write_uncoded_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static int av_interleaved_write_uncoded_frame(MemorySegment s, int stream_index, MemorySegment frame) {
        var mh$ = av_interleaved_write_uncoded_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_interleaved_write_uncoded_frame", s, stream_index, frame);
            }
            return (int)mh$.invokeExact(s, stream_index, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_uncoded_frame_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_uncoded_frame_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static FunctionDescriptor av_write_uncoded_frame_query$descriptor() {
        return av_write_uncoded_frame_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static MethodHandle av_write_uncoded_frame_query$handle() {
        return av_write_uncoded_frame_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static MemorySegment av_write_uncoded_frame_query$address() {
        return av_write_uncoded_frame_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static int av_write_uncoded_frame_query(MemorySegment s, int stream_index) {
        var mh$ = av_write_uncoded_frame_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_uncoded_frame_query", s, stream_index);
            }
            return (int)mh$.invokeExact(s, stream_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_trailer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_trailer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_write_trailer$descriptor() {
        return av_write_trailer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_write_trailer$handle() {
        return av_write_trailer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_write_trailer$address() {
        return av_write_trailer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static int av_write_trailer(MemorySegment s) {
        var mh$ = av_write_trailer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_trailer", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static FunctionDescriptor av_guess_format$descriptor() {
        return av_guess_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MethodHandle av_guess_format$handle() {
        return av_guess_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MemorySegment av_guess_format$address() {
        return av_guess_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MemorySegment av_guess_format(MemorySegment short_name, MemorySegment filename, MemorySegment mime_type) {
        var mh$ = av_guess_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_format", short_name, filename, mime_type);
            }
            return (MemorySegment)mh$.invokeExact(short_name, filename, mime_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_codec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_codec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static FunctionDescriptor av_guess_codec$descriptor() {
        return av_guess_codec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static MethodHandle av_guess_codec$handle() {
        return av_guess_codec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static MemorySegment av_guess_codec$address() {
        return av_guess_codec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static int av_guess_codec(MemorySegment fmt, MemorySegment short_name, MemorySegment filename, MemorySegment mime_type, int type) {
        var mh$ = av_guess_codec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_codec", fmt, short_name, filename, mime_type, type);
            }
            return (int)mh$.invokeExact(fmt, short_name, filename, mime_type, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_output_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_output_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static FunctionDescriptor av_get_output_timestamp$descriptor() {
        return av_get_output_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static MethodHandle av_get_output_timestamp$handle() {
        return av_get_output_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static MemorySegment av_get_output_timestamp$address() {
        return av_get_output_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static int av_get_output_timestamp(MemorySegment s, int stream, MemorySegment dts, MemorySegment wall) {
        var mh$ = av_get_output_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_output_timestamp", s, stream, dts, wall);
            }
            return (int)mh$.invokeExact(s, stream, dts, wall);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hex_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hex_dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static FunctionDescriptor av_hex_dump$descriptor() {
        return av_hex_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static MethodHandle av_hex_dump$handle() {
        return av_hex_dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static MemorySegment av_hex_dump$address() {
        return av_hex_dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static void av_hex_dump(MemorySegment f, MemorySegment buf, int size) {
        var mh$ = av_hex_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hex_dump", f, buf, size);
            }
            mh$.invokeExact(f, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hex_dump_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hex_dump_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static FunctionDescriptor av_hex_dump_log$descriptor() {
        return av_hex_dump_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static MethodHandle av_hex_dump_log$handle() {
        return av_hex_dump_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static MemorySegment av_hex_dump_log$address() {
        return av_hex_dump_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static void av_hex_dump_log(MemorySegment avcl, int level, MemorySegment buf, int size) {
        var mh$ = av_hex_dump_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hex_dump_log", avcl, level, buf, size);
            }
            mh$.invokeExact(avcl, level, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pkt_dump2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pkt_dump2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_pkt_dump2$descriptor() {
        return av_pkt_dump2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MethodHandle av_pkt_dump2$handle() {
        return av_pkt_dump2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MemorySegment av_pkt_dump2$address() {
        return av_pkt_dump2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static void av_pkt_dump2(MemorySegment f, MemorySegment pkt, int dump_payload, MemorySegment st) {
        var mh$ = av_pkt_dump2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pkt_dump2", f, pkt, dump_payload, st);
            }
            mh$.invokeExact(f, pkt, dump_payload, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pkt_dump_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pkt_dump_log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_pkt_dump_log2$descriptor() {
        return av_pkt_dump_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MethodHandle av_pkt_dump_log2$handle() {
        return av_pkt_dump_log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MemorySegment av_pkt_dump_log2$address() {
        return av_pkt_dump_log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static void av_pkt_dump_log2(MemorySegment avcl, int level, MemorySegment pkt, int dump_payload, MemorySegment st) {
        var mh$ = av_pkt_dump_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pkt_dump_log2", avcl, level, pkt, dump_payload, st);
            }
            mh$.invokeExact(avcl, level, pkt, dump_payload, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static FunctionDescriptor av_codec_get_id$descriptor() {
        return av_codec_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static MethodHandle av_codec_get_id$handle() {
        return av_codec_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static MemorySegment av_codec_get_id$address() {
        return av_codec_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static int av_codec_get_id(MemorySegment tags, int tag) {
        var mh$ = av_codec_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_id", tags, tag);
            }
            return (int)mh$.invokeExact(tags, tag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_get_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor av_codec_get_tag$descriptor() {
        return av_codec_get_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static MethodHandle av_codec_get_tag$handle() {
        return av_codec_get_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static MemorySegment av_codec_get_tag$address() {
        return av_codec_get_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static int av_codec_get_tag(MemorySegment tags, int id) {
        var mh$ = av_codec_get_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_tag", tags, id);
            }
            return (int)mh$.invokeExact(tags, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_tag2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_get_tag2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static FunctionDescriptor av_codec_get_tag2$descriptor() {
        return av_codec_get_tag2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static MethodHandle av_codec_get_tag2$handle() {
        return av_codec_get_tag2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static MemorySegment av_codec_get_tag2$address() {
        return av_codec_get_tag2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static int av_codec_get_tag2(MemorySegment tags, int id, MemorySegment tag) {
        var mh$ = av_codec_get_tag2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_tag2", tags, id, tag);
            }
            return (int)mh$.invokeExact(tags, id, tag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_default_stream_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_default_stream_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_find_default_stream_index$descriptor() {
        return av_find_default_stream_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_find_default_stream_index$handle() {
        return av_find_default_stream_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_find_default_stream_index$address() {
        return av_find_default_stream_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static int av_find_default_stream_index(MemorySegment s) {
        var mh$ = av_find_default_stream_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_default_stream_index", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_index_search_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_index_search_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor av_index_search_timestamp$descriptor() {
        return av_index_search_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle av_index_search_timestamp$handle() {
        return av_index_search_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment av_index_search_timestamp$address() {
        return av_index_search_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static int av_index_search_timestamp(MemorySegment st, long timestamp, int flags) {
        var mh$ = av_index_search_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_index_search_timestamp", st, timestamp, flags);
            }
            return (int)mh$.invokeExact(st, timestamp, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entries_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_index_get_entries_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entries_count$descriptor() {
        return avformat_index_get_entries_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static MethodHandle avformat_index_get_entries_count$handle() {
        return avformat_index_get_entries_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static MemorySegment avformat_index_get_entries_count$address() {
        return avformat_index_get_entries_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static int avformat_index_get_entries_count(MemorySegment st) {
        var mh$ = avformat_index_get_entries_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entries_count", st);
            }
            return (int)mh$.invokeExact(st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_index_get_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entry$descriptor() {
        return avformat_index_get_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MethodHandle avformat_index_get_entry$handle() {
        return avformat_index_get_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MemorySegment avformat_index_get_entry$address() {
        return avformat_index_get_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MemorySegment avformat_index_get_entry(MemorySegment st, int idx) {
        var mh$ = avformat_index_get_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entry", st, idx);
            }
            return (MemorySegment)mh$.invokeExact(st, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entry_from_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_index_get_entry_from_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entry_from_timestamp$descriptor() {
        return avformat_index_get_entry_from_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MethodHandle avformat_index_get_entry_from_timestamp$handle() {
        return avformat_index_get_entry_from_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MemorySegment avformat_index_get_entry_from_timestamp$address() {
        return avformat_index_get_entry_from_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MemorySegment avformat_index_get_entry_from_timestamp(MemorySegment st, long wanted_timestamp, int flags) {
        var mh$ = avformat_index_get_entry_from_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entry_from_timestamp", st, wanted_timestamp, flags);
            }
            return (MemorySegment)mh$.invokeExact(st, wanted_timestamp, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_index_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_add_index_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static FunctionDescriptor av_add_index_entry$descriptor() {
        return av_add_index_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static MethodHandle av_add_index_entry$handle() {
        return av_add_index_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static MemorySegment av_add_index_entry$address() {
        return av_add_index_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static int av_add_index_entry(MemorySegment st, long pos, long timestamp, int size, int distance, int flags) {
        var mh$ = av_add_index_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_index_entry", st, pos, timestamp, size, distance, flags);
            }
            return (int)mh$.invokeExact(st, pos, timestamp, size, distance, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_url_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_url_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static FunctionDescriptor av_url_split$descriptor() {
        return av_url_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static MethodHandle av_url_split$handle() {
        return av_url_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static MemorySegment av_url_split$address() {
        return av_url_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static void av_url_split(MemorySegment proto, int proto_size, MemorySegment authorization, int authorization_size, MemorySegment hostname, int hostname_size, MemorySegment port_ptr, MemorySegment path, int path_size, MemorySegment url) {
        var mh$ = av_url_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_url_split", proto, proto_size, authorization, authorization_size, hostname, hostname_size, port_ptr, path, path_size, url);
            }
            mh$.invokeExact(proto, proto_size, authorization, authorization_size, hostname, hostname_size, port_ptr, path, path_size, url);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dump_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dump_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static FunctionDescriptor av_dump_format$descriptor() {
        return av_dump_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static MethodHandle av_dump_format$handle() {
        return av_dump_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static MemorySegment av_dump_format$address() {
        return av_dump_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static void av_dump_format(MemorySegment ic, int index, MemorySegment url, int is_output) {
        var mh$ = av_dump_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dump_format", ic, index, url, is_output);
            }
            mh$.invokeExact(ic, index, url, is_output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_frame_filename2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_frame_filename2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static FunctionDescriptor av_get_frame_filename2$descriptor() {
        return av_get_frame_filename2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static MethodHandle av_get_frame_filename2$handle() {
        return av_get_frame_filename2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static MemorySegment av_get_frame_filename2$address() {
        return av_get_frame_filename2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static int av_get_frame_filename2(MemorySegment buf, int buf_size, MemorySegment path, int number, int flags) {
        var mh$ = av_get_frame_filename2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_frame_filename2", buf, buf_size, path, number, flags);
            }
            return (int)mh$.invokeExact(buf, buf_size, path, number, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_frame_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_frame_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static FunctionDescriptor av_get_frame_filename$descriptor() {
        return av_get_frame_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static MethodHandle av_get_frame_filename$handle() {
        return av_get_frame_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static MemorySegment av_get_frame_filename$address() {
        return av_get_frame_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static int av_get_frame_filename(MemorySegment buf, int buf_size, MemorySegment path, int number) {
        var mh$ = av_get_frame_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_frame_filename", buf, buf_size, path, number);
            }
            return (int)mh$.invokeExact(buf, buf_size, path, number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_filename_number_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_filename_number_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static FunctionDescriptor av_filename_number_test$descriptor() {
        return av_filename_number_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static MethodHandle av_filename_number_test$handle() {
        return av_filename_number_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static MemorySegment av_filename_number_test$address() {
        return av_filename_number_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static int av_filename_number_test(MemorySegment filename) {
        var mh$ = av_filename_number_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_filename_number_test", filename);
            }
            return (int)mh$.invokeExact(filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sdp_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_sdp_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static FunctionDescriptor av_sdp_create$descriptor() {
        return av_sdp_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static MethodHandle av_sdp_create$handle() {
        return av_sdp_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static MemorySegment av_sdp_create$address() {
        return av_sdp_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static int av_sdp_create(MemorySegment ac, int n_files, MemorySegment buf, int size) {
        var mh$ = av_sdp_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sdp_create", ac, n_files, buf, size);
            }
            return (int)mh$.invokeExact(ac, n_files, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_match_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_match_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static FunctionDescriptor av_match_ext$descriptor() {
        return av_match_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static MethodHandle av_match_ext$handle() {
        return av_match_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static MemorySegment av_match_ext$address() {
        return av_match_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static int av_match_ext(MemorySegment filename, MemorySegment extensions) {
        var mh$ = av_match_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_match_ext", filename, extensions);
            }
            return (int)mh$.invokeExact(filename, extensions);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_query_codec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_query_codec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static FunctionDescriptor avformat_query_codec$descriptor() {
        return avformat_query_codec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static MethodHandle avformat_query_codec$handle() {
        return avformat_query_codec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static MemorySegment avformat_query_codec$address() {
        return avformat_query_codec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static int avformat_query_codec(MemorySegment ofmt, int codec_id, int std_compliance) {
        var mh$ = avformat_query_codec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_query_codec", ofmt, codec_id, std_compliance);
            }
            return (int)mh$.invokeExact(ofmt, codec_id, std_compliance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_riff_video_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_riff_video_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_riff_video_tags$descriptor() {
        return avformat_get_riff_video_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MethodHandle avformat_get_riff_video_tags$handle() {
        return avformat_get_riff_video_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_video_tags$address() {
        return avformat_get_riff_video_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_video_tags() {
        var mh$ = avformat_get_riff_video_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_riff_video_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_riff_audio_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_riff_audio_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_riff_audio_tags$descriptor() {
        return avformat_get_riff_audio_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MethodHandle avformat_get_riff_audio_tags$handle() {
        return avformat_get_riff_audio_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_audio_tags$address() {
        return avformat_get_riff_audio_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_audio_tags() {
        var mh$ = avformat_get_riff_audio_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_riff_audio_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_mov_video_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_mov_video_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_mov_video_tags$descriptor() {
        return avformat_get_mov_video_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MethodHandle avformat_get_mov_video_tags$handle() {
        return avformat_get_mov_video_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_video_tags$address() {
        return avformat_get_mov_video_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_video_tags() {
        var mh$ = avformat_get_mov_video_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_mov_video_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_mov_audio_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_mov_audio_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_mov_audio_tags$descriptor() {
        return avformat_get_mov_audio_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MethodHandle avformat_get_mov_audio_tags$handle() {
        return avformat_get_mov_audio_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_audio_tags$address() {
        return avformat_get_mov_audio_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_audio_tags() {
        var mh$ = avformat_get_mov_audio_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_mov_audio_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_sample_aspect_ratio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_sample_aspect_ratio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_guess_sample_aspect_ratio$descriptor() {
        return av_guess_sample_aspect_ratio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_guess_sample_aspect_ratio$handle() {
        return av_guess_sample_aspect_ratio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_sample_aspect_ratio$address() {
        return av_guess_sample_aspect_ratio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_sample_aspect_ratio(SegmentAllocator allocator, MemorySegment format, MemorySegment stream, MemorySegment frame) {
        var mh$ = av_guess_sample_aspect_ratio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_sample_aspect_ratio", allocator, format, stream, frame);
            }
            return (MemorySegment)mh$.invokeExact(allocator, format, stream, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_frame_rate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_frame_rate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_guess_frame_rate$descriptor() {
        return av_guess_frame_rate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_guess_frame_rate$handle() {
        return av_guess_frame_rate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_frame_rate$address() {
        return av_guess_frame_rate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_frame_rate(SegmentAllocator allocator, MemorySegment ctx, MemorySegment stream, MemorySegment frame) {
        var mh$ = av_guess_frame_rate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_frame_rate", allocator, ctx, stream, frame);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx, stream, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_match_stream_specifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_match_stream_specifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static FunctionDescriptor avformat_match_stream_specifier$descriptor() {
        return avformat_match_stream_specifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static MethodHandle avformat_match_stream_specifier$handle() {
        return avformat_match_stream_specifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static MemorySegment avformat_match_stream_specifier$address() {
        return avformat_match_stream_specifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static int avformat_match_stream_specifier(MemorySegment s, MemorySegment st, MemorySegment spec) {
        var mh$ = avformat_match_stream_specifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_match_stream_specifier", s, st, spec);
            }
            return (int)mh$.invokeExact(s, st, spec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_queue_attached_pictures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_queue_attached_pictures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_queue_attached_pictures$descriptor() {
        return avformat_queue_attached_pictures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_queue_attached_pictures$handle() {
        return avformat_queue_attached_pictures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_queue_attached_pictures$address() {
        return avformat_queue_attached_pictures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static int avformat_queue_attached_pictures(MemorySegment s) {
        var mh$ = avformat_queue_attached_pictures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_queue_attached_pictures", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_transfer_internal_stream_timing_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_transfer_internal_stream_timing_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static FunctionDescriptor avformat_transfer_internal_stream_timing_info$descriptor() {
        return avformat_transfer_internal_stream_timing_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static MethodHandle avformat_transfer_internal_stream_timing_info$handle() {
        return avformat_transfer_internal_stream_timing_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static MemorySegment avformat_transfer_internal_stream_timing_info$address() {
        return avformat_transfer_internal_stream_timing_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static int avformat_transfer_internal_stream_timing_info(MemorySegment ofmt, MemorySegment ost, MemorySegment ist, int copy_tb) {
        var mh$ = avformat_transfer_internal_stream_timing_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_transfer_internal_stream_timing_info", ofmt, ost, ist, copy_tb);
            }
            return (int)mh$.invokeExact(ofmt, ost, ist, copy_tb);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_codec_timebase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_get_codec_timebase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_stream_get_codec_timebase$descriptor() {
        return av_stream_get_codec_timebase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MethodHandle av_stream_get_codec_timebase$handle() {
        return av_stream_get_codec_timebase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_codec_timebase$address() {
        return av_stream_get_codec_timebase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_codec_timebase(SegmentAllocator allocator, MemorySegment st) {
        var mh$ = av_stream_get_codec_timebase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_codec_timebase", allocator, st);
            }
            return (MemorySegment)mh$.invokeExact(allocator, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_max_pixsteps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_max_pixsteps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static FunctionDescriptor av_image_fill_max_pixsteps$descriptor() {
        return av_image_fill_max_pixsteps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MethodHandle av_image_fill_max_pixsteps$handle() {
        return av_image_fill_max_pixsteps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MemorySegment av_image_fill_max_pixsteps$address() {
        return av_image_fill_max_pixsteps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static void av_image_fill_max_pixsteps(MemorySegment max_pixsteps, MemorySegment max_pixstep_comps, MemorySegment pixdesc) {
        var mh$ = av_image_fill_max_pixsteps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_max_pixsteps", max_pixsteps, max_pixstep_comps, pixdesc);
            }
            mh$.invokeExact(max_pixsteps, max_pixstep_comps, pixdesc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_get_linesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_get_linesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static FunctionDescriptor av_image_get_linesize$descriptor() {
        return av_image_get_linesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static MethodHandle av_image_get_linesize$handle() {
        return av_image_get_linesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static MemorySegment av_image_get_linesize$address() {
        return av_image_get_linesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static int av_image_get_linesize(int pix_fmt, int width, int plane) {
        var mh$ = av_image_get_linesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_get_linesize", pix_fmt, width, plane);
            }
            return (int)mh$.invokeExact(pix_fmt, width, plane);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_linesizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_linesizes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static FunctionDescriptor av_image_fill_linesizes$descriptor() {
        return av_image_fill_linesizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static MethodHandle av_image_fill_linesizes$handle() {
        return av_image_fill_linesizes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static MemorySegment av_image_fill_linesizes$address() {
        return av_image_fill_linesizes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static int av_image_fill_linesizes(MemorySegment linesizes, int pix_fmt, int width) {
        var mh$ = av_image_fill_linesizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_linesizes", linesizes, pix_fmt, width);
            }
            return (int)mh$.invokeExact(linesizes, pix_fmt, width);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_plane_sizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_plane_sizes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static FunctionDescriptor av_image_fill_plane_sizes$descriptor() {
        return av_image_fill_plane_sizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static MethodHandle av_image_fill_plane_sizes$handle() {
        return av_image_fill_plane_sizes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static MemorySegment av_image_fill_plane_sizes$address() {
        return av_image_fill_plane_sizes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static int av_image_fill_plane_sizes(MemorySegment size, int pix_fmt, int height, MemorySegment linesizes) {
        var mh$ = av_image_fill_plane_sizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_plane_sizes", size, pix_fmt, height, linesizes);
            }
            return (int)mh$.invokeExact(size, pix_fmt, height, linesizes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static FunctionDescriptor av_image_fill_pointers$descriptor() {
        return av_image_fill_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static MethodHandle av_image_fill_pointers$handle() {
        return av_image_fill_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static MemorySegment av_image_fill_pointers$address() {
        return av_image_fill_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static int av_image_fill_pointers(MemorySegment data, int pix_fmt, int height, MemorySegment ptr, MemorySegment linesizes) {
        var mh$ = av_image_fill_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_pointers", data, pix_fmt, height, ptr, linesizes);
            }
            return (int)mh$.invokeExact(data, pix_fmt, height, ptr, linesizes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_image_alloc$descriptor() {
        return av_image_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static MethodHandle av_image_alloc$handle() {
        return av_image_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static MemorySegment av_image_alloc$address() {
        return av_image_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static int av_image_alloc(MemorySegment pointers, MemorySegment linesizes, int w, int h, int pix_fmt, int align) {
        var mh$ = av_image_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_alloc", pointers, linesizes, w, h, pix_fmt, align);
            }
            return (int)mh$.invokeExact(pointers, linesizes, w, h, pix_fmt, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_plane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_plane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_plane$descriptor() {
        return av_image_copy_plane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static MethodHandle av_image_copy_plane$handle() {
        return av_image_copy_plane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static MemorySegment av_image_copy_plane$address() {
        return av_image_copy_plane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static void av_image_copy_plane(MemorySegment dst, int dst_linesize, MemorySegment src, int src_linesize, int bytewidth, int height) {
        var mh$ = av_image_copy_plane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_plane", dst, dst_linesize, src, src_linesize, bytewidth, height);
            }
            mh$.invokeExact(dst, dst_linesize, src, src_linesize, bytewidth, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_plane_uc_from {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_plane_uc_from");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_plane_uc_from$descriptor() {
        return av_image_copy_plane_uc_from.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static MethodHandle av_image_copy_plane_uc_from$handle() {
        return av_image_copy_plane_uc_from.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static MemorySegment av_image_copy_plane_uc_from$address() {
        return av_image_copy_plane_uc_from.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static void av_image_copy_plane_uc_from(MemorySegment dst, long dst_linesize, MemorySegment src, long src_linesize, long bytewidth, int height) {
        var mh$ = av_image_copy_plane_uc_from.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_plane_uc_from", dst, dst_linesize, src, src_linesize, bytewidth, height);
            }
            mh$.invokeExact(dst, dst_linesize, src, src_linesize, bytewidth, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy$descriptor() {
        return av_image_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MethodHandle av_image_copy$handle() {
        return av_image_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MemorySegment av_image_copy$address() {
        return av_image_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static void av_image_copy(MemorySegment dst_data, MemorySegment dst_linesizes, MemorySegment src_data, MemorySegment src_linesizes, int pix_fmt, int width, int height) {
        var mh$ = av_image_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy", dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
            }
            mh$.invokeExact(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_uc_from {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_uc_from");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_uc_from$descriptor() {
        return av_image_copy_uc_from.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MethodHandle av_image_copy_uc_from$handle() {
        return av_image_copy_uc_from.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MemorySegment av_image_copy_uc_from$address() {
        return av_image_copy_uc_from.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static void av_image_copy_uc_from(MemorySegment dst_data, MemorySegment dst_linesizes, MemorySegment src_data, MemorySegment src_linesizes, int pix_fmt, int width, int height) {
        var mh$ = av_image_copy_uc_from.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_uc_from", dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
            }
            mh$.invokeExact(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_arrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_arrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_fill_arrays$descriptor() {
        return av_image_fill_arrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_fill_arrays$handle() {
        return av_image_fill_arrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_fill_arrays$address() {
        return av_image_fill_arrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_fill_arrays(MemorySegment dst_data, MemorySegment dst_linesize, MemorySegment src, int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_fill_arrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_arrays", dst_data, dst_linesize, src, pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, src, pix_fmt, width, height, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_get_buffer_size$descriptor() {
        return av_image_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_get_buffer_size$handle() {
        return av_image_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_get_buffer_size$address() {
        return av_image_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_get_buffer_size(int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_get_buffer_size", pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(pix_fmt, width, height, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_copy_to_buffer$descriptor() {
        return av_image_copy_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_copy_to_buffer$handle() {
        return av_image_copy_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_copy_to_buffer$address() {
        return av_image_copy_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_copy_to_buffer(MemorySegment dst, int dst_size, MemorySegment src_data, MemorySegment src_linesize, int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_copy_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_to_buffer", dst, dst_size, src_data, src_linesize, pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(dst, dst_size, src_data, src_linesize, pix_fmt, width, height, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_check_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static FunctionDescriptor av_image_check_size$descriptor() {
        return av_image_check_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static MethodHandle av_image_check_size$handle() {
        return av_image_check_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static MemorySegment av_image_check_size$address() {
        return av_image_check_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static int av_image_check_size(int w, int h, int log_offset, MemorySegment log_ctx) {
        var mh$ = av_image_check_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_size", w, h, log_offset, log_ctx);
            }
            return (int)mh$.invokeExact(w, h, log_offset, log_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_size2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_check_size2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static FunctionDescriptor av_image_check_size2$descriptor() {
        return av_image_check_size2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static MethodHandle av_image_check_size2$handle() {
        return av_image_check_size2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static MemorySegment av_image_check_size2$address() {
        return av_image_check_size2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static int av_image_check_size2(int w, int h, long max_pixels, int pix_fmt, int log_offset, MemorySegment log_ctx) {
        var mh$ = av_image_check_size2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_size2", w, h, max_pixels, pix_fmt, log_offset, log_ctx);
            }
            return (int)mh$.invokeExact(w, h, max_pixels, pix_fmt, log_offset, log_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_sar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_check_sar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static FunctionDescriptor av_image_check_sar$descriptor() {
        return av_image_check_sar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static MethodHandle av_image_check_sar$handle() {
        return av_image_check_sar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static MemorySegment av_image_check_sar$address() {
        return av_image_check_sar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static int av_image_check_sar(int w, int h, MemorySegment sar) {
        var mh$ = av_image_check_sar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_sar", w, h, sar);
            }
            return (int)mh$.invokeExact(w, h, sar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_black {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_black");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_fill_black$descriptor() {
        return av_image_fill_black.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static MethodHandle av_image_fill_black$handle() {
        return av_image_fill_black.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static MemorySegment av_image_fill_black$address() {
        return av_image_fill_black.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static int av_image_fill_black(MemorySegment dst_data, MemorySegment dst_linesize, int pix_fmt, int range, int width, int height) {
        var mh$ = av_image_fill_black.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_black", dst_data, dst_linesize, pix_fmt, range, width, height);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, pix_fmt, range, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_color {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_color");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static FunctionDescriptor av_image_fill_color$descriptor() {
        return av_image_fill_color.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static MethodHandle av_image_fill_color$handle() {
        return av_image_fill_color.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static MemorySegment av_image_fill_color$address() {
        return av_image_fill_color.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static int av_image_fill_color(MemorySegment dst_data, MemorySegment dst_linesize, int pix_fmt, MemorySegment color, int width, int height, int flags) {
        var mh$ = av_image_fill_color.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_color", dst_data, dst_linesize, pix_fmt, color, width, height, flags);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, pix_fmt, color, width, height, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swscale_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static FunctionDescriptor swscale_version$descriptor() {
        return swscale_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static MethodHandle swscale_version$handle() {
        return swscale_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static MemorySegment swscale_version$address() {
        return swscale_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static int swscale_version() {
        var mh$ = swscale_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swscale_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static FunctionDescriptor swscale_configuration$descriptor() {
        return swscale_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MethodHandle swscale_configuration$handle() {
        return swscale_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MemorySegment swscale_configuration$address() {
        return swscale_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MemorySegment swscale_configuration() {
        var mh$ = swscale_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swscale_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static FunctionDescriptor swscale_license$descriptor() {
        return swscale_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MethodHandle swscale_license$handle() {
        return swscale_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MemorySegment swscale_license$address() {
        return swscale_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MemorySegment swscale_license() {
        var mh$ = swscale_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static FunctionDescriptor sws_get_class$descriptor() {
        return sws_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MethodHandle sws_get_class$handle() {
        return sws_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MemorySegment sws_get_class$address() {
        return sws_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MemorySegment sws_get_class() {
        var mh$ = sws_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SWS_FAST_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_FAST_BILINEAR = 1
     * }
     */
    public static int SWS_FAST_BILINEAR() {
        return SWS_FAST_BILINEAR;
    }
    private static final int SWS_BILINEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BILINEAR = 2
     * }
     */
    public static int SWS_BILINEAR() {
        return SWS_BILINEAR;
    }
    private static final int SWS_BICUBIC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BICUBIC = 4
     * }
     */
    public static int SWS_BICUBIC() {
        return SWS_BICUBIC;
    }
    private static final int SWS_X = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_X = 8
     * }
     */
    public static int SWS_X() {
        return SWS_X;
    }
    private static final int SWS_POINT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_POINT = 16
     * }
     */
    public static int SWS_POINT() {
        return SWS_POINT;
    }
    private static final int SWS_AREA = (int)32L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_AREA = 32
     * }
     */
    public static int SWS_AREA() {
        return SWS_AREA;
    }
    private static final int SWS_BICUBLIN = (int)64L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BICUBLIN = 64
     * }
     */
    public static int SWS_BICUBLIN() {
        return SWS_BICUBLIN;
    }
    private static final int SWS_GAUSS = (int)128L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_GAUSS = 128
     * }
     */
    public static int SWS_GAUSS() {
        return SWS_GAUSS;
    }
    private static final int SWS_SINC = (int)256L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_SINC = 256
     * }
     */
    public static int SWS_SINC() {
        return SWS_SINC;
    }
    private static final int SWS_LANCZOS = (int)512L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_LANCZOS = 512
     * }
     */
    public static int SWS_LANCZOS() {
        return SWS_LANCZOS;
    }
    private static final int SWS_SPLINE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_SPLINE = 1024
     * }
     */
    public static int SWS_SPLINE() {
        return SWS_SPLINE;
    }
    private static final int SWS_PRINT_INFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_PRINT_INFO = 4096
     * }
     */
    public static int SWS_PRINT_INFO() {
        return SWS_PRINT_INFO;
    }
    private static final int SWS_FULL_CHR_H_INT = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_FULL_CHR_H_INT = 8192
     * }
     */
    public static int SWS_FULL_CHR_H_INT() {
        return SWS_FULL_CHR_H_INT;
    }
    private static final int SWS_FULL_CHR_H_INP = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_FULL_CHR_H_INP = 16384
     * }
     */
    public static int SWS_FULL_CHR_H_INP() {
        return SWS_FULL_CHR_H_INP;
    }
    private static final int SWS_ACCURATE_RND = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_ACCURATE_RND = 262144
     * }
     */
    public static int SWS_ACCURATE_RND() {
        return SWS_ACCURATE_RND;
    }
    private static final int SWS_BITEXACT = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BITEXACT = 524288
     * }
     */
    public static int SWS_BITEXACT() {
        return SWS_BITEXACT;
    }
    private static final int SWS_DIRECT_BGR = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_DIRECT_BGR = 32768
     * }
     */
    public static int SWS_DIRECT_BGR() {
        return SWS_DIRECT_BGR;
    }
    private static final int SWS_ERROR_DIFFUSION = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_ERROR_DIFFUSION = 8388608
     * }
     */
    public static int SWS_ERROR_DIFFUSION() {
        return SWS_ERROR_DIFFUSION;
    }

    private static class sws_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static FunctionDescriptor sws_alloc_context$descriptor() {
        return sws_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static MethodHandle sws_alloc_context$handle() {
        return sws_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static MemorySegment sws_alloc_context$address() {
        return sws_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static MemorySegment sws_alloc_context() {
        var mh$ = sws_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_alloc_context");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scale_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_scale_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_scale_frame$descriptor() {
        return sws_scale_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_scale_frame$handle() {
        return sws_scale_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_scale_frame$address() {
        return sws_scale_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_scale_frame(MemorySegment c, MemorySegment dst, MemorySegment src) {
        var mh$ = sws_scale_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scale_frame", c, dst, src);
            }
            return (int)mh$.invokeExact(c, dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getCoefficients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getCoefficients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static FunctionDescriptor sws_getCoefficients$descriptor() {
        return sws_getCoefficients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MethodHandle sws_getCoefficients$handle() {
        return sws_getCoefficients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MemorySegment sws_getCoefficients$address() {
        return sws_getCoefficients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MemorySegment sws_getCoefficients(int colorspace) {
        var mh$ = sws_getCoefficients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getCoefficients", colorspace);
            }
            return (MemorySegment)mh$.invokeExact(colorspace);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_isSupportedInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedInput$descriptor() {
        return sws_isSupportedInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedInput$handle() {
        return sws_isSupportedInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedInput$address() {
        return sws_isSupportedInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedInput(int pix_fmt) {
        var mh$ = sws_isSupportedInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedInput", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedOutput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_isSupportedOutput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedOutput$descriptor() {
        return sws_isSupportedOutput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedOutput$handle() {
        return sws_isSupportedOutput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedOutput$address() {
        return sws_isSupportedOutput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedOutput(int pix_fmt) {
        var mh$ = sws_isSupportedOutput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedOutput", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedEndiannessConversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_isSupportedEndiannessConversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedEndiannessConversion$descriptor() {
        return sws_isSupportedEndiannessConversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedEndiannessConversion$handle() {
        return sws_isSupportedEndiannessConversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedEndiannessConversion$address() {
        return sws_isSupportedEndiannessConversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedEndiannessConversion(int pix_fmt) {
        var mh$ = sws_isSupportedEndiannessConversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedEndiannessConversion", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_init_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_init_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static FunctionDescriptor sws_init_context$descriptor() {
        return sws_init_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static MethodHandle sws_init_context$handle() {
        return sws_init_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static MemorySegment sws_init_context$address() {
        return sws_init_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static int sws_init_context(MemorySegment sws_context, MemorySegment srcFilter, MemorySegment dstFilter) {
        var mh$ = sws_init_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_init_context", sws_context, srcFilter, dstFilter);
            }
            return (int)mh$.invokeExact(sws_context, srcFilter, dstFilter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_freeContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static FunctionDescriptor sws_freeContext$descriptor() {
        return sws_freeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static MethodHandle sws_freeContext$handle() {
        return sws_freeContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static MemorySegment sws_freeContext$address() {
        return sws_freeContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static void sws_freeContext(MemorySegment swsContext) {
        var mh$ = sws_freeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeContext", swsContext);
            }
            mh$.invokeExact(swsContext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static FunctionDescriptor sws_getContext$descriptor() {
        return sws_getContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MethodHandle sws_getContext$handle() {
        return sws_getContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getContext$address() {
        return sws_getContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, MemorySegment srcFilter, MemorySegment dstFilter, MemorySegment param) {
        var mh$ = sws_getContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getContext", srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
            }
            return (MemorySegment)mh$.invokeExact(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static FunctionDescriptor sws_scale$descriptor() {
        return sws_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static MethodHandle sws_scale$handle() {
        return sws_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static MemorySegment sws_scale$address() {
        return sws_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static int sws_scale(MemorySegment c, MemorySegment srcSlice, MemorySegment srcStride, int srcSliceY, int srcSliceH, MemorySegment dst, MemorySegment dstStride) {
        var mh$ = sws_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scale", c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride);
            }
            return (int)mh$.invokeExact(c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_frame_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_frame_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_frame_start$descriptor() {
        return sws_frame_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_frame_start$handle() {
        return sws_frame_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_frame_start$address() {
        return sws_frame_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_frame_start(MemorySegment c, MemorySegment dst, MemorySegment src) {
        var mh$ = sws_frame_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_frame_start", c, dst, src);
            }
            return (int)mh$.invokeExact(c, dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_frame_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_frame_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static FunctionDescriptor sws_frame_end$descriptor() {
        return sws_frame_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static MethodHandle sws_frame_end$handle() {
        return sws_frame_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static MemorySegment sws_frame_end$address() {
        return sws_frame_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static void sws_frame_end(MemorySegment c) {
        var mh$ = sws_frame_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_frame_end", c);
            }
            mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_send_slice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_send_slice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static FunctionDescriptor sws_send_slice$descriptor() {
        return sws_send_slice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MethodHandle sws_send_slice$handle() {
        return sws_send_slice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MemorySegment sws_send_slice$address() {
        return sws_send_slice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static int sws_send_slice(MemorySegment c, int slice_start, int slice_height) {
        var mh$ = sws_send_slice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_send_slice", c, slice_start, slice_height);
            }
            return (int)mh$.invokeExact(c, slice_start, slice_height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_receive_slice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_receive_slice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static FunctionDescriptor sws_receive_slice$descriptor() {
        return sws_receive_slice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MethodHandle sws_receive_slice$handle() {
        return sws_receive_slice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MemorySegment sws_receive_slice$address() {
        return sws_receive_slice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static int sws_receive_slice(MemorySegment c, int slice_start, int slice_height) {
        var mh$ = sws_receive_slice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_receive_slice", c, slice_start, slice_height);
            }
            return (int)mh$.invokeExact(c, slice_start, slice_height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_receive_slice_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_receive_slice_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static FunctionDescriptor sws_receive_slice_alignment$descriptor() {
        return sws_receive_slice_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static MethodHandle sws_receive_slice_alignment$handle() {
        return sws_receive_slice_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static MemorySegment sws_receive_slice_alignment$address() {
        return sws_receive_slice_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static int sws_receive_slice_alignment(MemorySegment c) {
        var mh$ = sws_receive_slice_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_receive_slice_alignment", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_setColorspaceDetails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_setColorspaceDetails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static FunctionDescriptor sws_setColorspaceDetails$descriptor() {
        return sws_setColorspaceDetails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static MethodHandle sws_setColorspaceDetails$handle() {
        return sws_setColorspaceDetails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static MemorySegment sws_setColorspaceDetails$address() {
        return sws_setColorspaceDetails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static int sws_setColorspaceDetails(MemorySegment c, MemorySegment inv_table, int srcRange, MemorySegment table, int dstRange, int brightness, int contrast, int saturation) {
        var mh$ = sws_setColorspaceDetails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_setColorspaceDetails", c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
            }
            return (int)mh$.invokeExact(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getColorspaceDetails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getColorspaceDetails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static FunctionDescriptor sws_getColorspaceDetails$descriptor() {
        return sws_getColorspaceDetails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static MethodHandle sws_getColorspaceDetails$handle() {
        return sws_getColorspaceDetails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static MemorySegment sws_getColorspaceDetails$address() {
        return sws_getColorspaceDetails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static int sws_getColorspaceDetails(MemorySegment c, MemorySegment inv_table, MemorySegment srcRange, MemorySegment table, MemorySegment dstRange, MemorySegment brightness, MemorySegment contrast, MemorySegment saturation) {
        var mh$ = sws_getColorspaceDetails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getColorspaceDetails", c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
            }
            return (int)mh$.invokeExact(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_allocVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_allocVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static FunctionDescriptor sws_allocVec$descriptor() {
        return sws_allocVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MethodHandle sws_allocVec$handle() {
        return sws_allocVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MemorySegment sws_allocVec$address() {
        return sws_allocVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MemorySegment sws_allocVec(int length) {
        var mh$ = sws_allocVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_allocVec", length);
            }
            return (MemorySegment)mh$.invokeExact(length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getGaussianVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getGaussianVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static FunctionDescriptor sws_getGaussianVec$descriptor() {
        return sws_getGaussianVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MethodHandle sws_getGaussianVec$handle() {
        return sws_getGaussianVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MemorySegment sws_getGaussianVec$address() {
        return sws_getGaussianVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MemorySegment sws_getGaussianVec(double variance, double quality) {
        var mh$ = sws_getGaussianVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getGaussianVec", variance, quality);
            }
            return (MemorySegment)mh$.invokeExact(variance, quality);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scaleVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_scaleVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static FunctionDescriptor sws_scaleVec$descriptor() {
        return sws_scaleVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static MethodHandle sws_scaleVec$handle() {
        return sws_scaleVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static MemorySegment sws_scaleVec$address() {
        return sws_scaleVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static void sws_scaleVec(MemorySegment a, double scalar) {
        var mh$ = sws_scaleVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scaleVec", a, scalar);
            }
            mh$.invokeExact(a, scalar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_normalizeVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_normalizeVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static FunctionDescriptor sws_normalizeVec$descriptor() {
        return sws_normalizeVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static MethodHandle sws_normalizeVec$handle() {
        return sws_normalizeVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static MemorySegment sws_normalizeVec$address() {
        return sws_normalizeVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static void sws_normalizeVec(MemorySegment a, double height) {
        var mh$ = sws_normalizeVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_normalizeVec", a, height);
            }
            mh$.invokeExact(a, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_freeVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static FunctionDescriptor sws_freeVec$descriptor() {
        return sws_freeVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static MethodHandle sws_freeVec$handle() {
        return sws_freeVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static MemorySegment sws_freeVec$address() {
        return sws_freeVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static void sws_freeVec(MemorySegment a) {
        var mh$ = sws_freeVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeVec", a);
            }
            mh$.invokeExact(a);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getDefaultFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getDefaultFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static FunctionDescriptor sws_getDefaultFilter$descriptor() {
        return sws_getDefaultFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MethodHandle sws_getDefaultFilter$handle() {
        return sws_getDefaultFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MemorySegment sws_getDefaultFilter$address() {
        return sws_getDefaultFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MemorySegment sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose) {
        var mh$ = sws_getDefaultFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getDefaultFilter", lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose);
            }
            return (MemorySegment)mh$.invokeExact(lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_freeFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static FunctionDescriptor sws_freeFilter$descriptor() {
        return sws_freeFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static MethodHandle sws_freeFilter$handle() {
        return sws_freeFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static MemorySegment sws_freeFilter$address() {
        return sws_freeFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static void sws_freeFilter(MemorySegment filter) {
        var mh$ = sws_freeFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeFilter", filter);
            }
            mh$.invokeExact(filter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getCachedContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getCachedContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static FunctionDescriptor sws_getCachedContext$descriptor() {
        return sws_getCachedContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MethodHandle sws_getCachedContext$handle() {
        return sws_getCachedContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getCachedContext$address() {
        return sws_getCachedContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getCachedContext(MemorySegment context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, MemorySegment srcFilter, MemorySegment dstFilter, MemorySegment param) {
        var mh$ = sws_getCachedContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getCachedContext", context, srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
            }
            return (MemorySegment)mh$.invokeExact(context, srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_convertPalette8ToPacked32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_convertPalette8ToPacked32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static FunctionDescriptor sws_convertPalette8ToPacked32$descriptor() {
        return sws_convertPalette8ToPacked32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MethodHandle sws_convertPalette8ToPacked32$handle() {
        return sws_convertPalette8ToPacked32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MemorySegment sws_convertPalette8ToPacked32$address() {
        return sws_convertPalette8ToPacked32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static void sws_convertPalette8ToPacked32(MemorySegment src, MemorySegment dst, int num_pixels, MemorySegment palette) {
        var mh$ = sws_convertPalette8ToPacked32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_convertPalette8ToPacked32", src, dst, num_pixels, palette);
            }
            mh$.invokeExact(src, dst, num_pixels, palette);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_convertPalette8ToPacked24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_convertPalette8ToPacked24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static FunctionDescriptor sws_convertPalette8ToPacked24$descriptor() {
        return sws_convertPalette8ToPacked24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MethodHandle sws_convertPalette8ToPacked24$handle() {
        return sws_convertPalette8ToPacked24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MemorySegment sws_convertPalette8ToPacked24$address() {
        return sws_convertPalette8ToPacked24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static void sws_convertPalette8ToPacked24(MemorySegment src, MemorySegment dst, int num_pixels, MemorySegment palette) {
        var mh$ = sws_convertPalette8ToPacked24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_convertPalette8ToPacked24", src, dst, num_pixels, palette);
            }
            mh$.invokeExact(src, dst, num_pixels, palette);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long AV_NOPTS_VALUE = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define AV_NOPTS_VALUE -9223372036854775808
     * }
     */
    public static long AV_NOPTS_VALUE() {
        return AV_NOPTS_VALUE;
    }
    private static final int AVERROR_BSF_NOT_FOUND = (int)-1179861752L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BSF_NOT_FOUND -1179861752
     * }
     */
    public static int AVERROR_BSF_NOT_FOUND() {
        return AVERROR_BSF_NOT_FOUND;
    }
    private static final int AVERROR_BUG = (int)-558323010L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BUG -558323010
     * }
     */
    public static int AVERROR_BUG() {
        return AVERROR_BUG;
    }
    private static final int AVERROR_BUFFER_TOO_SMALL = (int)-1397118274L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BUFFER_TOO_SMALL -1397118274
     * }
     */
    public static int AVERROR_BUFFER_TOO_SMALL() {
        return AVERROR_BUFFER_TOO_SMALL;
    }
    private static final int AVERROR_DECODER_NOT_FOUND = (int)-1128613112L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_DECODER_NOT_FOUND -1128613112
     * }
     */
    public static int AVERROR_DECODER_NOT_FOUND() {
        return AVERROR_DECODER_NOT_FOUND;
    }
    private static final int AVERROR_DEMUXER_NOT_FOUND = (int)-1296385272L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_DEMUXER_NOT_FOUND -1296385272
     * }
     */
    public static int AVERROR_DEMUXER_NOT_FOUND() {
        return AVERROR_DEMUXER_NOT_FOUND;
    }
    private static final int AVERROR_ENCODER_NOT_FOUND = (int)-1129203192L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_ENCODER_NOT_FOUND -1129203192
     * }
     */
    public static int AVERROR_ENCODER_NOT_FOUND() {
        return AVERROR_ENCODER_NOT_FOUND;
    }
    private static final int AVERROR_EOF = (int)-541478725L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EOF -541478725
     * }
     */
    public static int AVERROR_EOF() {
        return AVERROR_EOF;
    }
    private static final int AVERROR_EXIT = (int)-1414092869L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EXIT -1414092869
     * }
     */
    public static int AVERROR_EXIT() {
        return AVERROR_EXIT;
    }
    private static final int AVERROR_EXTERNAL = (int)-542398533L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EXTERNAL -542398533
     * }
     */
    public static int AVERROR_EXTERNAL() {
        return AVERROR_EXTERNAL;
    }
    private static final int AVERROR_FILTER_NOT_FOUND = (int)-1279870712L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_FILTER_NOT_FOUND -1279870712
     * }
     */
    public static int AVERROR_FILTER_NOT_FOUND() {
        return AVERROR_FILTER_NOT_FOUND;
    }
    private static final int AVERROR_INVALIDDATA = (int)-1094995529L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_INVALIDDATA -1094995529
     * }
     */
    public static int AVERROR_INVALIDDATA() {
        return AVERROR_INVALIDDATA;
    }
    private static final int AVERROR_MUXER_NOT_FOUND = (int)-1481985528L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_MUXER_NOT_FOUND -1481985528
     * }
     */
    public static int AVERROR_MUXER_NOT_FOUND() {
        return AVERROR_MUXER_NOT_FOUND;
    }
    private static final int AVERROR_OPTION_NOT_FOUND = (int)-1414549496L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_OPTION_NOT_FOUND -1414549496
     * }
     */
    public static int AVERROR_OPTION_NOT_FOUND() {
        return AVERROR_OPTION_NOT_FOUND;
    }
    private static final int AVERROR_PATCHWELCOME = (int)-1163346256L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_PATCHWELCOME -1163346256
     * }
     */
    public static int AVERROR_PATCHWELCOME() {
        return AVERROR_PATCHWELCOME;
    }
    private static final int AVERROR_PROTOCOL_NOT_FOUND = (int)-1330794744L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_PROTOCOL_NOT_FOUND -1330794744
     * }
     */
    public static int AVERROR_PROTOCOL_NOT_FOUND() {
        return AVERROR_PROTOCOL_NOT_FOUND;
    }
    private static final int AVERROR_STREAM_NOT_FOUND = (int)-1381258232L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_STREAM_NOT_FOUND -1381258232
     * }
     */
    public static int AVERROR_STREAM_NOT_FOUND() {
        return AVERROR_STREAM_NOT_FOUND;
    }
    private static final int AVERROR_BUG2 = (int)-541545794L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BUG2 -541545794
     * }
     */
    public static int AVERROR_BUG2() {
        return AVERROR_BUG2;
    }
    private static final int AVERROR_UNKNOWN = (int)-1313558101L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_UNKNOWN -1313558101
     * }
     */
    public static int AVERROR_UNKNOWN() {
        return AVERROR_UNKNOWN;
    }
    private static final int AVERROR_EXPERIMENTAL = (int)-733130664L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EXPERIMENTAL -733130664
     * }
     */
    public static int AVERROR_EXPERIMENTAL() {
        return AVERROR_EXPERIMENTAL;
    }
    private static final int AVERROR_INPUT_CHANGED = (int)-1668179713L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_INPUT_CHANGED -1668179713
     * }
     */
    public static int AVERROR_INPUT_CHANGED() {
        return AVERROR_INPUT_CHANGED;
    }
    private static final int AVERROR_OUTPUT_CHANGED = (int)-1668179714L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_OUTPUT_CHANGED -1668179714
     * }
     */
    public static int AVERROR_OUTPUT_CHANGED() {
        return AVERROR_OUTPUT_CHANGED;
    }
    private static final int AVERROR_HTTP_BAD_REQUEST = (int)-808465656L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_BAD_REQUEST -808465656
     * }
     */
    public static int AVERROR_HTTP_BAD_REQUEST() {
        return AVERROR_HTTP_BAD_REQUEST;
    }
    private static final int AVERROR_HTTP_UNAUTHORIZED = (int)-825242872L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_UNAUTHORIZED -825242872
     * }
     */
    public static int AVERROR_HTTP_UNAUTHORIZED() {
        return AVERROR_HTTP_UNAUTHORIZED;
    }
    private static final int AVERROR_HTTP_FORBIDDEN = (int)-858797304L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_FORBIDDEN -858797304
     * }
     */
    public static int AVERROR_HTTP_FORBIDDEN() {
        return AVERROR_HTTP_FORBIDDEN;
    }
    private static final int AVERROR_HTTP_NOT_FOUND = (int)-875574520L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_NOT_FOUND -875574520
     * }
     */
    public static int AVERROR_HTTP_NOT_FOUND() {
        return AVERROR_HTTP_NOT_FOUND;
    }
    private static final int AVERROR_HTTP_TOO_MANY_REQUESTS = (int)-959591672L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_TOO_MANY_REQUESTS -959591672
     * }
     */
    public static int AVERROR_HTTP_TOO_MANY_REQUESTS() {
        return AVERROR_HTTP_TOO_MANY_REQUESTS;
    }
    private static final int AVERROR_HTTP_OTHER_4XX = (int)-1482175736L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_OTHER_4XX -1482175736
     * }
     */
    public static int AVERROR_HTTP_OTHER_4XX() {
        return AVERROR_HTTP_OTHER_4XX;
    }
    private static final int AVERROR_HTTP_SERVER_ERROR = (int)-1482175992L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_SERVER_ERROR -1482175992
     * }
     */
    public static int AVERROR_HTTP_SERVER_ERROR() {
        return AVERROR_HTTP_SERVER_ERROR;
    }
    private static final int LIBAVUTIL_VERSION_INT = (int)3934308L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_INT 3934308
     * }
     */
    public static int LIBAVUTIL_VERSION_INT() {
        return LIBAVUTIL_VERSION_INT;
    }
    private static final int AV_LOG_QUIET = (int)-8L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_QUIET -8
     * }
     */
    public static int AV_LOG_QUIET() {
        return AV_LOG_QUIET;
    }
    private static final int AV_LOG_MAX_OFFSET = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_MAX_OFFSET 64
     * }
     */
    public static int AV_LOG_MAX_OFFSET() {
        return AV_LOG_MAX_OFFSET;
    }
    private static final int AV_PIX_FMT_RGB32 = (int)28L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB32 28
     * }
     */
    public static int AV_PIX_FMT_RGB32() {
        return AV_PIX_FMT_RGB32;
    }
    private static final int AV_PIX_FMT_RGB32_1 = (int)27L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB32_1 27
     * }
     */
    public static int AV_PIX_FMT_RGB32_1() {
        return AV_PIX_FMT_RGB32_1;
    }
    private static final int AV_PIX_FMT_BGR32 = (int)26L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR32 26
     * }
     */
    public static int AV_PIX_FMT_BGR32() {
        return AV_PIX_FMT_BGR32;
    }
    private static final int AV_PIX_FMT_BGR32_1 = (int)25L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR32_1 25
     * }
     */
    public static int AV_PIX_FMT_BGR32_1() {
        return AV_PIX_FMT_BGR32_1;
    }
    private static final int AV_PIX_FMT_0RGB32 = (int)121L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_0RGB32 121
     * }
     */
    public static int AV_PIX_FMT_0RGB32() {
        return AV_PIX_FMT_0RGB32;
    }
    private static final int AV_PIX_FMT_0BGR32 = (int)119L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_0BGR32 119
     * }
     */
    public static int AV_PIX_FMT_0BGR32() {
        return AV_PIX_FMT_0BGR32;
    }
    private static final int AV_PIX_FMT_GRAY9 = (int)173L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY9 173
     * }
     */
    public static int AV_PIX_FMT_GRAY9() {
        return AV_PIX_FMT_GRAY9;
    }
    private static final int AV_PIX_FMT_GRAY10 = (int)168L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY10 168
     * }
     */
    public static int AV_PIX_FMT_GRAY10() {
        return AV_PIX_FMT_GRAY10;
    }
    private static final int AV_PIX_FMT_GRAY12 = (int)166L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY12 166
     * }
     */
    public static int AV_PIX_FMT_GRAY12() {
        return AV_PIX_FMT_GRAY12;
    }
    private static final int AV_PIX_FMT_GRAY14 = (int)181L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY14 181
     * }
     */
    public static int AV_PIX_FMT_GRAY14() {
        return AV_PIX_FMT_GRAY14;
    }
    private static final int AV_PIX_FMT_GRAY16 = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY16 30
     * }
     */
    public static int AV_PIX_FMT_GRAY16() {
        return AV_PIX_FMT_GRAY16;
    }
    private static final int AV_PIX_FMT_YA16 = (int)110L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YA16 110
     * }
     */
    public static int AV_PIX_FMT_YA16() {
        return AV_PIX_FMT_YA16;
    }
    private static final int AV_PIX_FMT_RGB48 = (int)35L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB48 35
     * }
     */
    public static int AV_PIX_FMT_RGB48() {
        return AV_PIX_FMT_RGB48;
    }
    private static final int AV_PIX_FMT_RGB565 = (int)37L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB565 37
     * }
     */
    public static int AV_PIX_FMT_RGB565() {
        return AV_PIX_FMT_RGB565;
    }
    private static final int AV_PIX_FMT_RGB555 = (int)39L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB555 39
     * }
     */
    public static int AV_PIX_FMT_RGB555() {
        return AV_PIX_FMT_RGB555;
    }
    private static final int AV_PIX_FMT_RGB444 = (int)52L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB444 52
     * }
     */
    public static int AV_PIX_FMT_RGB444() {
        return AV_PIX_FMT_RGB444;
    }
    private static final int AV_PIX_FMT_RGBA64 = (int)105L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGBA64 105
     * }
     */
    public static int AV_PIX_FMT_RGBA64() {
        return AV_PIX_FMT_RGBA64;
    }
    private static final int AV_PIX_FMT_BGR48 = (int)58L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR48 58
     * }
     */
    public static int AV_PIX_FMT_BGR48() {
        return AV_PIX_FMT_BGR48;
    }
    private static final int AV_PIX_FMT_BGR565 = (int)41L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR565 41
     * }
     */
    public static int AV_PIX_FMT_BGR565() {
        return AV_PIX_FMT_BGR565;
    }
    private static final int AV_PIX_FMT_BGR555 = (int)43L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR555 43
     * }
     */
    public static int AV_PIX_FMT_BGR555() {
        return AV_PIX_FMT_BGR555;
    }
    private static final int AV_PIX_FMT_BGR444 = (int)54L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR444 54
     * }
     */
    public static int AV_PIX_FMT_BGR444() {
        return AV_PIX_FMT_BGR444;
    }
    private static final int AV_PIX_FMT_BGRA64 = (int)107L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGRA64 107
     * }
     */
    public static int AV_PIX_FMT_BGRA64() {
        return AV_PIX_FMT_BGRA64;
    }
    private static final int AV_PIX_FMT_YUV420P9 = (int)60L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P9 60
     * }
     */
    public static int AV_PIX_FMT_YUV420P9() {
        return AV_PIX_FMT_YUV420P9;
    }
    private static final int AV_PIX_FMT_YUV422P9 = (int)70L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P9 70
     * }
     */
    public static int AV_PIX_FMT_YUV422P9() {
        return AV_PIX_FMT_YUV422P9;
    }
    private static final int AV_PIX_FMT_YUV444P9 = (int)66L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P9 66
     * }
     */
    public static int AV_PIX_FMT_YUV444P9() {
        return AV_PIX_FMT_YUV444P9;
    }
    private static final int AV_PIX_FMT_YUV420P10 = (int)62L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P10 62
     * }
     */
    public static int AV_PIX_FMT_YUV420P10() {
        return AV_PIX_FMT_YUV420P10;
    }
    private static final int AV_PIX_FMT_YUV422P10 = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P10 64
     * }
     */
    public static int AV_PIX_FMT_YUV422P10() {
        return AV_PIX_FMT_YUV422P10;
    }
    private static final int AV_PIX_FMT_YUV440P10 = (int)151L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV440P10 151
     * }
     */
    public static int AV_PIX_FMT_YUV440P10() {
        return AV_PIX_FMT_YUV440P10;
    }
    private static final int AV_PIX_FMT_YUV444P10 = (int)68L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P10 68
     * }
     */
    public static int AV_PIX_FMT_YUV444P10() {
        return AV_PIX_FMT_YUV444P10;
    }
    private static final int AV_PIX_FMT_YUV420P12 = (int)123L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P12 123
     * }
     */
    public static int AV_PIX_FMT_YUV420P12() {
        return AV_PIX_FMT_YUV420P12;
    }
    private static final int AV_PIX_FMT_YUV422P12 = (int)127L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P12 127
     * }
     */
    public static int AV_PIX_FMT_YUV422P12() {
        return AV_PIX_FMT_YUV422P12;
    }
    private static final int AV_PIX_FMT_YUV440P12 = (int)153L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV440P12 153
     * }
     */
    public static int AV_PIX_FMT_YUV440P12() {
        return AV_PIX_FMT_YUV440P12;
    }
    private static final int AV_PIX_FMT_YUV444P12 = (int)131L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P12 131
     * }
     */
    public static int AV_PIX_FMT_YUV444P12() {
        return AV_PIX_FMT_YUV444P12;
    }
    private static final int AV_PIX_FMT_YUV420P14 = (int)125L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P14 125
     * }
     */
    public static int AV_PIX_FMT_YUV420P14() {
        return AV_PIX_FMT_YUV420P14;
    }
    private static final int AV_PIX_FMT_YUV422P14 = (int)129L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P14 129
     * }
     */
    public static int AV_PIX_FMT_YUV422P14() {
        return AV_PIX_FMT_YUV422P14;
    }
    private static final int AV_PIX_FMT_YUV444P14 = (int)133L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P14 133
     * }
     */
    public static int AV_PIX_FMT_YUV444P14() {
        return AV_PIX_FMT_YUV444P14;
    }
    private static final int AV_PIX_FMT_YUV420P16 = (int)45L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P16 45
     * }
     */
    public static int AV_PIX_FMT_YUV420P16() {
        return AV_PIX_FMT_YUV420P16;
    }
    private static final int AV_PIX_FMT_YUV422P16 = (int)47L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P16 47
     * }
     */
    public static int AV_PIX_FMT_YUV422P16() {
        return AV_PIX_FMT_YUV422P16;
    }
    private static final int AV_PIX_FMT_YUV444P16 = (int)49L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P16 49
     * }
     */
    public static int AV_PIX_FMT_YUV444P16() {
        return AV_PIX_FMT_YUV444P16;
    }
    private static final int AV_PIX_FMT_GBRP9 = (int)73L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRP9 73
     * }
     */
    public static int AV_PIX_FMT_GBRP9() {
        return AV_PIX_FMT_GBRP9;
    }
    private static final int AV_PIX_FMT_GBRP10 = (int)75L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRP10 75
     * }
     */
    public static int AV_PIX_FMT_GBRP10() {
        return AV_PIX_FMT_GBRP10;
    }
    private static final int AV_PIX_FMT_GBRP12 = (int)135L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRP12 135
     * }
     */
    public static int AV_PIX_FMT_GBRP12() {
        return AV_PIX_FMT_GBRP12;
    }
    private static final int AV_PIX_FMT_GBRP14 = (int)137L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRP14 137
     * }
     */
    public static int AV_PIX_FMT_GBRP14() {
        return AV_PIX_FMT_GBRP14;
    }
    private static final int AV_PIX_FMT_GBRP16 = (int)77L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRP16 77
     * }
     */
    public static int AV_PIX_FMT_GBRP16() {
        return AV_PIX_FMT_GBRP16;
    }
    private static final int AV_PIX_FMT_GBRAP10 = (int)163L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRAP10 163
     * }
     */
    public static int AV_PIX_FMT_GBRAP10() {
        return AV_PIX_FMT_GBRAP10;
    }
    private static final int AV_PIX_FMT_GBRAP12 = (int)161L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRAP12 161
     * }
     */
    public static int AV_PIX_FMT_GBRAP12() {
        return AV_PIX_FMT_GBRAP12;
    }
    private static final int AV_PIX_FMT_GBRAP14 = (int)226L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRAP14 226
     * }
     */
    public static int AV_PIX_FMT_GBRAP14() {
        return AV_PIX_FMT_GBRAP14;
    }
    private static final int AV_PIX_FMT_GBRAP16 = (int)113L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRAP16 113
     * }
     */
    public static int AV_PIX_FMT_GBRAP16() {
        return AV_PIX_FMT_GBRAP16;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16 = (int)143L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BAYER_BGGR16 143
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16() {
        return AV_PIX_FMT_BAYER_BGGR16;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16 = (int)145L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BAYER_RGGB16 145
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16() {
        return AV_PIX_FMT_BAYER_RGGB16;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16 = (int)147L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BAYER_GBRG16 147
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16() {
        return AV_PIX_FMT_BAYER_GBRG16;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16 = (int)149L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BAYER_GRBG16 149
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16() {
        return AV_PIX_FMT_BAYER_GRBG16;
    }
    private static final int AV_PIX_FMT_GBRPF32 = (int)175L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRPF32 175
     * }
     */
    public static int AV_PIX_FMT_GBRPF32() {
        return AV_PIX_FMT_GBRPF32;
    }
    private static final int AV_PIX_FMT_GBRAPF32 = (int)177L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GBRAPF32 177
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32() {
        return AV_PIX_FMT_GBRAPF32;
    }
    private static final int AV_PIX_FMT_GRAYF32 = (int)183L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAYF32 183
     * }
     */
    public static int AV_PIX_FMT_GRAYF32() {
        return AV_PIX_FMT_GRAYF32;
    }
    private static final int AV_PIX_FMT_YUVA420P9 = (int)81L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA420P9 81
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9() {
        return AV_PIX_FMT_YUVA420P9;
    }
    private static final int AV_PIX_FMT_YUVA422P9 = (int)83L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA422P9 83
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9() {
        return AV_PIX_FMT_YUVA422P9;
    }
    private static final int AV_PIX_FMT_YUVA444P9 = (int)85L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA444P9 85
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9() {
        return AV_PIX_FMT_YUVA444P9;
    }
    private static final int AV_PIX_FMT_YUVA420P10 = (int)87L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA420P10 87
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10() {
        return AV_PIX_FMT_YUVA420P10;
    }
    private static final int AV_PIX_FMT_YUVA422P10 = (int)89L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA422P10 89
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10() {
        return AV_PIX_FMT_YUVA422P10;
    }
    private static final int AV_PIX_FMT_YUVA444P10 = (int)91L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA444P10 91
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10() {
        return AV_PIX_FMT_YUVA444P10;
    }
    private static final int AV_PIX_FMT_YUVA422P12 = (int)185L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA422P12 185
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12() {
        return AV_PIX_FMT_YUVA422P12;
    }
    private static final int AV_PIX_FMT_YUVA444P12 = (int)187L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA444P12 187
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12() {
        return AV_PIX_FMT_YUVA444P12;
    }
    private static final int AV_PIX_FMT_YUVA420P16 = (int)93L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA420P16 93
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16() {
        return AV_PIX_FMT_YUVA420P16;
    }
    private static final int AV_PIX_FMT_YUVA422P16 = (int)95L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA422P16 95
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16() {
        return AV_PIX_FMT_YUVA422P16;
    }
    private static final int AV_PIX_FMT_YUVA444P16 = (int)97L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUVA444P16 97
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16() {
        return AV_PIX_FMT_YUVA444P16;
    }
    private static final int AV_PIX_FMT_XYZ12 = (int)99L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_XYZ12 99
     * }
     */
    public static int AV_PIX_FMT_XYZ12() {
        return AV_PIX_FMT_XYZ12;
    }
    private static final int AV_PIX_FMT_NV20 = (int)102L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_NV20 102
     * }
     */
    public static int AV_PIX_FMT_NV20() {
        return AV_PIX_FMT_NV20;
    }
    private static final int AV_PIX_FMT_AYUV64 = (int)155L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_AYUV64 155
     * }
     */
    public static int AV_PIX_FMT_AYUV64() {
        return AV_PIX_FMT_AYUV64;
    }
    private static final int AV_PIX_FMT_P010 = (int)158L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P010 158
     * }
     */
    public static int AV_PIX_FMT_P010() {
        return AV_PIX_FMT_P010;
    }
    private static final int AV_PIX_FMT_P012 = (int)209L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P012 209
     * }
     */
    public static int AV_PIX_FMT_P012() {
        return AV_PIX_FMT_P012;
    }
    private static final int AV_PIX_FMT_P016 = (int)169L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P016 169
     * }
     */
    public static int AV_PIX_FMT_P016() {
        return AV_PIX_FMT_P016;
    }
    private static final int AV_PIX_FMT_Y210 = (int)192L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_Y210 192
     * }
     */
    public static int AV_PIX_FMT_Y210() {
        return AV_PIX_FMT_Y210;
    }
    private static final int AV_PIX_FMT_Y212 = (int)212L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_Y212 212
     * }
     */
    public static int AV_PIX_FMT_Y212() {
        return AV_PIX_FMT_Y212;
    }
    private static final int AV_PIX_FMT_XV30 = (int)214L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_XV30 214
     * }
     */
    public static int AV_PIX_FMT_XV30() {
        return AV_PIX_FMT_XV30;
    }
    private static final int AV_PIX_FMT_XV36 = (int)216L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_XV36 216
     * }
     */
    public static int AV_PIX_FMT_XV36() {
        return AV_PIX_FMT_XV36;
    }
    private static final int AV_PIX_FMT_X2RGB10 = (int)193L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_X2RGB10 193
     * }
     */
    public static int AV_PIX_FMT_X2RGB10() {
        return AV_PIX_FMT_X2RGB10;
    }
    private static final int AV_PIX_FMT_X2BGR10 = (int)195L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_X2BGR10 195
     * }
     */
    public static int AV_PIX_FMT_X2BGR10() {
        return AV_PIX_FMT_X2BGR10;
    }
    private static final int AV_PIX_FMT_P210 = (int)198L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P210 198
     * }
     */
    public static int AV_PIX_FMT_P210() {
        return AV_PIX_FMT_P210;
    }
    private static final int AV_PIX_FMT_P410 = (int)200L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P410 200
     * }
     */
    public static int AV_PIX_FMT_P410() {
        return AV_PIX_FMT_P410;
    }
    private static final int AV_PIX_FMT_P212 = (int)222L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P212 222
     * }
     */
    public static int AV_PIX_FMT_P212() {
        return AV_PIX_FMT_P212;
    }
    private static final int AV_PIX_FMT_P412 = (int)224L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P412 224
     * }
     */
    public static int AV_PIX_FMT_P412() {
        return AV_PIX_FMT_P412;
    }
    private static final int AV_PIX_FMT_P216 = (int)202L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P216 202
     * }
     */
    public static int AV_PIX_FMT_P216() {
        return AV_PIX_FMT_P216;
    }
    private static final int AV_PIX_FMT_P416 = (int)204L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_P416 204
     * }
     */
    public static int AV_PIX_FMT_P416() {
        return AV_PIX_FMT_P416;
    }
    private static final int AV_PIX_FMT_RGBAF16 = (int)207L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGBAF16 207
     * }
     */
    public static int AV_PIX_FMT_RGBAF16() {
        return AV_PIX_FMT_RGBAF16;
    }
    private static final int AV_PIX_FMT_RGBF32 = (int)218L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGBF32 218
     * }
     */
    public static int AV_PIX_FMT_RGBF32() {
        return AV_PIX_FMT_RGBF32;
    }
    private static final int AV_PIX_FMT_RGBAF32 = (int)220L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGBAF32 220
     * }
     */
    public static int AV_PIX_FMT_RGBAF32() {
        return AV_PIX_FMT_RGBAF32;
    }
    private static final int LIBAVCODEC_VERSION_INT = (int)4066148L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_INT 4066148
     * }
     */
    public static int LIBAVCODEC_VERSION_INT() {
        return LIBAVCODEC_VERSION_INT;
    }
    private static final int LIBAVFORMAT_VERSION_INT = (int)4064100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_INT 4064100
     * }
     */
    public static int LIBAVFORMAT_VERSION_INT() {
        return LIBAVFORMAT_VERSION_INT;
    }
    private static final int LIBSWSCALE_VERSION_INT = (int)590180L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_INT 590180
     * }
     */
    public static int LIBSWSCALE_VERSION_INT() {
        return LIBSWSCALE_VERSION_INT;
    }
    private static final double SWS_MAX_REDUCE_CUTOFF = 0.002d;
    /**
     * {@snippet lang=c :
     * #define SWS_MAX_REDUCE_CUTOFF 0.002
     * }
     */
    public static double SWS_MAX_REDUCE_CUTOFF() {
        return SWS_MAX_REDUCE_CUTOFF;
    }
}

