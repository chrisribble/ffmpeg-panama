// Generated by jextract

package io.github.chrisribble.ffmpeg6;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class FFmpeg_2 extends FFmpeg_3 {

    FFmpeg_2() {
        // Should not be called directly
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("llrint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static long llrint(double __x) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__llrint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static FunctionDescriptor __llrint$descriptor() {
        return __llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static MethodHandle __llrint$handle() {
        return __llrint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static long __llrint(double __x) {
        var mh$ = __llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lround"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static long lround(double __x) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__lround"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static FunctionDescriptor __lround$descriptor() {
        return __lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static MethodHandle __lround$handle() {
        return __lround.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static long __lround(double __x) {
        var mh$ = __lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("llround"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static long llround(double __x) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__llround"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static FunctionDescriptor __llround$descriptor() {
        return __llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static MethodHandle __llround$handle() {
        return __llround.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static long __llround(double __x) {
        var mh$ = __llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fdim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static double fdim(double __x, double __y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fdim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fdim$descriptor() {
        return __fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static MethodHandle __fdim$handle() {
        return __fdim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static double __fdim(double __x, double __y) {
        var mh$ = __fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fmax"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static double fmax(double __x, double __y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fmax"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmax$descriptor() {
        return __fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static MethodHandle __fmax$handle() {
        return __fmax.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static double __fmax(double __x, double __y) {
        var mh$ = __fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmax", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fmin"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static double fmin(double __x, double __y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fmin"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmin$descriptor() {
        return __fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static MethodHandle __fmin$handle() {
        return __fmin.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static double __fmin(double __x, double __y) {
        var mh$ = __fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmin", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fma"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static double fma(double __x, double __y, double __z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fma"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor __fma$descriptor() {
        return __fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle __fma$handle() {
        return __fma.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static double __fma(double __x, double __y, double __z) {
        var mh$ = __fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("scalb"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static double scalb(double __x, double __n) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__scalb"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor __scalb$descriptor() {
        return __scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static MethodHandle __scalb$handle() {
        return __scalb.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static double __scalb(double __x, double __n) {
        var mh$ = __scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fpclassifyf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static int __fpclassifyf(float __value) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __signbitf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__signbitf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static FunctionDescriptor __signbitf$descriptor() {
        return __signbitf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static MethodHandle __signbitf$handle() {
        return __signbitf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static int __signbitf(float __value) {
        var mh$ = __signbitf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__signbitf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isinff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__isinff"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static FunctionDescriptor __isinff$descriptor() {
        return __isinff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static MethodHandle __isinff$handle() {
        return __isinff.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static int __isinff(float __value) {
        var mh$ = __isinff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isinff", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__finitef"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static FunctionDescriptor __finitef$descriptor() {
        return __finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static MethodHandle __finitef$handle() {
        return __finitef.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static int __finitef(float __value) {
        var mh$ = __finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__finitef", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__isnanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static FunctionDescriptor __isnanf$descriptor() {
        return __isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static MethodHandle __isnanf$handle() {
        return __isnanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static int __isnanf(float __value) {
        var mh$ = __isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isnanf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iseqsigf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__iseqsigf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __iseqsigf$descriptor() {
        return __iseqsigf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static MethodHandle __iseqsigf$handle() {
        return __iseqsigf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static int __iseqsigf(float __x, float __y) {
        var mh$ = __iseqsigf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iseqsigf", __x, __y);
            }
            return (int)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __issignalingf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__issignalingf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static FunctionDescriptor __issignalingf$descriptor() {
        return __issignalingf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static MethodHandle __issignalingf$handle() {
        return __issignalingf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static int __issignalingf(float __value) {
        var mh$ = __issignalingf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__issignalingf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("acosf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static float acosf(float __x) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__acosf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static FunctionDescriptor __acosf$descriptor() {
        return __acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static MethodHandle __acosf$handle() {
        return __acosf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static float __acosf(float __x) {
        var mh$ = __acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("asinf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static float asinf(float __x) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__asinf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static FunctionDescriptor __asinf$descriptor() {
        return __asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static MethodHandle __asinf$handle() {
        return __asinf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static float __asinf(float __x) {
        var mh$ = __asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static float atanf(float __x) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__atanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static FunctionDescriptor __atanf$descriptor() {
        return __atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static MethodHandle __atanf$handle() {
        return __atanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static float __atanf(float __x) {
        var mh$ = __atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atan2f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static float atan2f(float __y, float __x) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", __y, __x);
            }
            return (float)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__atan2f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static FunctionDescriptor __atan2f$descriptor() {
        return __atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static MethodHandle __atan2f$handle() {
        return __atan2f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static float __atan2f(float __y, float __x) {
        var mh$ = __atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atan2f", __y, __x);
            }
            return (float)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("cosf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static float cosf(float __x) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__cosf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static FunctionDescriptor __cosf$descriptor() {
        return __cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static MethodHandle __cosf$handle() {
        return __cosf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static float __cosf(float __x) {
        var mh$ = __cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("sinf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static float sinf(float __x) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__sinf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static FunctionDescriptor __sinf$descriptor() {
        return __sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static MethodHandle __sinf$handle() {
        return __sinf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static float __sinf(float __x) {
        var mh$ = __sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("tanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static float tanf(float __x) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__tanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static FunctionDescriptor __tanf$descriptor() {
        return __tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static MethodHandle __tanf$handle() {
        return __tanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static float __tanf(float __x) {
        var mh$ = __tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("coshf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static float coshf(float __x) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__coshf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static FunctionDescriptor __coshf$descriptor() {
        return __coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static MethodHandle __coshf$handle() {
        return __coshf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static float __coshf(float __x) {
        var mh$ = __coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__coshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("sinhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static float sinhf(float __x) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__sinhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static FunctionDescriptor __sinhf$descriptor() {
        return __sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static MethodHandle __sinhf$handle() {
        return __sinhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static float __sinhf(float __x) {
        var mh$ = __sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("tanhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static float tanhf(float __x) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__tanhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static FunctionDescriptor __tanhf$descriptor() {
        return __tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static MethodHandle __tanhf$handle() {
        return __tanhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static float __tanhf(float __x) {
        var mh$ = __tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("acoshf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static float acoshf(float __x) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__acoshf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static FunctionDescriptor __acoshf$descriptor() {
        return __acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static MethodHandle __acoshf$handle() {
        return __acoshf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static float __acoshf(float __x) {
        var mh$ = __acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acoshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("asinhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static float asinhf(float __x) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__asinhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static FunctionDescriptor __asinhf$descriptor() {
        return __asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static MethodHandle __asinhf$handle() {
        return __asinhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static float __asinhf(float __x) {
        var mh$ = __asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atanhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static float atanhf(float __x) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__atanhf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static FunctionDescriptor __atanhf$descriptor() {
        return __atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static MethodHandle __atanhf$handle() {
        return __atanhf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static float __atanhf(float __x) {
        var mh$ = __atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("expf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static float expf(float __x) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__expf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static FunctionDescriptor __expf$descriptor() {
        return __expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static MethodHandle __expf$handle() {
        return __expf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static float __expf(float __x) {
        var mh$ = __expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("frexpf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static float frexpf(float __x, MemorySegment __exponent) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__frexpf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor __frexpf$descriptor() {
        return __frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static MethodHandle __frexpf$handle() {
        return __frexpf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static float __frexpf(float __x, MemorySegment __exponent) {
        var mh$ = __frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__frexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ldexpf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static float ldexpf(float __x, int __exponent) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__ldexpf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static FunctionDescriptor __ldexpf$descriptor() {
        return __ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static MethodHandle __ldexpf$handle() {
        return __ldexpf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static float __ldexpf(float __x, int __exponent) {
        var mh$ = __ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ldexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("logf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static float logf(float __x) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__logf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static FunctionDescriptor __logf$descriptor() {
        return __logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static MethodHandle __logf$handle() {
        return __logf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static float __logf(float __x) {
        var mh$ = __logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("log10f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static float log10f(float __x) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__log10f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static FunctionDescriptor __log10f$descriptor() {
        return __log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static MethodHandle __log10f$handle() {
        return __log10f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static float __log10f(float __x) {
        var mh$ = __log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log10f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("modff"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static float modff(float __x, MemorySegment __iptr) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", __x, __iptr);
            }
            return (float)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__modff"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static FunctionDescriptor __modff$descriptor() {
        return __modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static MethodHandle __modff$handle() {
        return __modff.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static float __modff(float __x, MemorySegment __iptr) {
        var mh$ = __modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__modff", __x, __iptr);
            }
            return (float)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("expm1f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static float expm1f(float __x) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__expm1f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static FunctionDescriptor __expm1f$descriptor() {
        return __expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static MethodHandle __expm1f$handle() {
        return __expm1f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static float __expm1f(float __x) {
        var mh$ = __expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expm1f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("log1pf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static float log1pf(float __x) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__log1pf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static FunctionDescriptor __log1pf$descriptor() {
        return __log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static MethodHandle __log1pf$handle() {
        return __log1pf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static float __log1pf(float __x) {
        var mh$ = __log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log1pf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("logbf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static float logbf(float __x) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__logbf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static FunctionDescriptor __logbf$descriptor() {
        return __logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static MethodHandle __logbf$handle() {
        return __logbf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static float __logbf(float __x) {
        var mh$ = __logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logbf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("exp2f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static float exp2f(float __x) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__exp2f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static FunctionDescriptor __exp2f$descriptor() {
        return __exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static MethodHandle __exp2f$handle() {
        return __exp2f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static float __exp2f(float __x) {
        var mh$ = __exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("log2f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static float log2f(float __x) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__log2f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static FunctionDescriptor __log2f$descriptor() {
        return __log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static MethodHandle __log2f$handle() {
        return __log2f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static float __log2f(float __x) {
        var mh$ = __log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("powf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static float powf(float __x, float __y) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__powf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __powf$descriptor() {
        return __powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static MethodHandle __powf$handle() {
        return __powf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static float __powf(float __x, float __y) {
        var mh$ = __powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__powf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("sqrtf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static float sqrtf(float __x) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__sqrtf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static FunctionDescriptor __sqrtf$descriptor() {
        return __sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static MethodHandle __sqrtf$handle() {
        return __sqrtf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static float __sqrtf(float __x) {
        var mh$ = __sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sqrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("hypotf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static float hypotf(float __x, float __y) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__hypotf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __hypotf$descriptor() {
        return __hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static MethodHandle __hypotf$handle() {
        return __hypotf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static float __hypotf(float __x, float __y) {
        var mh$ = __hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__hypotf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("cbrtf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static float cbrtf(float __x) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__cbrtf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static FunctionDescriptor __cbrtf$descriptor() {
        return __cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static MethodHandle __cbrtf$handle() {
        return __cbrtf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static float __cbrtf(float __x) {
        var mh$ = __cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cbrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ceilf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static float ceilf(float __x) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__ceilf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static FunctionDescriptor __ceilf$descriptor() {
        return __ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static MethodHandle __ceilf$handle() {
        return __ceilf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static float __ceilf(float __x) {
        var mh$ = __ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ceilf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fabsf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static float fabsf(float __x) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fabsf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static FunctionDescriptor __fabsf$descriptor() {
        return __fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static MethodHandle __fabsf$handle() {
        return __fabsf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static float __fabsf(float __x) {
        var mh$ = __fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fabsf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("floorf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static float floorf(float __x) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__floorf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static FunctionDescriptor __floorf$descriptor() {
        return __floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static MethodHandle __floorf$handle() {
        return __floorf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static float __floorf(float __x) {
        var mh$ = __floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__floorf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fmodf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static float fmodf(float __x, float __y) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fmodf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fmodf$descriptor() {
        return __fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static MethodHandle __fmodf$handle() {
        return __fmodf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static float __fmodf(float __x, float __y) {
        var mh$ = __fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmodf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isinff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("isinff"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static FunctionDescriptor isinff$descriptor() {
        return isinff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static MethodHandle isinff$handle() {
        return isinff.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static int isinff(float __value) {
        var mh$ = isinff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isinff", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("finitef"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static FunctionDescriptor finitef$descriptor() {
        return finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static MethodHandle finitef$handle() {
        return finitef.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static int finitef(float __value) {
        var mh$ = finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("finitef", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dremf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("dremf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor dremf$descriptor() {
        return dremf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static MethodHandle dremf$handle() {
        return dremf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static float dremf(float __x, float __y) {
        var mh$ = dremf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dremf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __dremf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__dremf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __dremf$descriptor() {
        return __dremf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static MethodHandle __dremf$handle() {
        return __dremf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static float __dremf(float __x, float __y) {
        var mh$ = __dremf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__dremf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class significandf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("significandf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static FunctionDescriptor significandf$descriptor() {
        return significandf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static MethodHandle significandf$handle() {
        return significandf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static float significandf(float __x) {
        var mh$ = significandf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("significandf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __significandf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__significandf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static FunctionDescriptor __significandf$descriptor() {
        return __significandf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static MethodHandle __significandf$handle() {
        return __significandf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static float __significandf(float __x) {
        var mh$ = __significandf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__significandf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("copysignf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static float copysignf(float __x, float __y) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__copysignf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __copysignf$descriptor() {
        return __copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static MethodHandle __copysignf$handle() {
        return __copysignf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static float __copysignf(float __x, float __y) {
        var mh$ = __copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__copysignf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("nanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static float nanf(MemorySegment __tagb) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", __tagb);
            }
            return (float)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__nanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static FunctionDescriptor __nanf$descriptor() {
        return __nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static MethodHandle __nanf$handle() {
        return __nanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static float __nanf(MemorySegment __tagb) {
        var mh$ = __nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nanf", __tagb);
            }
            return (float)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("isnanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static FunctionDescriptor isnanf$descriptor() {
        return isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static MethodHandle isnanf$handle() {
        return isnanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static int isnanf(float __value) {
        var mh$ = isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isnanf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("j0f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static FunctionDescriptor j0f$descriptor() {
        return j0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static MethodHandle j0f$handle() {
        return j0f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static float j0f(float x0) {
        var mh$ = j0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__j0f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static FunctionDescriptor __j0f$descriptor() {
        return __j0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static MethodHandle __j0f$handle() {
        return __j0f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static float __j0f(float x0) {
        var mh$ = __j0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("j1f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static FunctionDescriptor j1f$descriptor() {
        return j1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static MethodHandle j1f$handle() {
        return j1f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static float j1f(float x0) {
        var mh$ = j1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__j1f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static FunctionDescriptor __j1f$descriptor() {
        return __j1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static MethodHandle __j1f$handle() {
        return __j1f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static float __j1f(float x0) {
        var mh$ = __j1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("jnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static FunctionDescriptor jnf$descriptor() {
        return jnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static MethodHandle jnf$handle() {
        return jnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static float jnf(int x0, float x1) {
        var mh$ = jnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __jnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__jnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static FunctionDescriptor __jnf$descriptor() {
        return __jnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static MethodHandle __jnf$handle() {
        return __jnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static float __jnf(int x0, float x1) {
        var mh$ = __jnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__jnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("y0f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static FunctionDescriptor y0f$descriptor() {
        return y0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static MethodHandle y0f$handle() {
        return y0f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static float y0f(float x0) {
        var mh$ = y0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__y0f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static FunctionDescriptor __y0f$descriptor() {
        return __y0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static MethodHandle __y0f$handle() {
        return __y0f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static float __y0f(float x0) {
        var mh$ = __y0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("y1f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static FunctionDescriptor y1f$descriptor() {
        return y1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static MethodHandle y1f$handle() {
        return y1f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static float y1f(float x0) {
        var mh$ = y1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__y1f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static FunctionDescriptor __y1f$descriptor() {
        return __y1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static MethodHandle __y1f$handle() {
        return __y1f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static float __y1f(float x0) {
        var mh$ = __y1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ynf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ynf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static FunctionDescriptor ynf$descriptor() {
        return ynf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static MethodHandle ynf$handle() {
        return ynf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static float ynf(int x0, float x1) {
        var mh$ = ynf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ynf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ynf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__ynf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static FunctionDescriptor __ynf$descriptor() {
        return __ynf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static MethodHandle __ynf$handle() {
        return __ynf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static float __ynf(int x0, float x1) {
        var mh$ = __ynf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ynf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("erff"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__erff"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static FunctionDescriptor __erff$descriptor() {
        return __erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static MethodHandle __erff$handle() {
        return __erff.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static float __erff(float x0) {
        var mh$ = __erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("erfcf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__erfcf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static FunctionDescriptor __erfcf$descriptor() {
        return __erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static MethodHandle __erfcf$handle() {
        return __erfcf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static float __erfcf(float x0) {
        var mh$ = __erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lgammaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__lgammaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static FunctionDescriptor __lgammaf$descriptor() {
        return __lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static MethodHandle __lgammaf$handle() {
        return __lgammaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static float __lgammaf(float x0) {
        var mh$ = __lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("tgammaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__tgammaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static FunctionDescriptor __tgammaf$descriptor() {
        return __tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static MethodHandle __tgammaf$handle() {
        return __tgammaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static float __tgammaf(float x0) {
        var mh$ = __tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("gammaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static FunctionDescriptor gammaf$descriptor() {
        return gammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static MethodHandle gammaf$handle() {
        return gammaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static float gammaf(float x0) {
        var mh$ = gammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__gammaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static FunctionDescriptor __gammaf$descriptor() {
        return __gammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static MethodHandle __gammaf$handle() {
        return __gammaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static float __gammaf(float x0) {
        var mh$ = __gammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lgammaf_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static FunctionDescriptor lgammaf_r$descriptor() {
        return lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MethodHandle lgammaf_r$handle() {
        return lgammaf_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static float lgammaf_r(float x0, MemorySegment __signgamp) {
        var mh$ = lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf_r", x0, __signgamp);
            }
            return (float)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__lgammaf_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static FunctionDescriptor __lgammaf_r$descriptor() {
        return __lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MethodHandle __lgammaf_r$handle() {
        return __lgammaf_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static float __lgammaf_r(float x0, MemorySegment __signgamp) {
        var mh$ = __lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgammaf_r", x0, __signgamp);
            }
            return (float)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("rintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static float rintf(float __x) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__rintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static FunctionDescriptor __rintf$descriptor() {
        return __rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static MethodHandle __rintf$handle() {
        return __rintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static float __rintf(float __x) {
        var mh$ = __rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__rintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("nextafterf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static float nextafterf(float __x, float __y) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__nextafterf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __nextafterf$descriptor() {
        return __nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static MethodHandle __nextafterf$handle() {
        return __nextafterf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static float __nextafterf(float __x, float __y) {
        var mh$ = __nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nextafterf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("remainderf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static float remainderf(float __x, float __y) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__remainderf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __remainderf$descriptor() {
        return __remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static MethodHandle __remainderf$handle() {
        return __remainderf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static float __remainderf(float __x, float __y) {
        var mh$ = __remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remainderf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("scalbnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static float scalbnf(float __x, int __n) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__scalbnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static FunctionDescriptor __scalbnf$descriptor() {
        return __scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static MethodHandle __scalbnf$handle() {
        return __scalbnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static float __scalbnf(float __x, int __n) {
        var mh$ = __scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ilogbf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static int ilogbf(float __x) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__ilogbf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static FunctionDescriptor __ilogbf$descriptor() {
        return __ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static MethodHandle __ilogbf$handle() {
        return __ilogbf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static int __ilogbf(float __x) {
        var mh$ = __ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ilogbf", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("scalblnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static float scalblnf(float __x, long __n) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__scalblnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static FunctionDescriptor __scalblnf$descriptor() {
        return __scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static MethodHandle __scalblnf$handle() {
        return __scalblnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static float __scalblnf(float __x, long __n) {
        var mh$ = __scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalblnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("nearbyintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static float nearbyintf(float __x) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__nearbyintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static FunctionDescriptor __nearbyintf$descriptor() {
        return __nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static MethodHandle __nearbyintf$handle() {
        return __nearbyintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static float __nearbyintf(float __x) {
        var mh$ = __nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nearbyintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("roundf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static float roundf(float __x) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__roundf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static FunctionDescriptor __roundf$descriptor() {
        return __roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static MethodHandle __roundf$handle() {
        return __roundf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static float __roundf(float __x) {
        var mh$ = __roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__roundf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("truncf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static float truncf(float __x) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__truncf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static FunctionDescriptor __truncf$descriptor() {
        return __truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static MethodHandle __truncf$handle() {
        return __truncf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static float __truncf(float __x) {
        var mh$ = __truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__truncf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("remquof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static float remquof(float __x, float __y, MemorySegment __quo) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", __x, __y, __quo);
            }
            return (float)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__remquof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static FunctionDescriptor __remquof$descriptor() {
        return __remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MethodHandle __remquof$handle() {
        return __remquof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static float __remquof(float __x, float __y, MemorySegment __quo) {
        var mh$ = __remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remquof", __x, __y, __quo);
            }
            return (float)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lrintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static long lrintf(float __x) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__lrintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static FunctionDescriptor __lrintf$descriptor() {
        return __lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static MethodHandle __lrintf$handle() {
        return __lrintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static long __lrintf(float __x) {
        var mh$ = __lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("llrintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static long llrintf(float __x) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__llrintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static FunctionDescriptor __llrintf$descriptor() {
        return __llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static MethodHandle __llrintf$handle() {
        return __llrintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static long __llrintf(float __x) {
        var mh$ = __llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lroundf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static long lroundf(float __x) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__lroundf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static FunctionDescriptor __lroundf$descriptor() {
        return __lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static MethodHandle __lroundf$handle() {
        return __lroundf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static long __lroundf(float __x) {
        var mh$ = __lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("llroundf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static long llroundf(float __x) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__llroundf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static FunctionDescriptor __llroundf$descriptor() {
        return __llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static MethodHandle __llroundf$handle() {
        return __llroundf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static long __llroundf(float __x) {
        var mh$ = __llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fdimf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static float fdimf(float __x, float __y) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fdimf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fdimf$descriptor() {
        return __fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static MethodHandle __fdimf$handle() {
        return __fdimf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static float __fdimf(float __x, float __y) {
        var mh$ = __fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fdimf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fmaxf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static float fmaxf(float __x, float __y) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fmaxf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fmaxf$descriptor() {
        return __fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static MethodHandle __fmaxf$handle() {
        return __fmaxf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static float __fmaxf(float __x, float __y) {
        var mh$ = __fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmaxf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fminf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static float fminf(float __x, float __y) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fminf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fminf$descriptor() {
        return __fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static MethodHandle __fminf$handle() {
        return __fminf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static float __fminf(float __x, float __y) {
        var mh$ = __fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fminf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fmaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static float fmaf(float __x, float __y, float __z) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", __x, __y, __z);
            }
            return (float)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__fmaf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static FunctionDescriptor __fmaf$descriptor() {
        return __fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static MethodHandle __fmaf$handle() {
        return __fmaf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static float __fmaf(float __x, float __y, float __z) {
        var mh$ = __fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmaf", __x, __y, __z);
            }
            return (float)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("scalbf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static FunctionDescriptor scalbf$descriptor() {
        return scalbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static MethodHandle scalbf$handle() {
        return scalbf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static float scalbf(float __x, float __n) {
        var mh$ = scalbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__scalbf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static FunctionDescriptor __scalbf$descriptor() {
        return __scalbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static MethodHandle __scalbf$handle() {
        return __scalbf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static float __scalbf(float __x, float __n) {
        var mh$ = __scalbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = FFmpeg.C_INT;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = FFmpeg.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("remove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("rename"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("renameat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("tmpfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("tmpnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("tmpnam_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("tempnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fflush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fflush_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("freopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fdopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fopencookie"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fmemopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("open_memstream"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("setbuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("setvbuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("setbuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("setlinebuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vfprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vsprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_LONG,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int)spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vsnprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vasprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int)spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int)spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vdprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int)spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int)spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int)spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int)spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vfscanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vscanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("vsscanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fgetc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getchar_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fgetc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fputc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("putc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("putchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fputc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("putc_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("putchar_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("putw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fgets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__getdelim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getdelim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getline"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fputs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("puts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ungetc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fwrite"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fread_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fwrite_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fseek"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ftell"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("rewind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fseeko"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ftello"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fgetpos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fsetpos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("clearerr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("feof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ferror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("clearerr_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("feof_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ferror_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("perror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fileno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fileno_unlocked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("pclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("popen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ctermid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("flockfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ftrylockfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("funlockfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__uflow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__overflow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = FFmpeg.C_INT;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__ctype_get_mb_cur_max"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atoi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtod"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtoul"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtoq"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtouq"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtoull"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("l64a"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("a64l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = FFmpeg.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("select"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("pselect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = FFmpeg.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("random"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("srandom"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("initstate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("setstate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("random_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("srandom_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("initstate_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("setstate_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("rand"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("srand"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("rand_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("drand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("erand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("nrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("jrand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("srand48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("seed48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lcong48"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("drand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("erand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("nrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("jrand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("srand48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("seed48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lcong48_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("arc4random"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("arc4random_buf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __size) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __size);
            }
            mh$.invokeExact(__buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("arc4random_uniform"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("malloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("calloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("reallocarray"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("alloca"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("valloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("posix_memalign"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("aligned_alloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("abort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("atexit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("at_quick_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("on_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("quick_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("_Exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("putenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("setenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("unsetenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("clearenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mktemp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mkstemp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mkstemps"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mkdtemp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("system"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("realpath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("bsearch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("qsort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("abs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("labs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("llabs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("div"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ldiv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("lldiv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ecvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("gcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ecvt_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("fcvt_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mblen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mbtowc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("wctomb"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mbstowcs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("wcstombs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("rpmatch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getsubopt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("getloadavg"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("memcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("memmove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("memccpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("memset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("memcmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__memcmpeq"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("memchr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strncpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strncat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strncmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strxfrm"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = FFmpeg.C_POINTER;

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcoll_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strxfrm_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strdup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strndup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strchr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strrchr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strchrnul"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcspn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strspn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strpbrk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strstr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtok"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__strtok_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strtok_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcasestr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("memmem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem(MemorySegment __haystack, long __haystacklen, MemorySegment __needle, long __needlelen) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __haystack, __haystacklen, __needle, __needlelen);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __haystacklen, __needle, __needlelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__mempcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __mempcpy$descriptor() {
        return __mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __mempcpy$handle() {
        return __mempcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("mempcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor mempcpy$descriptor() {
        return mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle mempcpy$handle() {
        return mempcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strnlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strerror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strerror_r"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strerror_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("bcmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("bcopy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("bzero"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("index"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("rindex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ffs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ffsl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("ffsll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcasecmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strncasecmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strcasecmp_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strncasecmp_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("explicit_bzero"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strsep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strsignal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__stpcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("stpcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("__stpncpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("stpncpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strlcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("strlcat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2$descriptor() {
        return av_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static MethodHandle av_log2$handle() {
        return av_log2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static int av_log2(int v) {
        var mh$ = av_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2_16bit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log2_16bit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2_16bit$descriptor() {
        return av_log2_16bit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static MethodHandle av_log2_16bit$handle() {
        return av_log2_16bit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static int av_log2_16bit(int v) {
        var mh$ = av_log2_16bit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2_16bit", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_malloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc$descriptor() {
        return av_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MethodHandle av_malloc$handle() {
        return av_malloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc(long size) {
        var mh$ = av_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_mallocz"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_mallocz$descriptor() {
        return av_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MethodHandle av_mallocz$handle() {
        return av_mallocz.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz(long size) {
        var mh$ = av_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mallocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_malloc_array"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc_array$descriptor() {
        return av_malloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_malloc_array$handle() {
        return av_malloc_array.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array(long nmemb, long size) {
        var mh$ = av_malloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc_array", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_calloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_calloc$descriptor() {
        return av_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_calloc$handle() {
        return av_calloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc(long nmemb, long size) {
        var mh$ = av_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_calloc", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc$descriptor() {
        return av_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_realloc$handle() {
        return av_realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc(MemorySegment ptr, long size) {
        var mh$ = av_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_reallocp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp$descriptor() {
        return av_reallocp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_reallocp$handle() {
        return av_reallocp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static int av_reallocp(MemorySegment ptr, long size) {
        var mh$ = av_reallocp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp", ptr, size);
            }
            return (int)mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_realloc_f"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor av_realloc_f$descriptor() {
        return av_realloc_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle av_realloc_f$handle() {
        return av_realloc_f.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f(MemorySegment ptr, long nelem, long elsize) {
        var mh$ = av_realloc_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_f", ptr, nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_realloc_array"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc_array$descriptor() {
        return av_realloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_realloc_array$handle() {
        return av_realloc_array.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_realloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_array", ptr, nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_reallocp_array"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp_array$descriptor() {
        return av_reallocp_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_reallocp_array$handle() {
        return av_reallocp_array.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static int av_reallocp_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_reallocp_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp_array", ptr, nmemb, size);
            }
            return (int)mh$.invokeExact(ptr, nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_fast_realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_realloc$descriptor() {
        return av_fast_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_realloc$handle() {
        return av_fast_realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_realloc", ptr, size, min_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_fast_malloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_malloc$descriptor() {
        return av_fast_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_malloc$handle() {
        return av_fast_malloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_fast_mallocz"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_mallocz$descriptor() {
        return av_fast_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_mallocz$handle() {
        return av_fast_mallocz.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static FunctionDescriptor av_free$descriptor() {
        return av_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MethodHandle av_free$handle() {
        return av_free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static void av_free(MemorySegment ptr) {
        var mh$ = av_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_freep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_freep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static FunctionDescriptor av_freep$descriptor() {
        return av_freep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MethodHandle av_freep$handle() {
        return av_freep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static void av_freep(MemorySegment ptr) {
        var mh$ = av_freep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_freep", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_strdup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static FunctionDescriptor av_strdup$descriptor() {
        return av_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MethodHandle av_strdup$handle() {
        return av_strdup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup(MemorySegment s) {
        var mh$ = av_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strdup", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_strndup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static FunctionDescriptor av_strndup$descriptor() {
        return av_strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MethodHandle av_strndup$handle() {
        return av_strndup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup(MemorySegment s, long len) {
        var mh$ = av_strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strndup", s, len);
            }
            return (MemorySegment)mh$.invokeExact(s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_memdup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static FunctionDescriptor av_memdup$descriptor() {
        return av_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MethodHandle av_memdup$handle() {
        return av_memdup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup(MemorySegment p, long size) {
        var mh$ = av_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memdup", p, size);
            }
            return (MemorySegment)mh$.invokeExact(p, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memcpy_backptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_memcpy_backptr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static FunctionDescriptor av_memcpy_backptr$descriptor() {
        return av_memcpy_backptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MethodHandle av_memcpy_backptr$handle() {
        return av_memcpy_backptr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static void av_memcpy_backptr(MemorySegment dst, int back, int cnt) {
        var mh$ = av_memcpy_backptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memcpy_backptr", dst, back, cnt);
            }
            mh$.invokeExact(dst, back, cnt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dynarray_add"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add$descriptor() {
        return av_dynarray_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add$handle() {
        return av_dynarray_add.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static void av_dynarray_add(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add", tab_ptr, nb_ptr, elem);
            }
            mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add_nofree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dynarray_add_nofree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add_nofree$descriptor() {
        return av_dynarray_add_nofree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add_nofree$handle() {
        return av_dynarray_add_nofree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static int av_dynarray_add_nofree(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add_nofree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add_nofree", tab_ptr, nb_ptr, elem);
            }
            return (int)mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray2_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dynarray2_add"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static FunctionDescriptor av_dynarray2_add$descriptor() {
        return av_dynarray2_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MethodHandle av_dynarray2_add$handle() {
        return av_dynarray2_add.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add(MemorySegment tab_ptr, MemorySegment nb_ptr, long elem_size, MemorySegment elem_data) {
        var mh$ = av_dynarray2_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray2_add", tab_ptr, nb_ptr, elem_size, elem_data);
            }
            return (MemorySegment)mh$.invokeExact(tab_ptr, nb_ptr, elem_size, elem_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_size_mult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_size_mult"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static FunctionDescriptor av_size_mult$descriptor() {
        return av_size_mult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MethodHandle av_size_mult$handle() {
        return av_size_mult.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static int av_size_mult(long a, long b, MemorySegment r) {
        var mh$ = av_size_mult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_size_mult", a, b, r);
            }
            return (int)mh$.invokeExact(a, b, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_max_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_max_alloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static FunctionDescriptor av_max_alloc$descriptor() {
        return av_max_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MethodHandle av_max_alloc$handle() {
        return av_max_alloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static void av_max_alloc(long max) {
        var mh$ = av_max_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_max_alloc", max);
            }
            mh$.invokeExact(max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = FFmpeg.C_LONG;

    private static class av_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_strerror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static FunctionDescriptor av_strerror$descriptor() {
        return av_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MethodHandle av_strerror$handle() {
        return av_strerror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static int av_strerror(int errnum, MemorySegment errbuf, long errbuf_size) {
        var mh$ = av_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strerror", errnum, errbuf, errbuf_size);
            }
            return (int)mh$.invokeExact(errnum, errbuf, errbuf_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_reduce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static FunctionDescriptor av_reduce$descriptor() {
        return av_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static MethodHandle av_reduce$handle() {
        return av_reduce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static int av_reduce(MemorySegment dst_num, MemorySegment dst_den, long num, long den, long max) {
        var mh$ = av_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reduce", dst_num, dst_den, num, den, max);
            }
            return (int)mh$.invokeExact(dst_num, dst_den, num, den, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mul_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_mul_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_mul_q$descriptor() {
        return av_mul_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_mul_q$handle() {
        return av_mul_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_mul_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_mul_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mul_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_div_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_div_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_div_q$descriptor() {
        return av_div_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_div_q$handle() {
        return av_div_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_div_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_div_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_div_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_add_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_add_q$descriptor() {
        return av_add_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_add_q$handle() {
        return av_add_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_add_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_add_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sub_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_sub_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_sub_q$descriptor() {
        return av_sub_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_sub_q$handle() {
        return av_sub_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_sub_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_sub_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sub_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_d2q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_d2q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static FunctionDescriptor av_d2q$descriptor() {
        return av_d2q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MethodHandle av_d2q$handle() {
        return av_d2q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MemorySegment av_d2q(SegmentAllocator allocator, double d, int max) {
        var mh$ = av_d2q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_d2q", allocator, d, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, d, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_nearer_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_nearer_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static FunctionDescriptor av_nearer_q$descriptor() {
        return av_nearer_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static MethodHandle av_nearer_q$handle() {
        return av_nearer_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static int av_nearer_q(MemorySegment q, MemorySegment q1, MemorySegment q2) {
        var mh$ = av_nearer_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_nearer_q", q, q1, q2);
            }
            return (int)mh$.invokeExact(q, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_nearest_q_idx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_find_nearest_q_idx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static FunctionDescriptor av_find_nearest_q_idx$descriptor() {
        return av_find_nearest_q_idx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static MethodHandle av_find_nearest_q_idx$handle() {
        return av_find_nearest_q_idx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static int av_find_nearest_q_idx(MemorySegment q, MemorySegment q_list) {
        var mh$ = av_find_nearest_q_idx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_nearest_q_idx", q, q_list);
            }
            return (int)mh$.invokeExact(q, q_list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_q2intfloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_q2intfloat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static FunctionDescriptor av_q2intfloat$descriptor() {
        return av_q2intfloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static MethodHandle av_q2intfloat$handle() {
        return av_q2intfloat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static int av_q2intfloat(MemorySegment q) {
        var mh$ = av_q2intfloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_q2intfloat", q);
            }
            return (int)mh$.invokeExact(q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_gcd_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout(),
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_gcd_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static FunctionDescriptor av_gcd_q$descriptor() {
        return av_gcd_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MethodHandle av_gcd_q$handle() {
        return av_gcd_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MemorySegment av_gcd_q(SegmentAllocator allocator, MemorySegment a, MemorySegment b, int max_den, MemorySegment def) {
        var mh$ = av_gcd_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd_q", allocator, a, b, max_den, def);
            }
            return (MemorySegment)mh$.invokeExact(allocator, a, b, max_den, def);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_ROUND_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_ZERO = 0
     * }
     */
    public static int AV_ROUND_ZERO() {
        return AV_ROUND_ZERO;
    }
    private static final int AV_ROUND_INF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_INF = 1
     * }
     */
    public static int AV_ROUND_INF() {
        return AV_ROUND_INF;
    }
    private static final int AV_ROUND_DOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_DOWN = 2
     * }
     */
    public static int AV_ROUND_DOWN() {
        return AV_ROUND_DOWN;
    }
    private static final int AV_ROUND_UP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_UP = 3
     * }
     */
    public static int AV_ROUND_UP() {
        return AV_ROUND_UP;
    }
    private static final int AV_ROUND_NEAR_INF = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_NEAR_INF = 5
     * }
     */
    public static int AV_ROUND_NEAR_INF() {
        return AV_ROUND_NEAR_INF;
    }
    private static final int AV_ROUND_PASS_MINMAX = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_PASS_MINMAX = 8192
     * }
     */
    public static int AV_ROUND_PASS_MINMAX() {
        return AV_ROUND_PASS_MINMAX;
    }

    private static class av_gcd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_gcd"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static FunctionDescriptor av_gcd$descriptor() {
        return av_gcd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static MethodHandle av_gcd$handle() {
        return av_gcd.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static long av_gcd(long a, long b) {
        var mh$ = av_gcd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd", a, b);
            }
            return (long)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_rescale"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static FunctionDescriptor av_rescale$descriptor() {
        return av_rescale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static MethodHandle av_rescale$handle() {
        return av_rescale.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static long av_rescale(long a, long b, long c) {
        var mh$ = av_rescale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale", a, b, c);
            }
            return (long)mh$.invokeExact(a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_rescale_rnd"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_rnd$descriptor() {
        return av_rescale_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_rnd$handle() {
        return av_rescale_rnd.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_rnd(long a, long b, long c, int rnd) {
        var mh$ = av_rescale_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_rnd", a, b, c, rnd);
            }
            return (long)mh$.invokeExact(a, b, c, rnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_rescale_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static FunctionDescriptor av_rescale_q$descriptor() {
        return av_rescale_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static MethodHandle av_rescale_q$handle() {
        return av_rescale_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static long av_rescale_q(long a, MemorySegment bq, MemorySegment cq) {
        var mh$ = av_rescale_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q", a, bq, cq);
            }
            return (long)mh$.invokeExact(a, bq, cq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            AVRational.layout(),
            AVRational.layout(),
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_rescale_q_rnd"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_q_rnd$descriptor() {
        return av_rescale_q_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_q_rnd$handle() {
        return av_rescale_q_rnd.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_q_rnd(long a, MemorySegment bq, MemorySegment cq, int rnd) {
        var mh$ = av_rescale_q_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q_rnd", a, bq, cq, rnd);
            }
            return (long)mh$.invokeExact(a, bq, cq, rnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_ts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG,
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_compare_ts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static FunctionDescriptor av_compare_ts$descriptor() {
        return av_compare_ts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static MethodHandle av_compare_ts$handle() {
        return av_compare_ts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static int av_compare_ts(long ts_a, MemorySegment tb_a, long ts_b, MemorySegment tb_b) {
        var mh$ = av_compare_ts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_ts", ts_a, tb_a, ts_b, tb_b);
            }
            return (int)mh$.invokeExact(ts_a, tb_a, ts_b, tb_b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_mod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_compare_mod"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static FunctionDescriptor av_compare_mod$descriptor() {
        return av_compare_mod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static MethodHandle av_compare_mod$handle() {
        return av_compare_mod.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static long av_compare_mod(long a, long b, long mod) {
        var mh$ = av_compare_mod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_mod", a, b, mod);
            }
            return (long)mh$.invokeExact(a, b, mod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_delta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            AVRational.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_rescale_delta"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static FunctionDescriptor av_rescale_delta$descriptor() {
        return av_rescale_delta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static MethodHandle av_rescale_delta$handle() {
        return av_rescale_delta.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static long av_rescale_delta(MemorySegment in_tb, long in_ts, MemorySegment fs_tb, int duration, MemorySegment last, MemorySegment out_tb) {
        var mh$ = av_rescale_delta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_delta", in_tb, in_ts, fs_tb, duration, last, out_tb);
            }
            return (long)mh$.invokeExact(in_tb, in_ts, fs_tb, duration, last, out_tb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_stable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_add_stable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static FunctionDescriptor av_add_stable$descriptor() {
        return av_add_stable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static MethodHandle av_add_stable$handle() {
        return av_add_stable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static long av_add_stable(MemorySegment ts_tb, long ts, MemorySegment inc_tb, long inc) {
        var mh$ = av_add_stable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_stable", ts_tb, ts, inc_tb, inc);
            }
            return (long)mh$.invokeExact(ts_tb, ts, inc_tb, inc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CLASS_CATEGORY_NA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NA = 0
     * }
     */
    public static int AV_CLASS_CATEGORY_NA() {
        return AV_CLASS_CATEGORY_NA;
    }
    private static final int AV_CLASS_CATEGORY_INPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_INPUT = 1
     * }
     */
    public static int AV_CLASS_CATEGORY_INPUT() {
        return AV_CLASS_CATEGORY_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_OUTPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_OUTPUT = 2
     * }
     */
    public static int AV_CLASS_CATEGORY_OUTPUT() {
        return AV_CLASS_CATEGORY_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_MUXER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_MUXER = 3
     * }
     */
    public static int AV_CLASS_CATEGORY_MUXER() {
        return AV_CLASS_CATEGORY_MUXER;
    }
    private static final int AV_CLASS_CATEGORY_DEMUXER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEMUXER = 4
     * }
     */
    public static int AV_CLASS_CATEGORY_DEMUXER() {
        return AV_CLASS_CATEGORY_DEMUXER;
    }
    private static final int AV_CLASS_CATEGORY_ENCODER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_ENCODER = 5
     * }
     */
    public static int AV_CLASS_CATEGORY_ENCODER() {
        return AV_CLASS_CATEGORY_ENCODER;
    }
    private static final int AV_CLASS_CATEGORY_DECODER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DECODER = 6
     * }
     */
    public static int AV_CLASS_CATEGORY_DECODER() {
        return AV_CLASS_CATEGORY_DECODER;
    }
    private static final int AV_CLASS_CATEGORY_FILTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_FILTER = 7
     * }
     */
    public static int AV_CLASS_CATEGORY_FILTER() {
        return AV_CLASS_CATEGORY_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_BITSTREAM_FILTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8
     * }
     */
    public static int AV_CLASS_CATEGORY_BITSTREAM_FILTER() {
        return AV_CLASS_CATEGORY_BITSTREAM_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_SWSCALER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWSCALER = 9
     * }
     */
    public static int AV_CLASS_CATEGORY_SWSCALER() {
        return AV_CLASS_CATEGORY_SWSCALER;
    }
    private static final int AV_CLASS_CATEGORY_SWRESAMPLER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWRESAMPLER = 10
     * }
     */
    public static int AV_CLASS_CATEGORY_SWRESAMPLER() {
        return AV_CLASS_CATEGORY_SWRESAMPLER;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_OUTPUT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_INPUT = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_INPUT = 45
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_NB = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NB = 46
     * }
     */
    public static int AV_CLASS_CATEGORY_NB() {
        return AV_CLASS_CATEGORY_NB;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log(void *avcl, int level, const char *fmt, ...)
     * }
     */
    public static class av_log {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                FFmpeg.C_POINTER,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log(void *avcl, int level, const char *fmt, ...)
         * }
         */
        public static av_log makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int level, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log", avcl, level, fmt, x3);
                }
                spreader.invokeExact(avcl, level, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
     * }
     */
    public static class av_log_once {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                FFmpeg.C_POINTER,
                FFmpeg.C_INT,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_once");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log_once(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
         * }
         */
        public static av_log_once makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log_once(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int initial_level, int subsequent_level, MemorySegment state, MemorySegment fmt, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log_once", avcl, initial_level, subsequent_level, state, fmt, x5);
                }
                spreader.invokeExact(avcl, initial_level, subsequent_level, state, fmt, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class av_vlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_vlog"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_vlog$descriptor() {
        return av_vlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_vlog$handle() {
        return av_vlog.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_vlog(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_vlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_vlog", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_get_level"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static FunctionDescriptor av_log_get_level$descriptor() {
        return av_log_get_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static MethodHandle av_log_get_level$handle() {
        return av_log_get_level.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static int av_log_get_level() {
        var mh$ = av_log_get_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_level");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_set_level"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static FunctionDescriptor av_log_set_level$descriptor() {
        return av_log_set_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MethodHandle av_log_set_level$handle() {
        return av_log_set_level.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static void av_log_set_level(int level) {
        var mh$ = av_log_set_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_level", level);
            }
            mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_set_callback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, struct __va_list_tag *))
     * }
     */
    public static FunctionDescriptor av_log_set_callback$descriptor() {
        return av_log_set_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, struct __va_list_tag *))
     * }
     */
    public static MethodHandle av_log_set_callback$handle() {
        return av_log_set_callback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, struct __va_list_tag *))
     * }
     */
    public static void av_log_set_callback(MemorySegment callback) {
        var mh$ = av_log_set_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_callback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_default_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_default_callback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_log_default_callback$descriptor() {
        return av_log_default_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_log_default_callback$handle() {
        return av_log_default_callback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_log_default_callback(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_log_default_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_default_callback", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_item_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_default_item_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static FunctionDescriptor av_default_item_name$descriptor() {
        return av_default_item_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MethodHandle av_default_item_name$handle() {
        return av_default_item_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MemorySegment av_default_item_name(MemorySegment ctx) {
        var mh$ = av_default_item_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_item_name", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_get_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_default_get_category"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static FunctionDescriptor av_default_get_category$descriptor() {
        return av_default_get_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static MethodHandle av_default_get_category$handle() {
        return av_default_get_category.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static int av_default_get_category(MemorySegment ptr) {
        var mh$ = av_default_get_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_get_category", ptr);
            }
            return (int)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_format_line"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line$descriptor() {
        return av_log_format_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line$handle() {
        return av_log_format_line.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static void av_log_format_line(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_format_line2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line2$descriptor() {
        return av_log_format_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line2$handle() {
        return av_log_format_line2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static int av_log_format_line2(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line2", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            return (int)mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_set_flags"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static FunctionDescriptor av_log_set_flags$descriptor() {
        return av_log_set_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static MethodHandle av_log_set_flags$handle() {
        return av_log_set_flags.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static void av_log_set_flags(int arg) {
        var mh$ = av_log_set_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_flags", arg);
            }
            mh$.invokeExact(arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_log_get_flags"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static FunctionDescriptor av_log_get_flags$descriptor() {
        return av_log_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static MethodHandle av_log_get_flags$handle() {
        return av_log_get_flags.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static int av_log_get_flags() {
        var mh$ = av_log_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_flags");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PIX_FMT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NONE = -1
     * }
     */
    public static int AV_PIX_FMT_NONE() {
        return AV_PIX_FMT_NONE;
    }
    private static final int AV_PIX_FMT_YUV420P = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P = 0
     * }
     */
    public static int AV_PIX_FMT_YUV420P() {
        return AV_PIX_FMT_YUV420P;
    }
    private static final int AV_PIX_FMT_YUYV422 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUYV422 = 1
     * }
     */
    public static int AV_PIX_FMT_YUYV422() {
        return AV_PIX_FMT_YUYV422;
    }
    private static final int AV_PIX_FMT_RGB24 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB24 = 2
     * }
     */
    public static int AV_PIX_FMT_RGB24() {
        return AV_PIX_FMT_RGB24;
    }
    private static final int AV_PIX_FMT_BGR24 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR24 = 3
     * }
     */
    public static int AV_PIX_FMT_BGR24() {
        return AV_PIX_FMT_BGR24;
    }
    private static final int AV_PIX_FMT_YUV422P = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P = 4
     * }
     */
    public static int AV_PIX_FMT_YUV422P() {
        return AV_PIX_FMT_YUV422P;
    }
    private static final int AV_PIX_FMT_YUV444P = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P = 5
     * }
     */
    public static int AV_PIX_FMT_YUV444P() {
        return AV_PIX_FMT_YUV444P;
    }
    private static final int AV_PIX_FMT_YUV410P = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV410P = 6
     * }
     */
    public static int AV_PIX_FMT_YUV410P() {
        return AV_PIX_FMT_YUV410P;
    }
    private static final int AV_PIX_FMT_YUV411P = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV411P = 7
     * }
     */
    public static int AV_PIX_FMT_YUV411P() {
        return AV_PIX_FMT_YUV411P;
    }
    private static final int AV_PIX_FMT_GRAY8 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8 = 8
     * }
     */
    public static int AV_PIX_FMT_GRAY8() {
        return AV_PIX_FMT_GRAY8;
    }
    private static final int AV_PIX_FMT_MONOWHITE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOWHITE = 9
     * }
     */
    public static int AV_PIX_FMT_MONOWHITE() {
        return AV_PIX_FMT_MONOWHITE;
    }
    private static final int AV_PIX_FMT_MONOBLACK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOBLACK = 10
     * }
     */
    public static int AV_PIX_FMT_MONOBLACK() {
        return AV_PIX_FMT_MONOBLACK;
    }
    private static final int AV_PIX_FMT_PAL8 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_PAL8 = 11
     * }
     */
    public static int AV_PIX_FMT_PAL8() {
        return AV_PIX_FMT_PAL8;
    }
    private static final int AV_PIX_FMT_YUVJ420P = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ420P = 12
     * }
     */
    public static int AV_PIX_FMT_YUVJ420P() {
        return AV_PIX_FMT_YUVJ420P;
    }
    private static final int AV_PIX_FMT_YUVJ422P = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ422P = 13
     * }
     */
    public static int AV_PIX_FMT_YUVJ422P() {
        return AV_PIX_FMT_YUVJ422P;
    }
    private static final int AV_PIX_FMT_YUVJ444P = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ444P = 14
     * }
     */
    public static int AV_PIX_FMT_YUVJ444P() {
        return AV_PIX_FMT_YUVJ444P;
    }
    private static final int AV_PIX_FMT_UYVY422 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYVY422 = 15
     * }
     */
    public static int AV_PIX_FMT_UYVY422() {
        return AV_PIX_FMT_UYVY422;
    }
    private static final int AV_PIX_FMT_UYYVYY411 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYYVYY411 = 16
     * }
     */
    public static int AV_PIX_FMT_UYYVYY411() {
        return AV_PIX_FMT_UYYVYY411;
    }
    private static final int AV_PIX_FMT_BGR8 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR8 = 17
     * }
     */
    public static int AV_PIX_FMT_BGR8() {
        return AV_PIX_FMT_BGR8;
    }
    private static final int AV_PIX_FMT_BGR4 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4 = 18
     * }
     */
    public static int AV_PIX_FMT_BGR4() {
        return AV_PIX_FMT_BGR4;
    }
    private static final int AV_PIX_FMT_BGR4_BYTE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4_BYTE = 19
     * }
     */
    public static int AV_PIX_FMT_BGR4_BYTE() {
        return AV_PIX_FMT_BGR4_BYTE;
    }
    private static final int AV_PIX_FMT_RGB8 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB8 = 20
     * }
     */
    public static int AV_PIX_FMT_RGB8() {
        return AV_PIX_FMT_RGB8;
    }
    private static final int AV_PIX_FMT_RGB4 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4 = 21
     * }
     */
    public static int AV_PIX_FMT_RGB4() {
        return AV_PIX_FMT_RGB4;
    }
    private static final int AV_PIX_FMT_RGB4_BYTE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4_BYTE = 22
     * }
     */
    public static int AV_PIX_FMT_RGB4_BYTE() {
        return AV_PIX_FMT_RGB4_BYTE;
    }
    private static final int AV_PIX_FMT_NV12 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV12 = 23
     * }
     */
    public static int AV_PIX_FMT_NV12() {
        return AV_PIX_FMT_NV12;
    }
    private static final int AV_PIX_FMT_NV21 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV21 = 24
     * }
     */
    public static int AV_PIX_FMT_NV21() {
        return AV_PIX_FMT_NV21;
    }
    private static final int AV_PIX_FMT_ARGB = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ARGB = 25
     * }
     */
    public static int AV_PIX_FMT_ARGB() {
        return AV_PIX_FMT_ARGB;
    }
    private static final int AV_PIX_FMT_RGBA = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA = 26
     * }
     */
    public static int AV_PIX_FMT_RGBA() {
        return AV_PIX_FMT_RGBA;
    }
    private static final int AV_PIX_FMT_ABGR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ABGR = 27
     * }
     */
    public static int AV_PIX_FMT_ABGR() {
        return AV_PIX_FMT_ABGR;
    }
    private static final int AV_PIX_FMT_BGRA = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA = 28
     * }
     */
    public static int AV_PIX_FMT_BGRA() {
        return AV_PIX_FMT_BGRA;
    }
    private static final int AV_PIX_FMT_GRAY16BE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16BE = 29
     * }
     */
    public static int AV_PIX_FMT_GRAY16BE() {
        return AV_PIX_FMT_GRAY16BE;
    }
    private static final int AV_PIX_FMT_GRAY16LE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16LE = 30
     * }
     */
    public static int AV_PIX_FMT_GRAY16LE() {
        return AV_PIX_FMT_GRAY16LE;
    }
    private static final int AV_PIX_FMT_YUV440P = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P = 31
     * }
     */
    public static int AV_PIX_FMT_YUV440P() {
        return AV_PIX_FMT_YUV440P;
    }
    private static final int AV_PIX_FMT_YUVJ440P = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ440P = 32
     * }
     */
    public static int AV_PIX_FMT_YUVJ440P() {
        return AV_PIX_FMT_YUVJ440P;
    }
    private static final int AV_PIX_FMT_YUVA420P = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P = 33
     * }
     */
    public static int AV_PIX_FMT_YUVA420P() {
        return AV_PIX_FMT_YUVA420P;
    }
    private static final int AV_PIX_FMT_RGB48BE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48BE = 34
     * }
     */
    public static int AV_PIX_FMT_RGB48BE() {
        return AV_PIX_FMT_RGB48BE;
    }
    private static final int AV_PIX_FMT_RGB48LE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48LE = 35
     * }
     */
    public static int AV_PIX_FMT_RGB48LE() {
        return AV_PIX_FMT_RGB48LE;
    }
    private static final int AV_PIX_FMT_RGB565BE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565BE = 36
     * }
     */
    public static int AV_PIX_FMT_RGB565BE() {
        return AV_PIX_FMT_RGB565BE;
    }
    private static final int AV_PIX_FMT_RGB565LE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565LE = 37
     * }
     */
    public static int AV_PIX_FMT_RGB565LE() {
        return AV_PIX_FMT_RGB565LE;
    }
    private static final int AV_PIX_FMT_RGB555BE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555BE = 38
     * }
     */
    public static int AV_PIX_FMT_RGB555BE() {
        return AV_PIX_FMT_RGB555BE;
    }
    private static final int AV_PIX_FMT_RGB555LE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555LE = 39
     * }
     */
    public static int AV_PIX_FMT_RGB555LE() {
        return AV_PIX_FMT_RGB555LE;
    }
    private static final int AV_PIX_FMT_BGR565BE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565BE = 40
     * }
     */
    public static int AV_PIX_FMT_BGR565BE() {
        return AV_PIX_FMT_BGR565BE;
    }
    private static final int AV_PIX_FMT_BGR565LE = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565LE = 41
     * }
     */
    public static int AV_PIX_FMT_BGR565LE() {
        return AV_PIX_FMT_BGR565LE;
    }
    private static final int AV_PIX_FMT_BGR555BE = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555BE = 42
     * }
     */
    public static int AV_PIX_FMT_BGR555BE() {
        return AV_PIX_FMT_BGR555BE;
    }
    private static final int AV_PIX_FMT_BGR555LE = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555LE = 43
     * }
     */
    public static int AV_PIX_FMT_BGR555LE() {
        return AV_PIX_FMT_BGR555LE;
    }
    private static final int AV_PIX_FMT_VAAPI = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VAAPI = 44
     * }
     */
    public static int AV_PIX_FMT_VAAPI() {
        return AV_PIX_FMT_VAAPI;
    }
    private static final int AV_PIX_FMT_YUV420P16LE = (int)45L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16LE = 45
     * }
     */
    public static int AV_PIX_FMT_YUV420P16LE() {
        return AV_PIX_FMT_YUV420P16LE;
    }
    private static final int AV_PIX_FMT_YUV420P16BE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16BE = 46
     * }
     */
    public static int AV_PIX_FMT_YUV420P16BE() {
        return AV_PIX_FMT_YUV420P16BE;
    }
    private static final int AV_PIX_FMT_YUV422P16LE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16LE = 47
     * }
     */
    public static int AV_PIX_FMT_YUV422P16LE() {
        return AV_PIX_FMT_YUV422P16LE;
    }
    private static final int AV_PIX_FMT_YUV422P16BE = (int)48L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16BE = 48
     * }
     */
    public static int AV_PIX_FMT_YUV422P16BE() {
        return AV_PIX_FMT_YUV422P16BE;
    }
    private static final int AV_PIX_FMT_YUV444P16LE = (int)49L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16LE = 49
     * }
     */
    public static int AV_PIX_FMT_YUV444P16LE() {
        return AV_PIX_FMT_YUV444P16LE;
    }
    private static final int AV_PIX_FMT_YUV444P16BE = (int)50L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16BE = 50
     * }
     */
    public static int AV_PIX_FMT_YUV444P16BE() {
        return AV_PIX_FMT_YUV444P16BE;
    }
    private static final int AV_PIX_FMT_DXVA2_VLD = (int)51L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DXVA2_VLD = 51
     * }
     */
    public static int AV_PIX_FMT_DXVA2_VLD() {
        return AV_PIX_FMT_DXVA2_VLD;
    }
    private static final int AV_PIX_FMT_RGB444LE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444LE = 52
     * }
     */
    public static int AV_PIX_FMT_RGB444LE() {
        return AV_PIX_FMT_RGB444LE;
    }
    private static final int AV_PIX_FMT_RGB444BE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444BE = 53
     * }
     */
    public static int AV_PIX_FMT_RGB444BE() {
        return AV_PIX_FMT_RGB444BE;
    }
    private static final int AV_PIX_FMT_BGR444LE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444LE = 54
     * }
     */
    public static int AV_PIX_FMT_BGR444LE() {
        return AV_PIX_FMT_BGR444LE;
    }
    private static final int AV_PIX_FMT_BGR444BE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444BE = 55
     * }
     */
    public static int AV_PIX_FMT_BGR444BE() {
        return AV_PIX_FMT_BGR444BE;
    }
    private static final int AV_PIX_FMT_YA8 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA8 = 56
     * }
     */
    public static int AV_PIX_FMT_YA8() {
        return AV_PIX_FMT_YA8;
    }
    private static final int AV_PIX_FMT_Y400A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y400A = 56
     * }
     */
    public static int AV_PIX_FMT_Y400A() {
        return AV_PIX_FMT_Y400A;
    }
    private static final int AV_PIX_FMT_GRAY8A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8A = 56
     * }
     */
    public static int AV_PIX_FMT_GRAY8A() {
        return AV_PIX_FMT_GRAY8A;
    }
    private static final int AV_PIX_FMT_BGR48BE = (int)57L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48BE = 57
     * }
     */
    public static int AV_PIX_FMT_BGR48BE() {
        return AV_PIX_FMT_BGR48BE;
    }
    private static final int AV_PIX_FMT_BGR48LE = (int)58L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48LE = 58
     * }
     */
    public static int AV_PIX_FMT_BGR48LE() {
        return AV_PIX_FMT_BGR48LE;
    }
    private static final int AV_PIX_FMT_YUV420P9BE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9BE = 59
     * }
     */
    public static int AV_PIX_FMT_YUV420P9BE() {
        return AV_PIX_FMT_YUV420P9BE;
    }
    private static final int AV_PIX_FMT_YUV420P9LE = (int)60L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9LE = 60
     * }
     */
    public static int AV_PIX_FMT_YUV420P9LE() {
        return AV_PIX_FMT_YUV420P9LE;
    }
    private static final int AV_PIX_FMT_YUV420P10BE = (int)61L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10BE = 61
     * }
     */
    public static int AV_PIX_FMT_YUV420P10BE() {
        return AV_PIX_FMT_YUV420P10BE;
    }
    private static final int AV_PIX_FMT_YUV420P10LE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10LE = 62
     * }
     */
    public static int AV_PIX_FMT_YUV420P10LE() {
        return AV_PIX_FMT_YUV420P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P10BE = (int)63L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10BE = 63
     * }
     */
    public static int AV_PIX_FMT_YUV422P10BE() {
        return AV_PIX_FMT_YUV422P10BE;
    }
    private static final int AV_PIX_FMT_YUV422P10LE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10LE = 64
     * }
     */
    public static int AV_PIX_FMT_YUV422P10LE() {
        return AV_PIX_FMT_YUV422P10LE;
    }
    private static final int AV_PIX_FMT_YUV444P9BE = (int)65L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9BE = 65
     * }
     */
    public static int AV_PIX_FMT_YUV444P9BE() {
        return AV_PIX_FMT_YUV444P9BE;
    }
    private static final int AV_PIX_FMT_YUV444P9LE = (int)66L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9LE = 66
     * }
     */
    public static int AV_PIX_FMT_YUV444P9LE() {
        return AV_PIX_FMT_YUV444P9LE;
    }
    private static final int AV_PIX_FMT_YUV444P10BE = (int)67L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10BE = 67
     * }
     */
    public static int AV_PIX_FMT_YUV444P10BE() {
        return AV_PIX_FMT_YUV444P10BE;
    }
    private static final int AV_PIX_FMT_YUV444P10LE = (int)68L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10LE = 68
     * }
     */
    public static int AV_PIX_FMT_YUV444P10LE() {
        return AV_PIX_FMT_YUV444P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P9BE = (int)69L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9BE = 69
     * }
     */
    public static int AV_PIX_FMT_YUV422P9BE() {
        return AV_PIX_FMT_YUV422P9BE;
    }
    private static final int AV_PIX_FMT_YUV422P9LE = (int)70L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9LE = 70
     * }
     */
    public static int AV_PIX_FMT_YUV422P9LE() {
        return AV_PIX_FMT_YUV422P9LE;
    }
    private static final int AV_PIX_FMT_GBRP = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP = 71
     * }
     */
    public static int AV_PIX_FMT_GBRP() {
        return AV_PIX_FMT_GBRP;
    }
    private static final int AV_PIX_FMT_GBR24P = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBR24P = 71
     * }
     */
    public static int AV_PIX_FMT_GBR24P() {
        return AV_PIX_FMT_GBR24P;
    }
    private static final int AV_PIX_FMT_GBRP9BE = (int)72L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9BE = 72
     * }
     */
    public static int AV_PIX_FMT_GBRP9BE() {
        return AV_PIX_FMT_GBRP9BE;
    }
    private static final int AV_PIX_FMT_GBRP9LE = (int)73L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9LE = 73
     * }
     */
    public static int AV_PIX_FMT_GBRP9LE() {
        return AV_PIX_FMT_GBRP9LE;
    }
    private static final int AV_PIX_FMT_GBRP10BE = (int)74L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10BE = 74
     * }
     */
    public static int AV_PIX_FMT_GBRP10BE() {
        return AV_PIX_FMT_GBRP10BE;
    }
    private static final int AV_PIX_FMT_GBRP10LE = (int)75L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10LE = 75
     * }
     */
    public static int AV_PIX_FMT_GBRP10LE() {
        return AV_PIX_FMT_GBRP10LE;
    }
    private static final int AV_PIX_FMT_GBRP16BE = (int)76L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16BE = 76
     * }
     */
    public static int AV_PIX_FMT_GBRP16BE() {
        return AV_PIX_FMT_GBRP16BE;
    }
    private static final int AV_PIX_FMT_GBRP16LE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16LE = 77
     * }
     */
    public static int AV_PIX_FMT_GBRP16LE() {
        return AV_PIX_FMT_GBRP16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P = (int)78L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P = 78
     * }
     */
    public static int AV_PIX_FMT_YUVA422P() {
        return AV_PIX_FMT_YUVA422P;
    }
    private static final int AV_PIX_FMT_YUVA444P = (int)79L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P = 79
     * }
     */
    public static int AV_PIX_FMT_YUVA444P() {
        return AV_PIX_FMT_YUVA444P;
    }
    private static final int AV_PIX_FMT_YUVA420P9BE = (int)80L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9BE = 80
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9BE() {
        return AV_PIX_FMT_YUVA420P9BE;
    }
    private static final int AV_PIX_FMT_YUVA420P9LE = (int)81L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9LE = 81
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9LE() {
        return AV_PIX_FMT_YUVA420P9LE;
    }
    private static final int AV_PIX_FMT_YUVA422P9BE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9BE = 82
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9BE() {
        return AV_PIX_FMT_YUVA422P9BE;
    }
    private static final int AV_PIX_FMT_YUVA422P9LE = (int)83L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9LE = 83
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9LE() {
        return AV_PIX_FMT_YUVA422P9LE;
    }
    private static final int AV_PIX_FMT_YUVA444P9BE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9BE = 84
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9BE() {
        return AV_PIX_FMT_YUVA444P9BE;
    }
    private static final int AV_PIX_FMT_YUVA444P9LE = (int)85L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9LE = 85
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9LE() {
        return AV_PIX_FMT_YUVA444P9LE;
    }
    private static final int AV_PIX_FMT_YUVA420P10BE = (int)86L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10BE = 86
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10BE() {
        return AV_PIX_FMT_YUVA420P10BE;
    }
    private static final int AV_PIX_FMT_YUVA420P10LE = (int)87L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10LE = 87
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10LE() {
        return AV_PIX_FMT_YUVA420P10LE;
    }
    private static final int AV_PIX_FMT_YUVA422P10BE = (int)88L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10BE = 88
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10BE() {
        return AV_PIX_FMT_YUVA422P10BE;
    }
    private static final int AV_PIX_FMT_YUVA422P10LE = (int)89L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10LE = 89
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10LE() {
        return AV_PIX_FMT_YUVA422P10LE;
    }
    private static final int AV_PIX_FMT_YUVA444P10BE = (int)90L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10BE = 90
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10BE() {
        return AV_PIX_FMT_YUVA444P10BE;
    }
    private static final int AV_PIX_FMT_YUVA444P10LE = (int)91L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10LE = 91
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10LE() {
        return AV_PIX_FMT_YUVA444P10LE;
    }
    private static final int AV_PIX_FMT_YUVA420P16BE = (int)92L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16BE = 92
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16BE() {
        return AV_PIX_FMT_YUVA420P16BE;
    }
    private static final int AV_PIX_FMT_YUVA420P16LE = (int)93L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16LE = 93
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16LE() {
        return AV_PIX_FMT_YUVA420P16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P16BE = (int)94L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16BE = 94
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16BE() {
        return AV_PIX_FMT_YUVA422P16BE;
    }
    private static final int AV_PIX_FMT_YUVA422P16LE = (int)95L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16LE = 95
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16LE() {
        return AV_PIX_FMT_YUVA422P16LE;
    }
    private static final int AV_PIX_FMT_YUVA444P16BE = (int)96L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16BE = 96
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16BE() {
        return AV_PIX_FMT_YUVA444P16BE;
    }
    private static final int AV_PIX_FMT_YUVA444P16LE = (int)97L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16LE = 97
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16LE() {
        return AV_PIX_FMT_YUVA444P16LE;
    }
    private static final int AV_PIX_FMT_VDPAU = (int)98L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VDPAU = 98
     * }
     */
    public static int AV_PIX_FMT_VDPAU() {
        return AV_PIX_FMT_VDPAU;
    }
    private static final int AV_PIX_FMT_XYZ12LE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12LE = 99
     * }
     */
    public static int AV_PIX_FMT_XYZ12LE() {
        return AV_PIX_FMT_XYZ12LE;
    }
    private static final int AV_PIX_FMT_XYZ12BE = (int)100L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12BE = 100
     * }
     */
    public static int AV_PIX_FMT_XYZ12BE() {
        return AV_PIX_FMT_XYZ12BE;
    }
    private static final int AV_PIX_FMT_NV16 = (int)101L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV16 = 101
     * }
     */
    public static int AV_PIX_FMT_NV16() {
        return AV_PIX_FMT_NV16;
    }
    private static final int AV_PIX_FMT_NV20LE = (int)102L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20LE = 102
     * }
     */
    public static int AV_PIX_FMT_NV20LE() {
        return AV_PIX_FMT_NV20LE;
    }
    private static final int AV_PIX_FMT_NV20BE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20BE = 103
     * }
     */
    public static int AV_PIX_FMT_NV20BE() {
        return AV_PIX_FMT_NV20BE;
    }
    private static final int AV_PIX_FMT_RGBA64BE = (int)104L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64BE = 104
     * }
     */
    public static int AV_PIX_FMT_RGBA64BE() {
        return AV_PIX_FMT_RGBA64BE;
    }
    private static final int AV_PIX_FMT_RGBA64LE = (int)105L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64LE = 105
     * }
     */
    public static int AV_PIX_FMT_RGBA64LE() {
        return AV_PIX_FMT_RGBA64LE;
    }
    private static final int AV_PIX_FMT_BGRA64BE = (int)106L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64BE = 106
     * }
     */
    public static int AV_PIX_FMT_BGRA64BE() {
        return AV_PIX_FMT_BGRA64BE;
    }
    private static final int AV_PIX_FMT_BGRA64LE = (int)107L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64LE = 107
     * }
     */
    public static int AV_PIX_FMT_BGRA64LE() {
        return AV_PIX_FMT_BGRA64LE;
    }
    private static final int AV_PIX_FMT_YVYU422 = (int)108L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YVYU422 = 108
     * }
     */
    public static int AV_PIX_FMT_YVYU422() {
        return AV_PIX_FMT_YVYU422;
    }
    private static final int AV_PIX_FMT_YA16BE = (int)109L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16BE = 109
     * }
     */
    public static int AV_PIX_FMT_YA16BE() {
        return AV_PIX_FMT_YA16BE;
    }
    private static final int AV_PIX_FMT_YA16LE = (int)110L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16LE = 110
     * }
     */
    public static int AV_PIX_FMT_YA16LE() {
        return AV_PIX_FMT_YA16LE;
    }
    private static final int AV_PIX_FMT_GBRAP = (int)111L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP = 111
     * }
     */
    public static int AV_PIX_FMT_GBRAP() {
        return AV_PIX_FMT_GBRAP;
    }
    private static final int AV_PIX_FMT_GBRAP16BE = (int)112L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16BE = 112
     * }
     */
    public static int AV_PIX_FMT_GBRAP16BE() {
        return AV_PIX_FMT_GBRAP16BE;
    }
    private static final int AV_PIX_FMT_GBRAP16LE = (int)113L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16LE = 113
     * }
     */
    public static int AV_PIX_FMT_GBRAP16LE() {
        return AV_PIX_FMT_GBRAP16LE;
    }
    private static final int AV_PIX_FMT_QSV = (int)114L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_QSV = 114
     * }
     */
    public static int AV_PIX_FMT_QSV() {
        return AV_PIX_FMT_QSV;
    }
    private static final int AV_PIX_FMT_MMAL = (int)115L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MMAL = 115
     * }
     */
    public static int AV_PIX_FMT_MMAL() {
        return AV_PIX_FMT_MMAL;
    }
    private static final int AV_PIX_FMT_D3D11VA_VLD = (int)116L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11VA_VLD = 116
     * }
     */
    public static int AV_PIX_FMT_D3D11VA_VLD() {
        return AV_PIX_FMT_D3D11VA_VLD;
    }
    private static final int AV_PIX_FMT_CUDA = (int)117L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_CUDA = 117
     * }
     */
    public static int AV_PIX_FMT_CUDA() {
        return AV_PIX_FMT_CUDA;
    }
    private static final int AV_PIX_FMT_0RGB = (int)118L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0RGB = 118
     * }
     */
    public static int AV_PIX_FMT_0RGB() {
        return AV_PIX_FMT_0RGB;
    }
    private static final int AV_PIX_FMT_RGB0 = (int)119L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB0 = 119
     * }
     */
    public static int AV_PIX_FMT_RGB0() {
        return AV_PIX_FMT_RGB0;
    }
    private static final int AV_PIX_FMT_0BGR = (int)120L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0BGR = 120
     * }
     */
    public static int AV_PIX_FMT_0BGR() {
        return AV_PIX_FMT_0BGR;
    }
    private static final int AV_PIX_FMT_BGR0 = (int)121L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR0 = 121
     * }
     */
    public static int AV_PIX_FMT_BGR0() {
        return AV_PIX_FMT_BGR0;
    }
    private static final int AV_PIX_FMT_YUV420P12BE = (int)122L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12BE = 122
     * }
     */
    public static int AV_PIX_FMT_YUV420P12BE() {
        return AV_PIX_FMT_YUV420P12BE;
    }
    private static final int AV_PIX_FMT_YUV420P12LE = (int)123L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12LE = 123
     * }
     */
    public static int AV_PIX_FMT_YUV420P12LE() {
        return AV_PIX_FMT_YUV420P12LE;
    }
    private static final int AV_PIX_FMT_YUV420P14BE = (int)124L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14BE = 124
     * }
     */
    public static int AV_PIX_FMT_YUV420P14BE() {
        return AV_PIX_FMT_YUV420P14BE;
    }
    private static final int AV_PIX_FMT_YUV420P14LE = (int)125L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14LE = 125
     * }
     */
    public static int AV_PIX_FMT_YUV420P14LE() {
        return AV_PIX_FMT_YUV420P14LE;
    }
    private static final int AV_PIX_FMT_YUV422P12BE = (int)126L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12BE = 126
     * }
     */
    public static int AV_PIX_FMT_YUV422P12BE() {
        return AV_PIX_FMT_YUV422P12BE;
    }
    private static final int AV_PIX_FMT_YUV422P12LE = (int)127L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12LE = 127
     * }
     */
    public static int AV_PIX_FMT_YUV422P12LE() {
        return AV_PIX_FMT_YUV422P12LE;
    }
    private static final int AV_PIX_FMT_YUV422P14BE = (int)128L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14BE = 128
     * }
     */
    public static int AV_PIX_FMT_YUV422P14BE() {
        return AV_PIX_FMT_YUV422P14BE;
    }
    private static final int AV_PIX_FMT_YUV422P14LE = (int)129L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14LE = 129
     * }
     */
    public static int AV_PIX_FMT_YUV422P14LE() {
        return AV_PIX_FMT_YUV422P14LE;
    }
    private static final int AV_PIX_FMT_YUV444P12BE = (int)130L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12BE = 130
     * }
     */
    public static int AV_PIX_FMT_YUV444P12BE() {
        return AV_PIX_FMT_YUV444P12BE;
    }
    private static final int AV_PIX_FMT_YUV444P12LE = (int)131L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12LE = 131
     * }
     */
    public static int AV_PIX_FMT_YUV444P12LE() {
        return AV_PIX_FMT_YUV444P12LE;
    }
    private static final int AV_PIX_FMT_YUV444P14BE = (int)132L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14BE = 132
     * }
     */
    public static int AV_PIX_FMT_YUV444P14BE() {
        return AV_PIX_FMT_YUV444P14BE;
    }
    private static final int AV_PIX_FMT_YUV444P14LE = (int)133L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14LE = 133
     * }
     */
    public static int AV_PIX_FMT_YUV444P14LE() {
        return AV_PIX_FMT_YUV444P14LE;
    }
    private static final int AV_PIX_FMT_GBRP12BE = (int)134L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12BE = 134
     * }
     */
    public static int AV_PIX_FMT_GBRP12BE() {
        return AV_PIX_FMT_GBRP12BE;
    }
    private static final int AV_PIX_FMT_GBRP12LE = (int)135L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12LE = 135
     * }
     */
    public static int AV_PIX_FMT_GBRP12LE() {
        return AV_PIX_FMT_GBRP12LE;
    }
    private static final int AV_PIX_FMT_GBRP14BE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14BE = 136
     * }
     */
    public static int AV_PIX_FMT_GBRP14BE() {
        return AV_PIX_FMT_GBRP14BE;
    }
    private static final int AV_PIX_FMT_GBRP14LE = (int)137L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14LE = 137
     * }
     */
    public static int AV_PIX_FMT_GBRP14LE() {
        return AV_PIX_FMT_GBRP14LE;
    }
    private static final int AV_PIX_FMT_YUVJ411P = (int)138L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ411P = 138
     * }
     */
    public static int AV_PIX_FMT_YUVJ411P() {
        return AV_PIX_FMT_YUVJ411P;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR8 = (int)139L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR8 = 139
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR8() {
        return AV_PIX_FMT_BAYER_BGGR8;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB8 = (int)140L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB8 = 140
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB8() {
        return AV_PIX_FMT_BAYER_RGGB8;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG8 = (int)141L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG8 = 141
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG8() {
        return AV_PIX_FMT_BAYER_GBRG8;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG8 = (int)142L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG8 = 142
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG8() {
        return AV_PIX_FMT_BAYER_GRBG8;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16LE = (int)143L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16LE = 143
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16LE() {
        return AV_PIX_FMT_BAYER_BGGR16LE;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16BE = (int)144L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16BE = 144
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16BE() {
        return AV_PIX_FMT_BAYER_BGGR16BE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16LE = (int)145L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16LE = 145
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16LE() {
        return AV_PIX_FMT_BAYER_RGGB16LE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16BE = (int)146L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16BE = 146
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16BE() {
        return AV_PIX_FMT_BAYER_RGGB16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16LE = (int)147L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16LE = 147
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16LE() {
        return AV_PIX_FMT_BAYER_GBRG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16BE = (int)148L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16BE = 148
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16BE() {
        return AV_PIX_FMT_BAYER_GBRG16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16LE = (int)149L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16LE = 149
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16LE() {
        return AV_PIX_FMT_BAYER_GRBG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16BE = (int)150L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16BE = 150
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16BE() {
        return AV_PIX_FMT_BAYER_GRBG16BE;
    }
    private static final int AV_PIX_FMT_XVMC = (int)151L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XVMC = 151
     * }
     */
    public static int AV_PIX_FMT_XVMC() {
        return AV_PIX_FMT_XVMC;
    }
    private static final int AV_PIX_FMT_YUV440P10LE = (int)152L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10LE = 152
     * }
     */
    public static int AV_PIX_FMT_YUV440P10LE() {
        return AV_PIX_FMT_YUV440P10LE;
    }
    private static final int AV_PIX_FMT_YUV440P10BE = (int)153L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10BE = 153
     * }
     */
    public static int AV_PIX_FMT_YUV440P10BE() {
        return AV_PIX_FMT_YUV440P10BE;
    }
    private static final int AV_PIX_FMT_YUV440P12LE = (int)154L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12LE = 154
     * }
     */
    public static int AV_PIX_FMT_YUV440P12LE() {
        return AV_PIX_FMT_YUV440P12LE;
    }
    private static final int AV_PIX_FMT_YUV440P12BE = (int)155L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12BE = 155
     * }
     */
    public static int AV_PIX_FMT_YUV440P12BE() {
        return AV_PIX_FMT_YUV440P12BE;
    }
    private static final int AV_PIX_FMT_AYUV64LE = (int)156L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64LE = 156
     * }
     */
    public static int AV_PIX_FMT_AYUV64LE() {
        return AV_PIX_FMT_AYUV64LE;
    }
    private static final int AV_PIX_FMT_AYUV64BE = (int)157L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64BE = 157
     * }
     */
    public static int AV_PIX_FMT_AYUV64BE() {
        return AV_PIX_FMT_AYUV64BE;
    }
    private static final int AV_PIX_FMT_VIDEOTOOLBOX = (int)158L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VIDEOTOOLBOX = 158
     * }
     */
    public static int AV_PIX_FMT_VIDEOTOOLBOX() {
        return AV_PIX_FMT_VIDEOTOOLBOX;
    }
    private static final int AV_PIX_FMT_P010LE = (int)159L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010LE = 159
     * }
     */
    public static int AV_PIX_FMT_P010LE() {
        return AV_PIX_FMT_P010LE;
    }
    private static final int AV_PIX_FMT_P010BE = (int)160L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010BE = 160
     * }
     */
    public static int AV_PIX_FMT_P010BE() {
        return AV_PIX_FMT_P010BE;
    }
    private static final int AV_PIX_FMT_GBRAP12BE = (int)161L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12BE = 161
     * }
     */
    public static int AV_PIX_FMT_GBRAP12BE() {
        return AV_PIX_FMT_GBRAP12BE;
    }
    private static final int AV_PIX_FMT_GBRAP12LE = (int)162L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12LE = 162
     * }
     */
    public static int AV_PIX_FMT_GBRAP12LE() {
        return AV_PIX_FMT_GBRAP12LE;
    }
    private static final int AV_PIX_FMT_GBRAP10BE = (int)163L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10BE = 163
     * }
     */
    public static int AV_PIX_FMT_GBRAP10BE() {
        return AV_PIX_FMT_GBRAP10BE;
    }
    private static final int AV_PIX_FMT_GBRAP10LE = (int)164L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10LE = 164
     * }
     */
    public static int AV_PIX_FMT_GBRAP10LE() {
        return AV_PIX_FMT_GBRAP10LE;
    }
    private static final int AV_PIX_FMT_MEDIACODEC = (int)165L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MEDIACODEC = 165
     * }
     */
    public static int AV_PIX_FMT_MEDIACODEC() {
        return AV_PIX_FMT_MEDIACODEC;
    }
    private static final int AV_PIX_FMT_GRAY12BE = (int)166L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12BE = 166
     * }
     */
    public static int AV_PIX_FMT_GRAY12BE() {
        return AV_PIX_FMT_GRAY12BE;
    }
    private static final int AV_PIX_FMT_GRAY12LE = (int)167L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12LE = 167
     * }
     */
    public static int AV_PIX_FMT_GRAY12LE() {
        return AV_PIX_FMT_GRAY12LE;
    }
    private static final int AV_PIX_FMT_GRAY10BE = (int)168L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10BE = 168
     * }
     */
    public static int AV_PIX_FMT_GRAY10BE() {
        return AV_PIX_FMT_GRAY10BE;
    }
    private static final int AV_PIX_FMT_GRAY10LE = (int)169L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10LE = 169
     * }
     */
    public static int AV_PIX_FMT_GRAY10LE() {
        return AV_PIX_FMT_GRAY10LE;
    }
    private static final int AV_PIX_FMT_P016LE = (int)170L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016LE = 170
     * }
     */
    public static int AV_PIX_FMT_P016LE() {
        return AV_PIX_FMT_P016LE;
    }
    private static final int AV_PIX_FMT_P016BE = (int)171L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016BE = 171
     * }
     */
    public static int AV_PIX_FMT_P016BE() {
        return AV_PIX_FMT_P016BE;
    }
    private static final int AV_PIX_FMT_D3D11 = (int)172L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11 = 172
     * }
     */
    public static int AV_PIX_FMT_D3D11() {
        return AV_PIX_FMT_D3D11;
    }
    private static final int AV_PIX_FMT_GRAY9BE = (int)173L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9BE = 173
     * }
     */
    public static int AV_PIX_FMT_GRAY9BE() {
        return AV_PIX_FMT_GRAY9BE;
    }
    private static final int AV_PIX_FMT_GRAY9LE = (int)174L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9LE = 174
     * }
     */
    public static int AV_PIX_FMT_GRAY9LE() {
        return AV_PIX_FMT_GRAY9LE;
    }
    private static final int AV_PIX_FMT_GBRPF32BE = (int)175L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32BE = 175
     * }
     */
    public static int AV_PIX_FMT_GBRPF32BE() {
        return AV_PIX_FMT_GBRPF32BE;
    }
    private static final int AV_PIX_FMT_GBRPF32LE = (int)176L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32LE = 176
     * }
     */
    public static int AV_PIX_FMT_GBRPF32LE() {
        return AV_PIX_FMT_GBRPF32LE;
    }
    private static final int AV_PIX_FMT_GBRAPF32BE = (int)177L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32BE = 177
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32BE() {
        return AV_PIX_FMT_GBRAPF32BE;
    }
    private static final int AV_PIX_FMT_GBRAPF32LE = (int)178L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32LE = 178
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32LE() {
        return AV_PIX_FMT_GBRAPF32LE;
    }
    private static final int AV_PIX_FMT_DRM_PRIME = (int)179L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DRM_PRIME = 179
     * }
     */
    public static int AV_PIX_FMT_DRM_PRIME() {
        return AV_PIX_FMT_DRM_PRIME;
    }
    private static final int AV_PIX_FMT_OPENCL = (int)180L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_OPENCL = 180
     * }
     */
    public static int AV_PIX_FMT_OPENCL() {
        return AV_PIX_FMT_OPENCL;
    }
    private static final int AV_PIX_FMT_GRAY14BE = (int)181L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14BE = 181
     * }
     */
    public static int AV_PIX_FMT_GRAY14BE() {
        return AV_PIX_FMT_GRAY14BE;
    }
    private static final int AV_PIX_FMT_GRAY14LE = (int)182L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14LE = 182
     * }
     */
    public static int AV_PIX_FMT_GRAY14LE() {
        return AV_PIX_FMT_GRAY14LE;
    }
    private static final int AV_PIX_FMT_GRAYF32BE = (int)183L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32BE = 183
     * }
     */
    public static int AV_PIX_FMT_GRAYF32BE() {
        return AV_PIX_FMT_GRAYF32BE;
    }
    private static final int AV_PIX_FMT_GRAYF32LE = (int)184L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32LE = 184
     * }
     */
    public static int AV_PIX_FMT_GRAYF32LE() {
        return AV_PIX_FMT_GRAYF32LE;
    }
    private static final int AV_PIX_FMT_YUVA422P12BE = (int)185L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12BE = 185
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12BE() {
        return AV_PIX_FMT_YUVA422P12BE;
    }
    private static final int AV_PIX_FMT_YUVA422P12LE = (int)186L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12LE = 186
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12LE() {
        return AV_PIX_FMT_YUVA422P12LE;
    }
    private static final int AV_PIX_FMT_YUVA444P12BE = (int)187L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12BE = 187
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12BE() {
        return AV_PIX_FMT_YUVA444P12BE;
    }
    private static final int AV_PIX_FMT_YUVA444P12LE = (int)188L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12LE = 188
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12LE() {
        return AV_PIX_FMT_YUVA444P12LE;
    }
    private static final int AV_PIX_FMT_NV24 = (int)189L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV24 = 189
     * }
     */
    public static int AV_PIX_FMT_NV24() {
        return AV_PIX_FMT_NV24;
    }
    private static final int AV_PIX_FMT_NV42 = (int)190L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV42 = 190
     * }
     */
    public static int AV_PIX_FMT_NV42() {
        return AV_PIX_FMT_NV42;
    }
    private static final int AV_PIX_FMT_VULKAN = (int)191L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VULKAN = 191
     * }
     */
    public static int AV_PIX_FMT_VULKAN() {
        return AV_PIX_FMT_VULKAN;
    }
    private static final int AV_PIX_FMT_Y210BE = (int)192L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210BE = 192
     * }
     */
    public static int AV_PIX_FMT_Y210BE() {
        return AV_PIX_FMT_Y210BE;
    }
    private static final int AV_PIX_FMT_Y210LE = (int)193L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210LE = 193
     * }
     */
    public static int AV_PIX_FMT_Y210LE() {
        return AV_PIX_FMT_Y210LE;
    }
    private static final int AV_PIX_FMT_X2RGB10LE = (int)194L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10LE = 194
     * }
     */
    public static int AV_PIX_FMT_X2RGB10LE() {
        return AV_PIX_FMT_X2RGB10LE;
    }
    private static final int AV_PIX_FMT_X2RGB10BE = (int)195L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10BE = 195
     * }
     */
    public static int AV_PIX_FMT_X2RGB10BE() {
        return AV_PIX_FMT_X2RGB10BE;
    }
    private static final int AV_PIX_FMT_X2BGR10LE = (int)196L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10LE = 196
     * }
     */
    public static int AV_PIX_FMT_X2BGR10LE() {
        return AV_PIX_FMT_X2BGR10LE;
    }
    private static final int AV_PIX_FMT_X2BGR10BE = (int)197L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10BE = 197
     * }
     */
    public static int AV_PIX_FMT_X2BGR10BE() {
        return AV_PIX_FMT_X2BGR10BE;
    }
    private static final int AV_PIX_FMT_P210BE = (int)198L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210BE = 198
     * }
     */
    public static int AV_PIX_FMT_P210BE() {
        return AV_PIX_FMT_P210BE;
    }
    private static final int AV_PIX_FMT_P210LE = (int)199L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210LE = 199
     * }
     */
    public static int AV_PIX_FMT_P210LE() {
        return AV_PIX_FMT_P210LE;
    }
    private static final int AV_PIX_FMT_P410BE = (int)200L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410BE = 200
     * }
     */
    public static int AV_PIX_FMT_P410BE() {
        return AV_PIX_FMT_P410BE;
    }
    private static final int AV_PIX_FMT_P410LE = (int)201L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410LE = 201
     * }
     */
    public static int AV_PIX_FMT_P410LE() {
        return AV_PIX_FMT_P410LE;
    }
    private static final int AV_PIX_FMT_P216BE = (int)202L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216BE = 202
     * }
     */
    public static int AV_PIX_FMT_P216BE() {
        return AV_PIX_FMT_P216BE;
    }
    private static final int AV_PIX_FMT_P216LE = (int)203L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216LE = 203
     * }
     */
    public static int AV_PIX_FMT_P216LE() {
        return AV_PIX_FMT_P216LE;
    }
    private static final int AV_PIX_FMT_P416BE = (int)204L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416BE = 204
     * }
     */
    public static int AV_PIX_FMT_P416BE() {
        return AV_PIX_FMT_P416BE;
    }
    private static final int AV_PIX_FMT_P416LE = (int)205L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416LE = 205
     * }
     */
    public static int AV_PIX_FMT_P416LE() {
        return AV_PIX_FMT_P416LE;
    }
    private static final int AV_PIX_FMT_VUYA = (int)206L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYA = 206
     * }
     */
    public static int AV_PIX_FMT_VUYA() {
        return AV_PIX_FMT_VUYA;
    }
    private static final int AV_PIX_FMT_RGBAF16BE = (int)207L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16BE = 207
     * }
     */
    public static int AV_PIX_FMT_RGBAF16BE() {
        return AV_PIX_FMT_RGBAF16BE;
    }
    private static final int AV_PIX_FMT_RGBAF16LE = (int)208L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16LE = 208
     * }
     */
    public static int AV_PIX_FMT_RGBAF16LE() {
        return AV_PIX_FMT_RGBAF16LE;
    }
    private static final int AV_PIX_FMT_VUYX = (int)209L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYX = 209
     * }
     */
    public static int AV_PIX_FMT_VUYX() {
        return AV_PIX_FMT_VUYX;
    }
    private static final int AV_PIX_FMT_P012LE = (int)210L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012LE = 210
     * }
     */
    public static int AV_PIX_FMT_P012LE() {
        return AV_PIX_FMT_P012LE;
    }
    private static final int AV_PIX_FMT_P012BE = (int)211L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012BE = 211
     * }
     */
    public static int AV_PIX_FMT_P012BE() {
        return AV_PIX_FMT_P012BE;
    }
    private static final int AV_PIX_FMT_Y212BE = (int)212L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212BE = 212
     * }
     */
    public static int AV_PIX_FMT_Y212BE() {
        return AV_PIX_FMT_Y212BE;
    }
    private static final int AV_PIX_FMT_Y212LE = (int)213L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212LE = 213
     * }
     */
    public static int AV_PIX_FMT_Y212LE() {
        return AV_PIX_FMT_Y212LE;
    }
    private static final int AV_PIX_FMT_XV30BE = (int)214L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30BE = 214
     * }
     */
    public static int AV_PIX_FMT_XV30BE() {
        return AV_PIX_FMT_XV30BE;
    }
    private static final int AV_PIX_FMT_XV30LE = (int)215L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30LE = 215
     * }
     */
    public static int AV_PIX_FMT_XV30LE() {
        return AV_PIX_FMT_XV30LE;
    }
    private static final int AV_PIX_FMT_XV36BE = (int)216L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36BE = 216
     * }
     */
    public static int AV_PIX_FMT_XV36BE() {
        return AV_PIX_FMT_XV36BE;
    }
    private static final int AV_PIX_FMT_XV36LE = (int)217L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36LE = 217
     * }
     */
    public static int AV_PIX_FMT_XV36LE() {
        return AV_PIX_FMT_XV36LE;
    }
    private static final int AV_PIX_FMT_RGBF32BE = (int)218L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32BE = 218
     * }
     */
    public static int AV_PIX_FMT_RGBF32BE() {
        return AV_PIX_FMT_RGBF32BE;
    }
    private static final int AV_PIX_FMT_RGBF32LE = (int)219L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32LE = 219
     * }
     */
    public static int AV_PIX_FMT_RGBF32LE() {
        return AV_PIX_FMT_RGBF32LE;
    }
    private static final int AV_PIX_FMT_RGBAF32BE = (int)220L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32BE = 220
     * }
     */
    public static int AV_PIX_FMT_RGBAF32BE() {
        return AV_PIX_FMT_RGBAF32BE;
    }
    private static final int AV_PIX_FMT_RGBAF32LE = (int)221L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32LE = 221
     * }
     */
    public static int AV_PIX_FMT_RGBAF32LE() {
        return AV_PIX_FMT_RGBAF32LE;
    }
    private static final int AV_PIX_FMT_NB = (int)222L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NB = 222
     * }
     */
    public static int AV_PIX_FMT_NB() {
        return AV_PIX_FMT_NB;
    }
    private static final int AVCOL_PRI_RESERVED0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_RESERVED0 = 0
     * }
     */
    public static int AVCOL_PRI_RESERVED0() {
        return AVCOL_PRI_RESERVED0;
    }
    private static final int AVCOL_PRI_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT709 = 1
     * }
     */
    public static int AVCOL_PRI_BT709() {
        return AVCOL_PRI_BT709;
    }
    private static final int AVCOL_PRI_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_PRI_UNSPECIFIED() {
        return AVCOL_PRI_UNSPECIFIED;
    }
    private static final int AVCOL_PRI_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_RESERVED = 3
     * }
     */
    public static int AVCOL_PRI_RESERVED() {
        return AVCOL_PRI_RESERVED;
    }
    private static final int AVCOL_PRI_BT470M = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT470M = 4
     * }
     */
    public static int AVCOL_PRI_BT470M() {
        return AVCOL_PRI_BT470M;
    }
    private static final int AVCOL_PRI_BT470BG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT470BG = 5
     * }
     */
    public static int AVCOL_PRI_BT470BG() {
        return AVCOL_PRI_BT470BG;
    }
    private static final int AVCOL_PRI_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE170M = 6
     * }
     */
    public static int AVCOL_PRI_SMPTE170M() {
        return AVCOL_PRI_SMPTE170M;
    }
    private static final int AVCOL_PRI_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE240M = 7
     * }
     */
    public static int AVCOL_PRI_SMPTE240M() {
        return AVCOL_PRI_SMPTE240M;
    }
    private static final int AVCOL_PRI_FILM = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_FILM = 8
     * }
     */
    public static int AVCOL_PRI_FILM() {
        return AVCOL_PRI_FILM;
    }
    private static final int AVCOL_PRI_BT2020 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT2020 = 9
     * }
     */
    public static int AVCOL_PRI_BT2020() {
        return AVCOL_PRI_BT2020;
    }
    private static final int AVCOL_PRI_SMPTE428 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE428 = 10
     * }
     */
    public static int AVCOL_PRI_SMPTE428() {
        return AVCOL_PRI_SMPTE428;
    }
    private static final int AVCOL_PRI_SMPTEST428_1 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTEST428_1 = 10
     * }
     */
    public static int AVCOL_PRI_SMPTEST428_1() {
        return AVCOL_PRI_SMPTEST428_1;
    }
    private static final int AVCOL_PRI_SMPTE431 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE431 = 11
     * }
     */
    public static int AVCOL_PRI_SMPTE431() {
        return AVCOL_PRI_SMPTE431;
    }
    private static final int AVCOL_PRI_SMPTE432 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE432 = 12
     * }
     */
    public static int AVCOL_PRI_SMPTE432() {
        return AVCOL_PRI_SMPTE432;
    }
    private static final int AVCOL_PRI_EBU3213 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_EBU3213 = 22
     * }
     */
    public static int AVCOL_PRI_EBU3213() {
        return AVCOL_PRI_EBU3213;
    }
    private static final int AVCOL_PRI_JEDEC_P22 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_JEDEC_P22 = 22
     * }
     */
    public static int AVCOL_PRI_JEDEC_P22() {
        return AVCOL_PRI_JEDEC_P22;
    }
    private static final int AVCOL_PRI_NB = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_NB = 23
     * }
     */
    public static int AVCOL_PRI_NB() {
        return AVCOL_PRI_NB;
    }
    private static final int AVCOL_TRC_RESERVED0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_RESERVED0 = 0
     * }
     */
    public static int AVCOL_TRC_RESERVED0() {
        return AVCOL_TRC_RESERVED0;
    }
    private static final int AVCOL_TRC_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT709 = 1
     * }
     */
    public static int AVCOL_TRC_BT709() {
        return AVCOL_TRC_BT709;
    }
    private static final int AVCOL_TRC_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_TRC_UNSPECIFIED() {
        return AVCOL_TRC_UNSPECIFIED;
    }
    private static final int AVCOL_TRC_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_RESERVED = 3
     * }
     */
    public static int AVCOL_TRC_RESERVED() {
        return AVCOL_TRC_RESERVED;
    }
    private static final int AVCOL_TRC_GAMMA22 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 = 4
     * }
     */
    public static int AVCOL_TRC_GAMMA22() {
        return AVCOL_TRC_GAMMA22;
    }
    private static final int AVCOL_TRC_GAMMA28 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 = 5
     * }
     */
    public static int AVCOL_TRC_GAMMA28() {
        return AVCOL_TRC_GAMMA28;
    }
    private static final int AVCOL_TRC_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M = 6
     * }
     */
    public static int AVCOL_TRC_SMPTE170M() {
        return AVCOL_TRC_SMPTE170M;
    }
    private static final int AVCOL_TRC_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M = 7
     * }
     */
    public static int AVCOL_TRC_SMPTE240M() {
        return AVCOL_TRC_SMPTE240M;
    }
    private static final int AVCOL_TRC_LINEAR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LINEAR = 8
     * }
     */
    public static int AVCOL_TRC_LINEAR() {
        return AVCOL_TRC_LINEAR;
    }
    private static final int AVCOL_TRC_LOG = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LOG = 9
     * }
     */
    public static int AVCOL_TRC_LOG() {
        return AVCOL_TRC_LOG;
    }
    private static final int AVCOL_TRC_LOG_SQRT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT = 10
     * }
     */
    public static int AVCOL_TRC_LOG_SQRT() {
        return AVCOL_TRC_LOG_SQRT;
    }
    private static final int AVCOL_TRC_IEC61966_2_4 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 = 11
     * }
     */
    public static int AVCOL_TRC_IEC61966_2_4() {
        return AVCOL_TRC_IEC61966_2_4;
    }
    private static final int AVCOL_TRC_BT1361_ECG = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG = 12
     * }
     */
    public static int AVCOL_TRC_BT1361_ECG() {
        return AVCOL_TRC_BT1361_ECG;
    }
    private static final int AVCOL_TRC_IEC61966_2_1 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 = 13
     * }
     */
    public static int AVCOL_TRC_IEC61966_2_1() {
        return AVCOL_TRC_IEC61966_2_1;
    }
    private static final int AVCOL_TRC_BT2020_10 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 = 14
     * }
     */
    public static int AVCOL_TRC_BT2020_10() {
        return AVCOL_TRC_BT2020_10;
    }
    private static final int AVCOL_TRC_BT2020_12 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 = 15
     * }
     */
    public static int AVCOL_TRC_BT2020_12() {
        return AVCOL_TRC_BT2020_12;
    }
    private static final int AVCOL_TRC_SMPTE2084 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 = 16
     * }
     */
    public static int AVCOL_TRC_SMPTE2084() {
        return AVCOL_TRC_SMPTE2084;
    }
    private static final int AVCOL_TRC_SMPTEST2084 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST2084 = 16
     * }
     */
    public static int AVCOL_TRC_SMPTEST2084() {
        return AVCOL_TRC_SMPTEST2084;
    }
    private static final int AVCOL_TRC_SMPTE428 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE428 = 17
     * }
     */
    public static int AVCOL_TRC_SMPTE428() {
        return AVCOL_TRC_SMPTE428;
    }
    private static final int AVCOL_TRC_SMPTEST428_1 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST428_1 = 17
     * }
     */
    public static int AVCOL_TRC_SMPTEST428_1() {
        return AVCOL_TRC_SMPTEST428_1;
    }
    private static final int AVCOL_TRC_ARIB_STD_B67 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 = 18
     * }
     */
    public static int AVCOL_TRC_ARIB_STD_B67() {
        return AVCOL_TRC_ARIB_STD_B67;
    }
    private static final int AVCOL_TRC_NB = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_NB = 19
     * }
     */
    public static int AVCOL_TRC_NB() {
        return AVCOL_TRC_NB;
    }
    private static final int AVCOL_SPC_RGB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_RGB = 0
     * }
     */
    public static int AVCOL_SPC_RGB() {
        return AVCOL_SPC_RGB;
    }
    private static final int AVCOL_SPC_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT709 = 1
     * }
     */
    public static int AVCOL_SPC_BT709() {
        return AVCOL_SPC_BT709;
    }
    private static final int AVCOL_SPC_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_SPC_UNSPECIFIED() {
        return AVCOL_SPC_UNSPECIFIED;
    }
    private static final int AVCOL_SPC_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_RESERVED = 3
     * }
     */
    public static int AVCOL_SPC_RESERVED() {
        return AVCOL_SPC_RESERVED;
    }
    private static final int AVCOL_SPC_FCC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_FCC = 4
     * }
     */
    public static int AVCOL_SPC_FCC() {
        return AVCOL_SPC_FCC;
    }
    private static final int AVCOL_SPC_BT470BG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT470BG = 5
     * }
     */
    public static int AVCOL_SPC_BT470BG() {
        return AVCOL_SPC_BT470BG;
    }
    private static final int AVCOL_SPC_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE170M = 6
     * }
     */
    public static int AVCOL_SPC_SMPTE170M() {
        return AVCOL_SPC_SMPTE170M;
    }
    private static final int AVCOL_SPC_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE240M = 7
     * }
     */
    public static int AVCOL_SPC_SMPTE240M() {
        return AVCOL_SPC_SMPTE240M;
    }
    private static final int AVCOL_SPC_YCGCO = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCGCO = 8
     * }
     */
    public static int AVCOL_SPC_YCGCO() {
        return AVCOL_SPC_YCGCO;
    }
    private static final int AVCOL_SPC_YCOCG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCOCG = 8
     * }
     */
    public static int AVCOL_SPC_YCOCG() {
        return AVCOL_SPC_YCOCG;
    }
    private static final int AVCOL_SPC_BT2020_NCL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT2020_NCL = 9
     * }
     */
    public static int AVCOL_SPC_BT2020_NCL() {
        return AVCOL_SPC_BT2020_NCL;
    }
    private static final int AVCOL_SPC_BT2020_CL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT2020_CL = 10
     * }
     */
    public static int AVCOL_SPC_BT2020_CL() {
        return AVCOL_SPC_BT2020_CL;
    }
    private static final int AVCOL_SPC_SMPTE2085 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE2085 = 11
     * }
     */
    public static int AVCOL_SPC_SMPTE2085() {
        return AVCOL_SPC_SMPTE2085;
    }
    private static final int AVCOL_SPC_CHROMA_DERIVED_NCL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_NCL = 12
     * }
     */
    public static int AVCOL_SPC_CHROMA_DERIVED_NCL() {
        return AVCOL_SPC_CHROMA_DERIVED_NCL;
    }
    private static final int AVCOL_SPC_CHROMA_DERIVED_CL = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_CL = 13
     * }
     */
    public static int AVCOL_SPC_CHROMA_DERIVED_CL() {
        return AVCOL_SPC_CHROMA_DERIVED_CL;
    }
    private static final int AVCOL_SPC_ICTCP = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_ICTCP = 14
     * }
     */
    public static int AVCOL_SPC_ICTCP() {
        return AVCOL_SPC_ICTCP;
    }
    private static final int AVCOL_SPC_NB = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_NB = 15
     * }
     */
    public static int AVCOL_SPC_NB() {
        return AVCOL_SPC_NB;
    }
    private static final int AVCOL_RANGE_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_UNSPECIFIED = 0
     * }
     */
    public static int AVCOL_RANGE_UNSPECIFIED() {
        return AVCOL_RANGE_UNSPECIFIED;
    }
    private static final int AVCOL_RANGE_MPEG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_MPEG = 1
     * }
     */
    public static int AVCOL_RANGE_MPEG() {
        return AVCOL_RANGE_MPEG;
    }
    private static final int AVCOL_RANGE_JPEG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_JPEG = 2
     * }
     */
    public static int AVCOL_RANGE_JPEG() {
        return AVCOL_RANGE_JPEG;
    }
    private static final int AVCOL_RANGE_NB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_NB = 3
     * }
     */
    public static int AVCOL_RANGE_NB() {
        return AVCOL_RANGE_NB;
    }
    private static final int AVCHROMA_LOC_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED = 0
     * }
     */
    public static int AVCHROMA_LOC_UNSPECIFIED() {
        return AVCHROMA_LOC_UNSPECIFIED;
    }
    private static final int AVCHROMA_LOC_LEFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_LEFT = 1
     * }
     */
    public static int AVCHROMA_LOC_LEFT() {
        return AVCHROMA_LOC_LEFT;
    }
    private static final int AVCHROMA_LOC_CENTER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_CENTER = 2
     * }
     */
    public static int AVCHROMA_LOC_CENTER() {
        return AVCHROMA_LOC_CENTER;
    }
    private static final int AVCHROMA_LOC_TOPLEFT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_TOPLEFT = 3
     * }
     */
    public static int AVCHROMA_LOC_TOPLEFT() {
        return AVCHROMA_LOC_TOPLEFT;
    }
    private static final int AVCHROMA_LOC_TOP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_TOP = 4
     * }
     */
    public static int AVCHROMA_LOC_TOP() {
        return AVCHROMA_LOC_TOP;
    }
    private static final int AVCHROMA_LOC_BOTTOMLEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_BOTTOMLEFT = 5
     * }
     */
    public static int AVCHROMA_LOC_BOTTOMLEFT() {
        return AVCHROMA_LOC_BOTTOMLEFT;
    }
    private static final int AVCHROMA_LOC_BOTTOM = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_BOTTOM = 6
     * }
     */
    public static int AVCHROMA_LOC_BOTTOM() {
        return AVCHROMA_LOC_BOTTOM;
    }
    private static final int AVCHROMA_LOC_NB = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_NB = 7
     * }
     */
    public static int AVCHROMA_LOC_NB() {
        return AVCHROMA_LOC_NB;
    }

    private static class av_int_list_length_for_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_int_list_length_for_size"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static FunctionDescriptor av_int_list_length_for_size$descriptor() {
        return av_int_list_length_for_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static MethodHandle av_int_list_length_for_size$handle() {
        return av_int_list_length_for_size.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static int av_int_list_length_for_size(int elsize, MemorySegment list, long term) {
        var mh$ = av_int_list_length_for_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_int_list_length_for_size", elsize, list, term);
            }
            return (int)mh$.invokeExact(elsize, list, term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fopen_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_fopen_utf8"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *av_fopen_utf8(const char *path, const char *mode)
     * }
     */
    public static FunctionDescriptor av_fopen_utf8$descriptor() {
        return av_fopen_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *av_fopen_utf8(const char *path, const char *mode)
     * }
     */
    public static MethodHandle av_fopen_utf8$handle() {
        return av_fopen_utf8.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *av_fopen_utf8(const char *path, const char *mode)
     * }
     */
    public static MemorySegment av_fopen_utf8(MemorySegment path, MemorySegment mode) {
        var mh$ = av_fopen_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fopen_utf8", path, mode);
            }
            return (MemorySegment)mh$.invokeExact(path, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_time_base_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout()    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_time_base_q"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static FunctionDescriptor av_get_time_base_q$descriptor() {
        return av_get_time_base_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MethodHandle av_get_time_base_q$handle() {
        return av_get_time_base_q.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MemorySegment av_get_time_base_q(SegmentAllocator allocator) {
        var mh$ = av_get_time_base_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_time_base_q", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fourcc_make_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_fourcc_make_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static FunctionDescriptor av_fourcc_make_string$descriptor() {
        return av_fourcc_make_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MethodHandle av_fourcc_make_string$handle() {
        return av_fourcc_make_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MemorySegment av_fourcc_make_string(MemorySegment buf, int fourcc) {
        var mh$ = av_fourcc_make_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fourcc_make_string", buf, fourcc);
            }
            return (MemorySegment)mh$.invokeExact(buf, fourcc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_alloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_alloc$descriptor() {
        return av_buffer_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MethodHandle av_buffer_alloc$handle() {
        return av_buffer_alloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MemorySegment av_buffer_alloc(long size) {
        var mh$ = av_buffer_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_alloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_allocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_allocz"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_allocz$descriptor() {
        return av_buffer_allocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MethodHandle av_buffer_allocz$handle() {
        return av_buffer_allocz.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MemorySegment av_buffer_allocz(long size) {
        var mh$ = av_buffer_allocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_allocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_create"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static FunctionDescriptor av_buffer_create$descriptor() {
        return av_buffer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MethodHandle av_buffer_create$handle() {
        return av_buffer_create.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MemorySegment av_buffer_create(MemorySegment data, long size, MemorySegment free, MemorySegment opaque, int flags) {
        var mh$ = av_buffer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_create", data, size, free, opaque, flags);
            }
            return (MemorySegment)mh$.invokeExact(data, size, free, opaque, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_default_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_default_free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static FunctionDescriptor av_buffer_default_free$descriptor() {
        return av_buffer_default_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static MethodHandle av_buffer_default_free$handle() {
        return av_buffer_default_free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static void av_buffer_default_free(MemorySegment opaque, MemorySegment data) {
        var mh$ = av_buffer_default_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_default_free", opaque, data);
            }
            mh$.invokeExact(opaque, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_ref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_ref$descriptor() {
        return av_buffer_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_ref$handle() {
        return av_buffer_ref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_ref(MemorySegment buf) {
        var mh$ = av_buffer_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_ref", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_unref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static FunctionDescriptor av_buffer_unref$descriptor() {
        return av_buffer_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static MethodHandle av_buffer_unref$handle() {
        return av_buffer_unref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static void av_buffer_unref(MemorySegment buf) {
        var mh$ = av_buffer_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_unref", buf);
            }
            mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_is_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_is_writable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_is_writable$descriptor() {
        return av_buffer_is_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_is_writable$handle() {
        return av_buffer_is_writable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static int av_buffer_is_writable(MemorySegment buf) {
        var mh$ = av_buffer_is_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_is_writable", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_get_opaque {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_get_opaque"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_get_opaque$descriptor() {
        return av_buffer_get_opaque.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_get_opaque$handle() {
        return av_buffer_get_opaque.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_get_opaque(MemorySegment buf) {
        var mh$ = av_buffer_get_opaque.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_get_opaque", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_get_ref_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_get_ref_count"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_get_ref_count$descriptor() {
        return av_buffer_get_ref_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_get_ref_count$handle() {
        return av_buffer_get_ref_count.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static int av_buffer_get_ref_count(MemorySegment buf) {
        var mh$ = av_buffer_get_ref_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_get_ref_count", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_make_writable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static FunctionDescriptor av_buffer_make_writable$descriptor() {
        return av_buffer_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static MethodHandle av_buffer_make_writable$handle() {
        return av_buffer_make_writable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static int av_buffer_make_writable(MemorySegment buf) {
        var mh$ = av_buffer_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_make_writable", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_realloc$descriptor() {
        return av_buffer_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static MethodHandle av_buffer_realloc$handle() {
        return av_buffer_realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static int av_buffer_realloc(MemorySegment buf, long size) {
        var mh$ = av_buffer_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_realloc", buf, size);
            }
            return (int)mh$.invokeExact(buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_replace"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static FunctionDescriptor av_buffer_replace$descriptor() {
        return av_buffer_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static MethodHandle av_buffer_replace$handle() {
        return av_buffer_replace.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static int av_buffer_replace(MemorySegment dst, MemorySegment src) {
        var mh$ = av_buffer_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_replace", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_pool_init"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static FunctionDescriptor av_buffer_pool_init$descriptor() {
        return av_buffer_pool_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MethodHandle av_buffer_pool_init$handle() {
        return av_buffer_pool_init.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MemorySegment av_buffer_pool_init(long size, MemorySegment alloc) {
        var mh$ = av_buffer_pool_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_init", size, alloc);
            }
            return (MemorySegment)mh$.invokeExact(size, alloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_init2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_pool_init2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static FunctionDescriptor av_buffer_pool_init2$descriptor() {
        return av_buffer_pool_init2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MethodHandle av_buffer_pool_init2$handle() {
        return av_buffer_pool_init2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MemorySegment av_buffer_pool_init2(long size, MemorySegment opaque, MemorySegment alloc, MemorySegment pool_free) {
        var mh$ = av_buffer_pool_init2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_init2", size, opaque, alloc, pool_free);
            }
            return (MemorySegment)mh$.invokeExact(size, opaque, alloc, pool_free);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_uninit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_pool_uninit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_uninit$descriptor() {
        return av_buffer_pool_uninit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static MethodHandle av_buffer_pool_uninit$handle() {
        return av_buffer_pool_uninit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static void av_buffer_pool_uninit(MemorySegment pool) {
        var mh$ = av_buffer_pool_uninit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_uninit", pool);
            }
            mh$.invokeExact(pool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_pool_get"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_get$descriptor() {
        return av_buffer_pool_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MethodHandle av_buffer_pool_get$handle() {
        return av_buffer_pool_get.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MemorySegment av_buffer_pool_get(MemorySegment pool) {
        var mh$ = av_buffer_pool_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_get", pool);
            }
            return (MemorySegment)mh$.invokeExact(pool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_buffer_get_opaque {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_buffer_pool_buffer_get_opaque"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_buffer_get_opaque$descriptor() {
        return av_buffer_pool_buffer_get_opaque.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MethodHandle av_buffer_pool_buffer_get_opaque$handle() {
        return av_buffer_pool_buffer_get_opaque.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_buffer_pool_buffer_get_opaque(MemorySegment ref) {
        var mh$ = av_buffer_pool_buffer_get_opaque.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_buffer_get_opaque", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_get"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_get$descriptor() {
        return av_dict_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)
     * }
     */
    public static MethodHandle av_dict_get$handle() {
        return av_dict_get.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)
     * }
     */
    public static MemorySegment av_dict_get(MemorySegment m, MemorySegment key, MemorySegment prev, int flags) {
        var mh$ = av_dict_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_get", m, key, prev, flags);
            }
            return (MemorySegment)mh$.invokeExact(m, key, prev, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_iterate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m, const AVDictionaryEntry *prev)
     * }
     */
    public static FunctionDescriptor av_dict_iterate$descriptor() {
        return av_dict_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m, const AVDictionaryEntry *prev)
     * }
     */
    public static MethodHandle av_dict_iterate$handle() {
        return av_dict_iterate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m, const AVDictionaryEntry *prev)
     * }
     */
    public static MemorySegment av_dict_iterate(MemorySegment m, MemorySegment prev) {
        var mh$ = av_dict_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_iterate", m, prev);
            }
            return (MemorySegment)mh$.invokeExact(m, prev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_count"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_count(const AVDictionary *m)
     * }
     */
    public static FunctionDescriptor av_dict_count$descriptor() {
        return av_dict_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_count(const AVDictionary *m)
     * }
     */
    public static MethodHandle av_dict_count$handle() {
        return av_dict_count.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_dict_count(const AVDictionary *m)
     * }
     */
    public static int av_dict_count(MemorySegment m) {
        var mh$ = av_dict_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_count", m);
            }
            return (int)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_set"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_set$descriptor() {
        return av_dict_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)
     * }
     */
    public static MethodHandle av_dict_set$handle() {
        return av_dict_set.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)
     * }
     */
    public static int av_dict_set(MemorySegment pm, MemorySegment key, MemorySegment value, int flags) {
        var mh$ = av_dict_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_set", pm, key, value, flags);
            }
            return (int)mh$.invokeExact(pm, key, value, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_set_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_set_int"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_set_int$descriptor() {
        return av_dict_set_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags)
     * }
     */
    public static MethodHandle av_dict_set_int$handle() {
        return av_dict_set_int.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags)
     * }
     */
    public static int av_dict_set_int(MemorySegment pm, MemorySegment key, long value, int flags) {
        var mh$ = av_dict_set_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_set_int", pm, key, value, flags);
            }
            return (int)mh$.invokeExact(pm, key, value, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_parse_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_parse_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_parse_string(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_parse_string$descriptor() {
        return av_dict_parse_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_parse_string(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)
     * }
     */
    public static MethodHandle av_dict_parse_string$handle() {
        return av_dict_parse_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_dict_parse_string(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)
     * }
     */
    public static int av_dict_parse_string(MemorySegment pm, MemorySegment str, MemorySegment key_val_sep, MemorySegment pairs_sep, int flags) {
        var mh$ = av_dict_parse_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_parse_string", pm, str, key_val_sep, pairs_sep, flags);
            }
            return (int)mh$.invokeExact(pm, str, key_val_sep, pairs_sep, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_copy$descriptor() {
        return av_dict_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
     * }
     */
    public static MethodHandle av_dict_copy$handle() {
        return av_dict_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
     * }
     */
    public static int av_dict_copy(MemorySegment dst, MemorySegment src, int flags) {
        var mh$ = av_dict_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_copy", dst, src, flags);
            }
            return (int)mh$.invokeExact(dst, src, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dict_free(AVDictionary **m)
     * }
     */
    public static FunctionDescriptor av_dict_free$descriptor() {
        return av_dict_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dict_free(AVDictionary **m)
     * }
     */
    public static MethodHandle av_dict_free$handle() {
        return av_dict_free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_dict_free(AVDictionary **m)
     * }
     */
    public static void av_dict_free(MemorySegment m) {
        var mh$ = av_dict_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_free", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_CHAR,
            FFmpeg.C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_dict_get_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)
     * }
     */
    public static FunctionDescriptor av_dict_get_string$descriptor() {
        return av_dict_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)
     * }
     */
    public static MethodHandle av_dict_get_string$handle() {
        return av_dict_get_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)
     * }
     */
    public static int av_dict_get_string(MemorySegment m, MemorySegment buffer, byte key_val_sep, byte pairs_sep) {
        var mh$ = av_dict_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_get_string", m, buffer, key_val_sep, pairs_sep);
            }
            return (int)mh$.invokeExact(m, buffer, key_val_sep, pairs_sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CHAN_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_NONE = -1
     * }
     */
    public static int AV_CHAN_NONE() {
        return AV_CHAN_NONE;
    }
    private static final int AV_CHAN_FRONT_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_LEFT = 0
     * }
     */
    public static int AV_CHAN_FRONT_LEFT() {
        return AV_CHAN_FRONT_LEFT;
    }
    private static final int AV_CHAN_FRONT_RIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_RIGHT = 1
     * }
     */
    public static int AV_CHAN_FRONT_RIGHT() {
        return AV_CHAN_FRONT_RIGHT;
    }
    private static final int AV_CHAN_FRONT_CENTER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_CENTER = 2
     * }
     */
    public static int AV_CHAN_FRONT_CENTER() {
        return AV_CHAN_FRONT_CENTER;
    }
    private static final int AV_CHAN_LOW_FREQUENCY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_LOW_FREQUENCY = 3
     * }
     */
    public static int AV_CHAN_LOW_FREQUENCY() {
        return AV_CHAN_LOW_FREQUENCY;
    }
    private static final int AV_CHAN_BACK_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_LEFT = 4
     * }
     */
    public static int AV_CHAN_BACK_LEFT() {
        return AV_CHAN_BACK_LEFT;
    }
    private static final int AV_CHAN_BACK_RIGHT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_RIGHT = 5
     * }
     */
    public static int AV_CHAN_BACK_RIGHT() {
        return AV_CHAN_BACK_RIGHT;
    }
    private static final int AV_CHAN_FRONT_LEFT_OF_CENTER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_LEFT_OF_CENTER = 6
     * }
     */
    public static int AV_CHAN_FRONT_LEFT_OF_CENTER() {
        return AV_CHAN_FRONT_LEFT_OF_CENTER;
    }
    private static final int AV_CHAN_FRONT_RIGHT_OF_CENTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_RIGHT_OF_CENTER = 7
     * }
     */
    public static int AV_CHAN_FRONT_RIGHT_OF_CENTER() {
        return AV_CHAN_FRONT_RIGHT_OF_CENTER;
    }
    private static final int AV_CHAN_BACK_CENTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_CENTER = 8
     * }
     */
    public static int AV_CHAN_BACK_CENTER() {
        return AV_CHAN_BACK_CENTER;
    }
    private static final int AV_CHAN_SIDE_LEFT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_LEFT = 9
     * }
     */
    public static int AV_CHAN_SIDE_LEFT() {
        return AV_CHAN_SIDE_LEFT;
    }
    private static final int AV_CHAN_SIDE_RIGHT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_RIGHT = 10
     * }
     */
    public static int AV_CHAN_SIDE_RIGHT() {
        return AV_CHAN_SIDE_RIGHT;
    }
    private static final int AV_CHAN_TOP_CENTER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_CENTER = 11
     * }
     */
    public static int AV_CHAN_TOP_CENTER() {
        return AV_CHAN_TOP_CENTER;
    }
    private static final int AV_CHAN_TOP_FRONT_LEFT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_LEFT = 12
     * }
     */
    public static int AV_CHAN_TOP_FRONT_LEFT() {
        return AV_CHAN_TOP_FRONT_LEFT;
    }
    private static final int AV_CHAN_TOP_FRONT_CENTER = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_CENTER = 13
     * }
     */
    public static int AV_CHAN_TOP_FRONT_CENTER() {
        return AV_CHAN_TOP_FRONT_CENTER;
    }
    private static final int AV_CHAN_TOP_FRONT_RIGHT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_RIGHT = 14
     * }
     */
    public static int AV_CHAN_TOP_FRONT_RIGHT() {
        return AV_CHAN_TOP_FRONT_RIGHT;
    }
    private static final int AV_CHAN_TOP_BACK_LEFT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_LEFT = 15
     * }
     */
    public static int AV_CHAN_TOP_BACK_LEFT() {
        return AV_CHAN_TOP_BACK_LEFT;
    }
    private static final int AV_CHAN_TOP_BACK_CENTER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_CENTER = 16
     * }
     */
    public static int AV_CHAN_TOP_BACK_CENTER() {
        return AV_CHAN_TOP_BACK_CENTER;
    }
    private static final int AV_CHAN_TOP_BACK_RIGHT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_RIGHT = 17
     * }
     */
    public static int AV_CHAN_TOP_BACK_RIGHT() {
        return AV_CHAN_TOP_BACK_RIGHT;
    }
    private static final int AV_CHAN_STEREO_LEFT = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_STEREO_LEFT = 29
     * }
     */
    public static int AV_CHAN_STEREO_LEFT() {
        return AV_CHAN_STEREO_LEFT;
    }
    private static final int AV_CHAN_STEREO_RIGHT = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_STEREO_RIGHT = 30
     * }
     */
    public static int AV_CHAN_STEREO_RIGHT() {
        return AV_CHAN_STEREO_RIGHT;
    }
    private static final int AV_CHAN_WIDE_LEFT = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_WIDE_LEFT = 31
     * }
     */
    public static int AV_CHAN_WIDE_LEFT() {
        return AV_CHAN_WIDE_LEFT;
    }
    private static final int AV_CHAN_WIDE_RIGHT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_WIDE_RIGHT = 32
     * }
     */
    public static int AV_CHAN_WIDE_RIGHT() {
        return AV_CHAN_WIDE_RIGHT;
    }
    private static final int AV_CHAN_SURROUND_DIRECT_LEFT = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SURROUND_DIRECT_LEFT = 33
     * }
     */
    public static int AV_CHAN_SURROUND_DIRECT_LEFT() {
        return AV_CHAN_SURROUND_DIRECT_LEFT;
    }
    private static final int AV_CHAN_SURROUND_DIRECT_RIGHT = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SURROUND_DIRECT_RIGHT = 34
     * }
     */
    public static int AV_CHAN_SURROUND_DIRECT_RIGHT() {
        return AV_CHAN_SURROUND_DIRECT_RIGHT;
    }
    private static final int AV_CHAN_LOW_FREQUENCY_2 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_LOW_FREQUENCY_2 = 35
     * }
     */
    public static int AV_CHAN_LOW_FREQUENCY_2() {
        return AV_CHAN_LOW_FREQUENCY_2;
    }
    private static final int AV_CHAN_TOP_SIDE_LEFT = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SIDE_LEFT = 36
     * }
     */
    public static int AV_CHAN_TOP_SIDE_LEFT() {
        return AV_CHAN_TOP_SIDE_LEFT;
    }
    private static final int AV_CHAN_TOP_SIDE_RIGHT = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SIDE_RIGHT = 37
     * }
     */
    public static int AV_CHAN_TOP_SIDE_RIGHT() {
        return AV_CHAN_TOP_SIDE_RIGHT;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_CENTER = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_CENTER = 38
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_CENTER() {
        return AV_CHAN_BOTTOM_FRONT_CENTER;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_LEFT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_LEFT = 39
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_LEFT() {
        return AV_CHAN_BOTTOM_FRONT_LEFT;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_RIGHT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_RIGHT = 40
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_RIGHT() {
        return AV_CHAN_BOTTOM_FRONT_RIGHT;
    }
    private static final int AV_CHAN_UNUSED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_UNUSED = 512
     * }
     */
    public static int AV_CHAN_UNUSED() {
        return AV_CHAN_UNUSED;
    }
    private static final int AV_CHAN_UNKNOWN = (int)768L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_UNKNOWN = 768
     * }
     */
    public static int AV_CHAN_UNKNOWN() {
        return AV_CHAN_UNKNOWN;
    }
    private static final int AV_CHAN_AMBISONIC_BASE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_AMBISONIC_BASE = 1024
     * }
     */
    public static int AV_CHAN_AMBISONIC_BASE() {
        return AV_CHAN_AMBISONIC_BASE;
    }
    private static final int AV_CHAN_AMBISONIC_END = (int)2047L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_AMBISONIC_END = 2047
     * }
     */
    public static int AV_CHAN_AMBISONIC_END() {
        return AV_CHAN_AMBISONIC_END;
    }
    private static final int AV_CHANNEL_ORDER_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC = 0
     * }
     */
    public static int AV_CHANNEL_ORDER_UNSPEC() {
        return AV_CHANNEL_ORDER_UNSPEC;
    }
    private static final int AV_CHANNEL_ORDER_NATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_NATIVE = 1
     * }
     */
    public static int AV_CHANNEL_ORDER_NATIVE() {
        return AV_CHANNEL_ORDER_NATIVE;
    }
    private static final int AV_CHANNEL_ORDER_CUSTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_CUSTOM = 2
     * }
     */
    public static int AV_CHANNEL_ORDER_CUSTOM() {
        return AV_CHANNEL_ORDER_CUSTOM;
    }
    private static final int AV_CHANNEL_ORDER_AMBISONIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_AMBISONIC = 3
     * }
     */
    public static int AV_CHANNEL_ORDER_AMBISONIC() {
        return AV_CHANNEL_ORDER_AMBISONIC;
    }
    private static final int AV_MATRIX_ENCODING_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_NONE = 0
     * }
     */
    public static int AV_MATRIX_ENCODING_NONE() {
        return AV_MATRIX_ENCODING_NONE;
    }
    private static final int AV_MATRIX_ENCODING_DOLBY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DOLBY = 1
     * }
     */
    public static int AV_MATRIX_ENCODING_DOLBY() {
        return AV_MATRIX_ENCODING_DOLBY;
    }
    private static final int AV_MATRIX_ENCODING_DPLII = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DPLII = 2
     * }
     */
    public static int AV_MATRIX_ENCODING_DPLII() {
        return AV_MATRIX_ENCODING_DPLII;
    }
    private static final int AV_MATRIX_ENCODING_DPLIIX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DPLIIX = 3
     * }
     */
    public static int AV_MATRIX_ENCODING_DPLIIX() {
        return AV_MATRIX_ENCODING_DPLIIX;
    }
    private static final int AV_MATRIX_ENCODING_DPLIIZ = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DPLIIZ = 4
     * }
     */
    public static int AV_MATRIX_ENCODING_DPLIIZ() {
        return AV_MATRIX_ENCODING_DPLIIZ;
    }
    private static final int AV_MATRIX_ENCODING_DOLBYEX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DOLBYEX = 5
     * }
     */
    public static int AV_MATRIX_ENCODING_DOLBYEX() {
        return AV_MATRIX_ENCODING_DOLBYEX;
    }
    private static final int AV_MATRIX_ENCODING_DOLBYHEADPHONE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6
     * }
     */
    public static int AV_MATRIX_ENCODING_DOLBYHEADPHONE() {
        return AV_MATRIX_ENCODING_DOLBYHEADPHONE;
    }
    private static final int AV_MATRIX_ENCODING_NB = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_NB = 7
     * }
     */
    public static int AV_MATRIX_ENCODING_NB() {
        return AV_MATRIX_ENCODING_NB;
    }

    private static class av_get_channel_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_channel_layout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t av_get_channel_layout(const char *name)
     * }
     */
    public static FunctionDescriptor av_get_channel_layout$descriptor() {
        return av_get_channel_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t av_get_channel_layout(const char *name)
     * }
     */
    public static MethodHandle av_get_channel_layout$handle() {
        return av_get_channel_layout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * uint64_t av_get_channel_layout(const char *name)
     * }
     */
    public static long av_get_channel_layout(MemorySegment name) {
        var mh$ = av_get_channel_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_channel_layout", name);
            }
            return (long)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_extended_channel_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_extended_channel_layout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_extended_channel_layout(const char *name, uint64_t *channel_layout, int *nb_channels)
     * }
     */
    public static FunctionDescriptor av_get_extended_channel_layout$descriptor() {
        return av_get_extended_channel_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_extended_channel_layout(const char *name, uint64_t *channel_layout, int *nb_channels)
     * }
     */
    public static MethodHandle av_get_extended_channel_layout$handle() {
        return av_get_extended_channel_layout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_get_extended_channel_layout(const char *name, uint64_t *channel_layout, int *nb_channels)
     * }
     */
    public static int av_get_extended_channel_layout(MemorySegment name, MemorySegment channel_layout, MemorySegment nb_channels) {
        var mh$ = av_get_extended_channel_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_extended_channel_layout", name, channel_layout, nb_channels);
            }
            return (int)mh$.invokeExact(name, channel_layout, nb_channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_channel_layout_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_channel_layout_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_get_channel_layout_string(char *buf, int buf_size, int nb_channels, uint64_t channel_layout)
     * }
     */
    public static FunctionDescriptor av_get_channel_layout_string$descriptor() {
        return av_get_channel_layout_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_get_channel_layout_string(char *buf, int buf_size, int nb_channels, uint64_t channel_layout)
     * }
     */
    public static MethodHandle av_get_channel_layout_string$handle() {
        return av_get_channel_layout_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_get_channel_layout_string(char *buf, int buf_size, int nb_channels, uint64_t channel_layout)
     * }
     */
    public static void av_get_channel_layout_string(MemorySegment buf, int buf_size, int nb_channels, long channel_layout) {
        var mh$ = av_get_channel_layout_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_channel_layout_string", buf, buf_size, nb_channels, channel_layout);
            }
            mh$.invokeExact(buf, buf_size, nb_channels, channel_layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_bprint_channel_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_bprint_channel_layout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_bprint_channel_layout(struct AVBPrint *bp, int nb_channels, uint64_t channel_layout)
     * }
     */
    public static FunctionDescriptor av_bprint_channel_layout$descriptor() {
        return av_bprint_channel_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_bprint_channel_layout(struct AVBPrint *bp, int nb_channels, uint64_t channel_layout)
     * }
     */
    public static MethodHandle av_bprint_channel_layout$handle() {
        return av_bprint_channel_layout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_bprint_channel_layout(struct AVBPrint *bp, int nb_channels, uint64_t channel_layout)
     * }
     */
    public static void av_bprint_channel_layout(MemorySegment bp, int nb_channels, long channel_layout) {
        var mh$ = av_bprint_channel_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_bprint_channel_layout", bp, nb_channels, channel_layout);
            }
            mh$.invokeExact(bp, nb_channels, channel_layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_channel_layout_nb_channels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_channel_layout_nb_channels"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_channel_layout_nb_channels(uint64_t channel_layout)
     * }
     */
    public static FunctionDescriptor av_get_channel_layout_nb_channels$descriptor() {
        return av_get_channel_layout_nb_channels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_channel_layout_nb_channels(uint64_t channel_layout)
     * }
     */
    public static MethodHandle av_get_channel_layout_nb_channels$handle() {
        return av_get_channel_layout_nb_channels.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_get_channel_layout_nb_channels(uint64_t channel_layout)
     * }
     */
    public static int av_get_channel_layout_nb_channels(long channel_layout) {
        var mh$ = av_get_channel_layout_nb_channels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_channel_layout_nb_channels", channel_layout);
            }
            return (int)mh$.invokeExact(channel_layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_default_channel_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_default_channel_layout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_get_default_channel_layout(int nb_channels)
     * }
     */
    public static FunctionDescriptor av_get_default_channel_layout$descriptor() {
        return av_get_default_channel_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_get_default_channel_layout(int nb_channels)
     * }
     */
    public static MethodHandle av_get_default_channel_layout$handle() {
        return av_get_default_channel_layout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int64_t av_get_default_channel_layout(int nb_channels)
     * }
     */
    public static long av_get_default_channel_layout(int nb_channels) {
        var mh$ = av_get_default_channel_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_default_channel_layout", nb_channels);
            }
            return (long)mh$.invokeExact(nb_channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_channel_layout_channel_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_channel_layout_channel_index"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_channel_layout_channel_index(uint64_t channel_layout, uint64_t channel)
     * }
     */
    public static FunctionDescriptor av_get_channel_layout_channel_index$descriptor() {
        return av_get_channel_layout_channel_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_channel_layout_channel_index(uint64_t channel_layout, uint64_t channel)
     * }
     */
    public static MethodHandle av_get_channel_layout_channel_index$handle() {
        return av_get_channel_layout_channel_index.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_get_channel_layout_channel_index(uint64_t channel_layout, uint64_t channel)
     * }
     */
    public static int av_get_channel_layout_channel_index(long channel_layout, long channel) {
        var mh$ = av_get_channel_layout_channel_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_channel_layout_channel_index", channel_layout, channel);
            }
            return (int)mh$.invokeExact(channel_layout, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_extract_channel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_extract_channel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index)
     * }
     */
    public static FunctionDescriptor av_channel_layout_extract_channel$descriptor() {
        return av_channel_layout_extract_channel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index)
     * }
     */
    public static MethodHandle av_channel_layout_extract_channel$handle() {
        return av_channel_layout_extract_channel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index)
     * }
     */
    public static long av_channel_layout_extract_channel(long channel_layout, int index) {
        var mh$ = av_channel_layout_extract_channel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_extract_channel", channel_layout, index);
            }
            return (long)mh$.invokeExact(channel_layout, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_channel_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_channel_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_channel_name(uint64_t channel)
     * }
     */
    public static FunctionDescriptor av_get_channel_name$descriptor() {
        return av_get_channel_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_channel_name(uint64_t channel)
     * }
     */
    public static MethodHandle av_get_channel_name$handle() {
        return av_get_channel_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *av_get_channel_name(uint64_t channel)
     * }
     */
    public static MemorySegment av_get_channel_name(long channel) {
        var mh$ = av_get_channel_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_channel_name", channel);
            }
            return (MemorySegment)mh$.invokeExact(channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_channel_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_channel_description"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_channel_description(uint64_t channel)
     * }
     */
    public static FunctionDescriptor av_get_channel_description$descriptor() {
        return av_get_channel_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_channel_description(uint64_t channel)
     * }
     */
    public static MethodHandle av_get_channel_description$handle() {
        return av_get_channel_description.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *av_get_channel_description(uint64_t channel)
     * }
     */
    public static MemorySegment av_get_channel_description(long channel) {
        var mh$ = av_get_channel_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_channel_description", channel);
            }
            return (MemorySegment)mh$.invokeExact(channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_standard_channel_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_get_standard_channel_layout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_standard_channel_layout(unsigned int index, uint64_t *layout, const char **name)
     * }
     */
    public static FunctionDescriptor av_get_standard_channel_layout$descriptor() {
        return av_get_standard_channel_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_standard_channel_layout(unsigned int index, uint64_t *layout, const char **name)
     * }
     */
    public static MethodHandle av_get_standard_channel_layout$handle() {
        return av_get_standard_channel_layout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_get_standard_channel_layout(unsigned int index, uint64_t *layout, const char **name)
     * }
     */
    public static int av_get_standard_channel_layout(int index, MemorySegment layout, MemorySegment name) {
        var mh$ = av_get_standard_channel_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_standard_channel_layout", index, layout, name);
            }
            return (int)mh$.invokeExact(index, layout, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static FunctionDescriptor av_channel_name$descriptor() {
        return av_channel_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static MethodHandle av_channel_name$handle() {
        return av_channel_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static int av_channel_name(MemorySegment buf, long buf_size, int channel) {
        var mh$ = av_channel_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_name", buf, buf_size, channel);
            }
            return (int)mh$.invokeExact(buf, buf_size, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_name_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_name_bprint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static FunctionDescriptor av_channel_name_bprint$descriptor() {
        return av_channel_name_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static MethodHandle av_channel_name_bprint$handle() {
        return av_channel_name_bprint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static void av_channel_name_bprint(MemorySegment bp, int channel_id) {
        var mh$ = av_channel_name_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_name_bprint", bp, channel_id);
            }
            mh$.invokeExact(bp, channel_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_description"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static FunctionDescriptor av_channel_description$descriptor() {
        return av_channel_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static MethodHandle av_channel_description$handle() {
        return av_channel_description.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static int av_channel_description(MemorySegment buf, long buf_size, int channel) {
        var mh$ = av_channel_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_description", buf, buf_size, channel);
            }
            return (int)mh$.invokeExact(buf, buf_size, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_description_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_description_bprint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static FunctionDescriptor av_channel_description_bprint$descriptor() {
        return av_channel_description_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static MethodHandle av_channel_description_bprint$handle() {
        return av_channel_description_bprint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static void av_channel_description_bprint(MemorySegment bp, int channel_id) {
        var mh$ = av_channel_description_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_description_bprint", bp, channel_id);
            }
            mh$.invokeExact(bp, channel_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_from_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_from_string(const char *name)
     * }
     */
    public static FunctionDescriptor av_channel_from_string$descriptor() {
        return av_channel_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_from_string(const char *name)
     * }
     */
    public static MethodHandle av_channel_from_string$handle() {
        return av_channel_from_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * enum AVChannel av_channel_from_string(const char *name)
     * }
     */
    public static int av_channel_from_string(MemorySegment name) {
        var mh$ = av_channel_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_from_string", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_from_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_from_mask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static FunctionDescriptor av_channel_layout_from_mask$descriptor() {
        return av_channel_layout_from_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static MethodHandle av_channel_layout_from_mask$handle() {
        return av_channel_layout_from_mask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static int av_channel_layout_from_mask(MemorySegment channel_layout, long mask) {
        var mh$ = av_channel_layout_from_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_from_mask", channel_layout, mask);
            }
            return (int)mh$.invokeExact(channel_layout, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_from_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_from_string(AVChannelLayout *channel_layout, const char *str)
     * }
     */
    public static FunctionDescriptor av_channel_layout_from_string$descriptor() {
        return av_channel_layout_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_from_string(AVChannelLayout *channel_layout, const char *str)
     * }
     */
    public static MethodHandle av_channel_layout_from_string$handle() {
        return av_channel_layout_from_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_from_string(AVChannelLayout *channel_layout, const char *str)
     * }
     */
    public static int av_channel_layout_from_string(MemorySegment channel_layout, MemorySegment str) {
        var mh$ = av_channel_layout_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_from_string", channel_layout, str);
            }
            return (int)mh$.invokeExact(channel_layout, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_default"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
     * }
     */
    public static FunctionDescriptor av_channel_layout_default$descriptor() {
        return av_channel_layout_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
     * }
     */
    public static MethodHandle av_channel_layout_default$handle() {
        return av_channel_layout_default.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
     * }
     */
    public static void av_channel_layout_default(MemorySegment ch_layout, int nb_channels) {
        var mh$ = av_channel_layout_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_default", ch_layout, nb_channels);
            }
            mh$.invokeExact(ch_layout, nb_channels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_standard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_standard"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVChannelLayout *av_channel_layout_standard(void **opaque)
     * }
     */
    public static FunctionDescriptor av_channel_layout_standard$descriptor() {
        return av_channel_layout_standard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVChannelLayout *av_channel_layout_standard(void **opaque)
     * }
     */
    public static MethodHandle av_channel_layout_standard$handle() {
        return av_channel_layout_standard.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const AVChannelLayout *av_channel_layout_standard(void **opaque)
     * }
     */
    public static MemorySegment av_channel_layout_standard(MemorySegment opaque) {
        var mh$ = av_channel_layout_standard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_standard", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_uninit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_uninit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_layout_uninit(AVChannelLayout *channel_layout)
     * }
     */
    public static FunctionDescriptor av_channel_layout_uninit$descriptor() {
        return av_channel_layout_uninit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_layout_uninit(AVChannelLayout *channel_layout)
     * }
     */
    public static MethodHandle av_channel_layout_uninit$handle() {
        return av_channel_layout_uninit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_channel_layout_uninit(AVChannelLayout *channel_layout)
     * }
     */
    public static void av_channel_layout_uninit(MemorySegment channel_layout) {
        var mh$ = av_channel_layout_uninit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_uninit", channel_layout);
            }
            mh$.invokeExact(channel_layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     * }
     */
    public static FunctionDescriptor av_channel_layout_copy$descriptor() {
        return av_channel_layout_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     * }
     */
    public static MethodHandle av_channel_layout_copy$handle() {
        return av_channel_layout_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     * }
     */
    public static int av_channel_layout_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = av_channel_layout_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_describe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_describe"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_describe(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)
     * }
     */
    public static FunctionDescriptor av_channel_layout_describe$descriptor() {
        return av_channel_layout_describe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_describe(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)
     * }
     */
    public static MethodHandle av_channel_layout_describe$handle() {
        return av_channel_layout_describe.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_describe(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)
     * }
     */
    public static int av_channel_layout_describe(MemorySegment channel_layout, MemorySegment buf, long buf_size) {
        var mh$ = av_channel_layout_describe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_describe", channel_layout, buf, buf_size);
            }
            return (int)mh$.invokeExact(channel_layout, buf, buf_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_describe_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_describe_bprint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout, struct AVBPrint *bp)
     * }
     */
    public static FunctionDescriptor av_channel_layout_describe_bprint$descriptor() {
        return av_channel_layout_describe_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout, struct AVBPrint *bp)
     * }
     */
    public static MethodHandle av_channel_layout_describe_bprint$handle() {
        return av_channel_layout_describe_bprint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout, struct AVBPrint *bp)
     * }
     */
    public static int av_channel_layout_describe_bprint(MemorySegment channel_layout, MemorySegment bp) {
        var mh$ = av_channel_layout_describe_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_describe_bprint", channel_layout, bp);
            }
            return (int)mh$.invokeExact(channel_layout, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_channel_from_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_channel_from_index"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx)
     * }
     */
    public static FunctionDescriptor av_channel_layout_channel_from_index$descriptor() {
        return av_channel_layout_channel_from_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx)
     * }
     */
    public static MethodHandle av_channel_layout_channel_from_index$handle() {
        return av_channel_layout_channel_from_index.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx)
     * }
     */
    public static int av_channel_layout_channel_from_index(MemorySegment channel_layout, int idx) {
        var mh$ = av_channel_layout_channel_from_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_channel_from_index", channel_layout, idx);
            }
            return (int)mh$.invokeExact(channel_layout, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_index_from_channel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_index_from_channel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout, enum AVChannel channel)
     * }
     */
    public static FunctionDescriptor av_channel_layout_index_from_channel$descriptor() {
        return av_channel_layout_index_from_channel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout, enum AVChannel channel)
     * }
     */
    public static MethodHandle av_channel_layout_index_from_channel$handle() {
        return av_channel_layout_index_from_channel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout, enum AVChannel channel)
     * }
     */
    public static int av_channel_layout_index_from_channel(MemorySegment channel_layout, int channel) {
        var mh$ = av_channel_layout_index_from_channel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_index_from_channel", channel_layout, channel);
            }
            return (int)mh$.invokeExact(channel_layout, channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_index_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_index_from_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static FunctionDescriptor av_channel_layout_index_from_string$descriptor() {
        return av_channel_layout_index_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static MethodHandle av_channel_layout_index_from_string$handle() {
        return av_channel_layout_index_from_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static int av_channel_layout_index_from_string(MemorySegment channel_layout, MemorySegment name) {
        var mh$ = av_channel_layout_index_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_index_from_string", channel_layout, name);
            }
            return (int)mh$.invokeExact(channel_layout, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_channel_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_channel_from_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static FunctionDescriptor av_channel_layout_channel_from_string$descriptor() {
        return av_channel_layout_channel_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static MethodHandle av_channel_layout_channel_from_string$handle() {
        return av_channel_layout_channel_from_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static int av_channel_layout_channel_from_string(MemorySegment channel_layout, MemorySegment name) {
        var mh$ = av_channel_layout_channel_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_channel_from_string", channel_layout, name);
            }
            return (int)mh$.invokeExact(channel_layout, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_subset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_subset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static FunctionDescriptor av_channel_layout_subset$descriptor() {
        return av_channel_layout_subset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static MethodHandle av_channel_layout_subset$handle() {
        return av_channel_layout_subset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static long av_channel_layout_subset(MemorySegment channel_layout, long mask) {
        var mh$ = av_channel_layout_subset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_subset", channel_layout, mask);
            }
            return (long)mh$.invokeExact(channel_layout, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_check"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_check(const AVChannelLayout *channel_layout)
     * }
     */
    public static FunctionDescriptor av_channel_layout_check$descriptor() {
        return av_channel_layout_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_check(const AVChannelLayout *channel_layout)
     * }
     */
    public static MethodHandle av_channel_layout_check$handle() {
        return av_channel_layout_check.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_check(const AVChannelLayout *channel_layout)
     * }
     */
    public static int av_channel_layout_check(MemorySegment channel_layout) {
        var mh$ = av_channel_layout_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_check", channel_layout);
            }
            return (int)mh$.invokeExact(channel_layout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_channel_layout_compare"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
     * }
     */
    public static FunctionDescriptor av_channel_layout_compare$descriptor() {
        return av_channel_layout_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
     * }
     */
    public static MethodHandle av_channel_layout_compare$handle() {
        return av_channel_layout_compare.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
     * }
     */
    public static int av_channel_layout_compare(MemorySegment chl, MemorySegment chl1) {
        var mh$ = av_channel_layout_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_compare", chl, chl1);
            }
            return (int)mh$.invokeExact(chl, chl1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_FRAME_DATA_PANSCAN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_PANSCAN = 0
     * }
     */
    public static int AV_FRAME_DATA_PANSCAN() {
        return AV_FRAME_DATA_PANSCAN;
    }
    private static final int AV_FRAME_DATA_A53_CC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_A53_CC = 1
     * }
     */
    public static int AV_FRAME_DATA_A53_CC() {
        return AV_FRAME_DATA_A53_CC;
    }
    private static final int AV_FRAME_DATA_STEREO3D = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_STEREO3D = 2
     * }
     */
    public static int AV_FRAME_DATA_STEREO3D() {
        return AV_FRAME_DATA_STEREO3D;
    }
    private static final int AV_FRAME_DATA_MATRIXENCODING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MATRIXENCODING = 3
     * }
     */
    public static int AV_FRAME_DATA_MATRIXENCODING() {
        return AV_FRAME_DATA_MATRIXENCODING;
    }
    private static final int AV_FRAME_DATA_DOWNMIX_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOWNMIX_INFO = 4
     * }
     */
    public static int AV_FRAME_DATA_DOWNMIX_INFO() {
        return AV_FRAME_DATA_DOWNMIX_INFO;
    }
    private static final int AV_FRAME_DATA_REPLAYGAIN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_REPLAYGAIN = 5
     * }
     */
    public static int AV_FRAME_DATA_REPLAYGAIN() {
        return AV_FRAME_DATA_REPLAYGAIN;
    }
    private static final int AV_FRAME_DATA_DISPLAYMATRIX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DISPLAYMATRIX = 6
     * }
     */
    public static int AV_FRAME_DATA_DISPLAYMATRIX() {
        return AV_FRAME_DATA_DISPLAYMATRIX;
    }
    private static final int AV_FRAME_DATA_AFD = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AFD = 7
     * }
     */
    public static int AV_FRAME_DATA_AFD() {
        return AV_FRAME_DATA_AFD;
    }
    private static final int AV_FRAME_DATA_MOTION_VECTORS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MOTION_VECTORS = 8
     * }
     */
    public static int AV_FRAME_DATA_MOTION_VECTORS() {
        return AV_FRAME_DATA_MOTION_VECTORS;
    }
    private static final int AV_FRAME_DATA_SKIP_SAMPLES = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SKIP_SAMPLES = 9
     * }
     */
    public static int AV_FRAME_DATA_SKIP_SAMPLES() {
        return AV_FRAME_DATA_SKIP_SAMPLES;
    }
    private static final int AV_FRAME_DATA_AUDIO_SERVICE_TYPE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10
     * }
     */
    public static int AV_FRAME_DATA_AUDIO_SERVICE_TYPE() {
        return AV_FRAME_DATA_AUDIO_SERVICE_TYPE;
    }
    private static final int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11
     * }
     */
    public static int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA() {
        return AV_FRAME_DATA_MASTERING_DISPLAY_METADATA;
    }
    private static final int AV_FRAME_DATA_GOP_TIMECODE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_GOP_TIMECODE = 12
     * }
     */
    public static int AV_FRAME_DATA_GOP_TIMECODE() {
        return AV_FRAME_DATA_GOP_TIMECODE;
    }
    private static final int AV_FRAME_DATA_SPHERICAL = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SPHERICAL = 13
     * }
     */
    public static int AV_FRAME_DATA_SPHERICAL() {
        return AV_FRAME_DATA_SPHERICAL;
    }
    private static final int AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14
     * }
     */
    public static int AV_FRAME_DATA_CONTENT_LIGHT_LEVEL() {
        return AV_FRAME_DATA_CONTENT_LIGHT_LEVEL;
    }
    private static final int AV_FRAME_DATA_ICC_PROFILE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_ICC_PROFILE = 15
     * }
     */
    public static int AV_FRAME_DATA_ICC_PROFILE() {
        return AV_FRAME_DATA_ICC_PROFILE;
    }
    private static final int AV_FRAME_DATA_S12M_TIMECODE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_S12M_TIMECODE = 16
     * }
     */
    public static int AV_FRAME_DATA_S12M_TIMECODE() {
        return AV_FRAME_DATA_S12M_TIMECODE;
    }
    private static final int AV_FRAME_DATA_DYNAMIC_HDR_PLUS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 17
     * }
     */
    public static int AV_FRAME_DATA_DYNAMIC_HDR_PLUS() {
        return AV_FRAME_DATA_DYNAMIC_HDR_PLUS;
    }
    private static final int AV_FRAME_DATA_REGIONS_OF_INTEREST = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_REGIONS_OF_INTEREST = 18
     * }
     */
    public static int AV_FRAME_DATA_REGIONS_OF_INTEREST() {
        return AV_FRAME_DATA_REGIONS_OF_INTEREST;
    }
    private static final int AV_FRAME_DATA_VIDEO_ENC_PARAMS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_VIDEO_ENC_PARAMS = 19
     * }
     */
    public static int AV_FRAME_DATA_VIDEO_ENC_PARAMS() {
        return AV_FRAME_DATA_VIDEO_ENC_PARAMS;
    }
    private static final int AV_FRAME_DATA_SEI_UNREGISTERED = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SEI_UNREGISTERED = 20
     * }
     */
    public static int AV_FRAME_DATA_SEI_UNREGISTERED() {
        return AV_FRAME_DATA_SEI_UNREGISTERED;
    }
    private static final int AV_FRAME_DATA_FILM_GRAIN_PARAMS = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_FILM_GRAIN_PARAMS = 21
     * }
     */
    public static int AV_FRAME_DATA_FILM_GRAIN_PARAMS() {
        return AV_FRAME_DATA_FILM_GRAIN_PARAMS;
    }
    private static final int AV_FRAME_DATA_DETECTION_BBOXES = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DETECTION_BBOXES = 22
     * }
     */
    public static int AV_FRAME_DATA_DETECTION_BBOXES() {
        return AV_FRAME_DATA_DETECTION_BBOXES;
    }
    private static final int AV_FRAME_DATA_DOVI_RPU_BUFFER = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOVI_RPU_BUFFER = 23
     * }
     */
    public static int AV_FRAME_DATA_DOVI_RPU_BUFFER() {
        return AV_FRAME_DATA_DOVI_RPU_BUFFER;
    }
    private static final int AV_FRAME_DATA_DOVI_METADATA = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOVI_METADATA = 24
     * }
     */
    public static int AV_FRAME_DATA_DOVI_METADATA() {
        return AV_FRAME_DATA_DOVI_METADATA;
    }
    private static final int AV_FRAME_DATA_DYNAMIC_HDR_VIVID = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DYNAMIC_HDR_VIVID = 25
     * }
     */
    public static int AV_FRAME_DATA_DYNAMIC_HDR_VIVID() {
        return AV_FRAME_DATA_DYNAMIC_HDR_VIVID;
    }
    private static final int AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT = 26
     * }
     */
    public static int AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT() {
        return AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT;
    }
    private static final int AV_AFD_SAME = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_SAME = 8
     * }
     */
    public static int AV_AFD_SAME() {
        return AV_AFD_SAME;
    }
    private static final int AV_AFD_4_3 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_4_3 = 9
     * }
     */
    public static int AV_AFD_4_3() {
        return AV_AFD_4_3;
    }
    private static final int AV_AFD_16_9 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_16_9 = 10
     * }
     */
    public static int AV_AFD_16_9() {
        return AV_AFD_16_9;
    }
    private static final int AV_AFD_14_9 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_14_9 = 11
     * }
     */
    public static int AV_AFD_14_9() {
        return AV_AFD_14_9;
    }
    private static final int AV_AFD_4_3_SP_14_9 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_4_3_SP_14_9 = 13
     * }
     */
    public static int AV_AFD_4_3_SP_14_9() {
        return AV_AFD_4_3_SP_14_9;
    }
    private static final int AV_AFD_16_9_SP_14_9 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_16_9_SP_14_9 = 14
     * }
     */
    public static int AV_AFD_16_9_SP_14_9() {
        return AV_AFD_16_9_SP_14_9;
    }
    private static final int AV_AFD_SP_4_3 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_SP_4_3 = 15
     * }
     */
    public static int AV_AFD_SP_4_3() {
        return AV_AFD_SP_4_3;
    }

    private static class av_frame_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_alloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static FunctionDescriptor av_frame_alloc$descriptor() {
        return av_frame_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MethodHandle av_frame_alloc$handle() {
        return av_frame_alloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MemorySegment av_frame_alloc() {
        var mh$ = av_frame_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static FunctionDescriptor av_frame_free$descriptor() {
        return av_frame_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static MethodHandle av_frame_free$handle() {
        return av_frame_free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static void av_frame_free(MemorySegment frame) {
        var mh$ = av_frame_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_free", frame);
            }
            mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_ref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_ref$descriptor() {
        return av_frame_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_ref$handle() {
        return av_frame_ref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_ref", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_clone"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_clone$descriptor() {
        return av_frame_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_clone$handle() {
        return av_frame_clone.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_clone(MemorySegment src) {
        var mh$ = av_frame_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_clone", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_unref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_unref$descriptor() {
        return av_frame_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_unref$handle() {
        return av_frame_unref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static void av_frame_unref(MemorySegment frame) {
        var mh$ = av_frame_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_unref", frame);
            }
            mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_move_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_move_ref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_move_ref$descriptor() {
        return av_frame_move_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_move_ref$handle() {
        return av_frame_move_ref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static void av_frame_move_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_move_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_move_ref", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_get_buffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static FunctionDescriptor av_frame_get_buffer$descriptor() {
        return av_frame_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static MethodHandle av_frame_get_buffer$handle() {
        return av_frame_get_buffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static int av_frame_get_buffer(MemorySegment frame, int align) {
        var mh$ = av_frame_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_buffer", frame, align);
            }
            return (int)mh$.invokeExact(frame, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_is_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_is_writable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_is_writable$descriptor() {
        return av_frame_is_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_is_writable$handle() {
        return av_frame_is_writable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_is_writable(MemorySegment frame) {
        var mh$ = av_frame_is_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_is_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_make_writable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_make_writable$descriptor() {
        return av_frame_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_make_writable$handle() {
        return av_frame_make_writable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_make_writable(MemorySegment frame) {
        var mh$ = av_frame_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_make_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy$descriptor() {
        return av_frame_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy$handle() {
        return av_frame_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_copy_props"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy_props$descriptor() {
        return av_frame_copy_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy_props$handle() {
        return av_frame_copy_props.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy_props(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy_props", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_plane_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_get_plane_buffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(AVFrame *frame, int plane)
     * }
     */
    public static FunctionDescriptor av_frame_get_plane_buffer$descriptor() {
        return av_frame_get_plane_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(AVFrame *frame, int plane)
     * }
     */
    public static MethodHandle av_frame_get_plane_buffer$handle() {
        return av_frame_get_plane_buffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(AVFrame *frame, int plane)
     * }
     */
    public static MemorySegment av_frame_get_plane_buffer(MemorySegment frame, int plane) {
        var mh$ = av_frame_get_plane_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_plane_buffer", frame, plane);
            }
            return (MemorySegment)mh$.invokeExact(frame, plane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_new_side_data"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data$descriptor() {
        return av_frame_new_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_frame_new_side_data$handle() {
        return av_frame_new_side_data.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_frame_new_side_data(MemorySegment frame, int type, long size) {
        var mh$ = av_frame_new_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data", frame, type, size);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data_from_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_new_side_data_from_buf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data_from_buf$descriptor() {
        return av_frame_new_side_data_from_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_frame_new_side_data_from_buf$handle() {
        return av_frame_new_side_data_from_buf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_frame_new_side_data_from_buf(MemorySegment frame, int type, MemorySegment buf) {
        var mh$ = av_frame_new_side_data_from_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data_from_buf", frame, type, buf);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_get_side_data"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_get_side_data$descriptor() {
        return av_frame_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_get_side_data$handle() {
        return av_frame_get_side_data.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_get_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_side_data", frame, type);
            }
            return (MemorySegment)mh$.invokeExact(frame, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_remove_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_remove_side_data"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_remove_side_data$descriptor() {
        return av_frame_remove_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_remove_side_data$handle() {
        return av_frame_remove_side_data.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static void av_frame_remove_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_remove_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_remove_side_data", frame, type);
            }
            mh$.invokeExact(frame, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_FRAME_CROP_UNALIGNED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_FRAME_CROP_UNALIGNED = 1
     * }
     */
    public static int AV_FRAME_CROP_UNALIGNED() {
        return AV_FRAME_CROP_UNALIGNED;
    }

    private static class av_frame_apply_cropping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_apply_cropping"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_frame_apply_cropping$descriptor() {
        return av_frame_apply_cropping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_frame_apply_cropping$handle() {
        return av_frame_apply_cropping.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static int av_frame_apply_cropping(MemorySegment frame, int flags) {
        var mh$ = av_frame_apply_cropping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_apply_cropping", frame, flags);
            }
            return (int)mh$.invokeExact(frame, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    FFmpeg.findOrThrow("av_frame_side_data_name"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_name$descriptor() {
        return av_frame_side_data_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_name$handle() {
        return av_frame_side_data_name.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_name(int type) {
        var mh$ = av_frame_side_data_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_HWDEVICE_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_NONE = 0
     * }
     */
    public static int AV_HWDEVICE_TYPE_NONE() {
        return AV_HWDEVICE_TYPE_NONE;
    }
    private static final int AV_HWDEVICE_TYPE_VDPAU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_VDPAU = 1
     * }
     */
    public static int AV_HWDEVICE_TYPE_VDPAU() {
        return AV_HWDEVICE_TYPE_VDPAU;
    }
    private static final int AV_HWDEVICE_TYPE_CUDA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_CUDA = 2
     * }
     */
    public static int AV_HWDEVICE_TYPE_CUDA() {
        return AV_HWDEVICE_TYPE_CUDA;
    }
    private static final int AV_HWDEVICE_TYPE_VAAPI = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_VAAPI = 3
     * }
     */
    public static int AV_HWDEVICE_TYPE_VAAPI() {
        return AV_HWDEVICE_TYPE_VAAPI;
    }
}

