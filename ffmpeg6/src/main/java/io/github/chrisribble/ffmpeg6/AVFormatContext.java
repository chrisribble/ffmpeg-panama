// Generated by jextract

package io.github.chrisribble.ffmpeg6;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct AVFormatContext {
 *     const AVClass *av_class;
 *     const struct AVInputFormat *iformat;
 *     const struct AVOutputFormat *oformat;
 *     void *priv_data;
 *     AVIOContext *pb;
 *     int ctx_flags;
 *     unsigned int nb_streams;
 *     AVStream **streams;
 *     char *url;
 *     int64_t start_time;
 *     int64_t duration;
 *     int64_t bit_rate;
 *     unsigned int packet_size;
 *     int max_delay;
 *     int flags;
 *     int64_t probesize;
 *     int64_t max_analyze_duration;
 *     const uint8_t *key;
 *     int keylen;
 *     unsigned int nb_programs;
 *     AVProgram **programs;
 *     enum AVCodecID video_codec_id;
 *     enum AVCodecID audio_codec_id;
 *     enum AVCodecID subtitle_codec_id;
 *     unsigned int max_index_size;
 *     unsigned int max_picture_buffer;
 *     unsigned int nb_chapters;
 *     AVChapter **chapters;
 *     AVDictionary *metadata;
 *     int64_t start_time_realtime;
 *     int fps_probe_size;
 *     int error_recognition;
 *     AVIOInterruptCB interrupt_callback;
 *     int debug;
 *     int64_t max_interleave_delta;
 *     int strict_std_compliance;
 *     int event_flags;
 *     int max_ts_probe;
 *     int avoid_negative_ts;
 *     int ts_id;
 *     int audio_preload;
 *     int max_chunk_duration;
 *     int max_chunk_size;
 *     int use_wallclock_as_timestamps;
 *     int avio_flags;
 *     enum AVDurationEstimationMethod duration_estimation_method;
 *     int64_t skip_initial_bytes;
 *     unsigned int correct_ts_overflow;
 *     int seek2any;
 *     int flush_packets;
 *     int probe_score;
 *     int format_probesize;
 *     char *codec_whitelist;
 *     char *format_whitelist;
 *     int io_repositioned;
 *     const struct AVCodec *video_codec;
 *     const struct AVCodec *audio_codec;
 *     const struct AVCodec *subtitle_codec;
 *     const struct AVCodec *data_codec;
 *     int metadata_header_padding;
 *     void *opaque;
 *     av_format_control_message control_message_cb;
 *     int64_t output_ts_offset;
 *     uint8_t *dump_separator;
 *     enum AVCodecID data_codec_id;
 *     char *protocol_whitelist;
 *     int (*io_open)(struct AVFormatContext *, AVIOContext **, const char *, int, AVDictionary **);
 *     void (*io_close)(struct AVFormatContext *, AVIOContext *);
 *     char *protocol_blacklist;
 *     int max_streams;
 *     int skip_estimate_duration_from_pts;
 *     int max_probe_packets;
 *     int (*io_close2)(struct AVFormatContext *, AVIOContext *);
 * }
 * }
 */
public class AVFormatContext {

    AVFormatContext() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        FFmpeg.C_POINTER.withName("av_class"),
        FFmpeg.C_POINTER.withName("iformat"),
        FFmpeg.C_POINTER.withName("oformat"),
        FFmpeg.C_POINTER.withName("priv_data"),
        FFmpeg.C_POINTER.withName("pb"),
        FFmpeg.C_INT.withName("ctx_flags"),
        FFmpeg.C_INT.withName("nb_streams"),
        FFmpeg.C_POINTER.withName("streams"),
        FFmpeg.C_POINTER.withName("url"),
        FFmpeg.C_LONG.withName("start_time"),
        FFmpeg.C_LONG.withName("duration"),
        FFmpeg.C_LONG.withName("bit_rate"),
        FFmpeg.C_INT.withName("packet_size"),
        FFmpeg.C_INT.withName("max_delay"),
        FFmpeg.C_INT.withName("flags"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_LONG.withName("probesize"),
        FFmpeg.C_LONG.withName("max_analyze_duration"),
        FFmpeg.C_POINTER.withName("key"),
        FFmpeg.C_INT.withName("keylen"),
        FFmpeg.C_INT.withName("nb_programs"),
        FFmpeg.C_POINTER.withName("programs"),
        FFmpeg.C_INT.withName("video_codec_id"),
        FFmpeg.C_INT.withName("audio_codec_id"),
        FFmpeg.C_INT.withName("subtitle_codec_id"),
        FFmpeg.C_INT.withName("max_index_size"),
        FFmpeg.C_INT.withName("max_picture_buffer"),
        FFmpeg.C_INT.withName("nb_chapters"),
        FFmpeg.C_POINTER.withName("chapters"),
        FFmpeg.C_POINTER.withName("metadata"),
        FFmpeg.C_LONG.withName("start_time_realtime"),
        FFmpeg.C_INT.withName("fps_probe_size"),
        FFmpeg.C_INT.withName("error_recognition"),
        AVIOInterruptCB.layout().withName("interrupt_callback"),
        FFmpeg.C_INT.withName("debug"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_LONG.withName("max_interleave_delta"),
        FFmpeg.C_INT.withName("strict_std_compliance"),
        FFmpeg.C_INT.withName("event_flags"),
        FFmpeg.C_INT.withName("max_ts_probe"),
        FFmpeg.C_INT.withName("avoid_negative_ts"),
        FFmpeg.C_INT.withName("ts_id"),
        FFmpeg.C_INT.withName("audio_preload"),
        FFmpeg.C_INT.withName("max_chunk_duration"),
        FFmpeg.C_INT.withName("max_chunk_size"),
        FFmpeg.C_INT.withName("use_wallclock_as_timestamps"),
        FFmpeg.C_INT.withName("avio_flags"),
        FFmpeg.C_INT.withName("duration_estimation_method"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_LONG.withName("skip_initial_bytes"),
        FFmpeg.C_INT.withName("correct_ts_overflow"),
        FFmpeg.C_INT.withName("seek2any"),
        FFmpeg.C_INT.withName("flush_packets"),
        FFmpeg.C_INT.withName("probe_score"),
        FFmpeg.C_INT.withName("format_probesize"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_POINTER.withName("codec_whitelist"),
        FFmpeg.C_POINTER.withName("format_whitelist"),
        FFmpeg.C_INT.withName("io_repositioned"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_POINTER.withName("video_codec"),
        FFmpeg.C_POINTER.withName("audio_codec"),
        FFmpeg.C_POINTER.withName("subtitle_codec"),
        FFmpeg.C_POINTER.withName("data_codec"),
        FFmpeg.C_INT.withName("metadata_header_padding"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_POINTER.withName("opaque"),
        FFmpeg.C_POINTER.withName("control_message_cb"),
        FFmpeg.C_LONG.withName("output_ts_offset"),
        FFmpeg.C_POINTER.withName("dump_separator"),
        FFmpeg.C_INT.withName("data_codec_id"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_POINTER.withName("protocol_whitelist"),
        FFmpeg.C_POINTER.withName("io_open"),
        FFmpeg.C_POINTER.withName("io_close"),
        FFmpeg.C_POINTER.withName("protocol_blacklist"),
        FFmpeg.C_INT.withName("max_streams"),
        FFmpeg.C_INT.withName("skip_estimate_duration_from_pts"),
        FFmpeg.C_INT.withName("max_probe_packets"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_POINTER.withName("io_close2")
    ).withName("AVFormatContext");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout av_class$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("av_class"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const AVClass *av_class
     * }
     */
    public static final AddressLayout av_class$layout() {
        return av_class$LAYOUT;
    }

    private static final long av_class$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const AVClass *av_class
     * }
     */
    public static final long av_class$offset() {
        return av_class$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const AVClass *av_class
     * }
     */
    public static MemorySegment av_class(MemorySegment struct) {
        return struct.get(av_class$LAYOUT, av_class$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const AVClass *av_class
     * }
     */
    public static void av_class(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(av_class$LAYOUT, av_class$OFFSET, fieldValue);
    }

    private static final AddressLayout iformat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("iformat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct AVInputFormat *iformat
     * }
     */
    public static final AddressLayout iformat$layout() {
        return iformat$LAYOUT;
    }

    private static final long iformat$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct AVInputFormat *iformat
     * }
     */
    public static final long iformat$offset() {
        return iformat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct AVInputFormat *iformat
     * }
     */
    public static MemorySegment iformat(MemorySegment struct) {
        return struct.get(iformat$LAYOUT, iformat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct AVInputFormat *iformat
     * }
     */
    public static void iformat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(iformat$LAYOUT, iformat$OFFSET, fieldValue);
    }

    private static final AddressLayout oformat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("oformat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct AVOutputFormat *oformat
     * }
     */
    public static final AddressLayout oformat$layout() {
        return oformat$LAYOUT;
    }

    private static final long oformat$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct AVOutputFormat *oformat
     * }
     */
    public static final long oformat$offset() {
        return oformat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct AVOutputFormat *oformat
     * }
     */
    public static MemorySegment oformat(MemorySegment struct) {
        return struct.get(oformat$LAYOUT, oformat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct AVOutputFormat *oformat
     * }
     */
    public static void oformat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(oformat$LAYOUT, oformat$OFFSET, fieldValue);
    }

    private static final AddressLayout priv_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("priv_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *priv_data
     * }
     */
    public static final AddressLayout priv_data$layout() {
        return priv_data$LAYOUT;
    }

    private static final long priv_data$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *priv_data
     * }
     */
    public static final long priv_data$offset() {
        return priv_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *priv_data
     * }
     */
    public static MemorySegment priv_data(MemorySegment struct) {
        return struct.get(priv_data$LAYOUT, priv_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *priv_data
     * }
     */
    public static void priv_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(priv_data$LAYOUT, priv_data$OFFSET, fieldValue);
    }

    private static final AddressLayout pb$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pb"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVIOContext *pb
     * }
     */
    public static final AddressLayout pb$layout() {
        return pb$LAYOUT;
    }

    private static final long pb$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVIOContext *pb
     * }
     */
    public static final long pb$offset() {
        return pb$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVIOContext *pb
     * }
     */
    public static MemorySegment pb(MemorySegment struct) {
        return struct.get(pb$LAYOUT, pb$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVIOContext *pb
     * }
     */
    public static void pb(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pb$LAYOUT, pb$OFFSET, fieldValue);
    }

    private static final OfInt ctx_flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ctx_flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int ctx_flags
     * }
     */
    public static final OfInt ctx_flags$layout() {
        return ctx_flags$LAYOUT;
    }

    private static final long ctx_flags$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int ctx_flags
     * }
     */
    public static final long ctx_flags$offset() {
        return ctx_flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int ctx_flags
     * }
     */
    public static int ctx_flags(MemorySegment struct) {
        return struct.get(ctx_flags$LAYOUT, ctx_flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int ctx_flags
     * }
     */
    public static void ctx_flags(MemorySegment struct, int fieldValue) {
        struct.set(ctx_flags$LAYOUT, ctx_flags$OFFSET, fieldValue);
    }

    private static final OfInt nb_streams$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nb_streams"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int nb_streams
     * }
     */
    public static final OfInt nb_streams$layout() {
        return nb_streams$LAYOUT;
    }

    private static final long nb_streams$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int nb_streams
     * }
     */
    public static final long nb_streams$offset() {
        return nb_streams$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int nb_streams
     * }
     */
    public static int nb_streams(MemorySegment struct) {
        return struct.get(nb_streams$LAYOUT, nb_streams$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int nb_streams
     * }
     */
    public static void nb_streams(MemorySegment struct, int fieldValue) {
        struct.set(nb_streams$LAYOUT, nb_streams$OFFSET, fieldValue);
    }

    private static final AddressLayout streams$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("streams"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVStream **streams
     * }
     */
    public static final AddressLayout streams$layout() {
        return streams$LAYOUT;
    }

    private static final long streams$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVStream **streams
     * }
     */
    public static final long streams$offset() {
        return streams$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVStream **streams
     * }
     */
    public static MemorySegment streams(MemorySegment struct) {
        return struct.get(streams$LAYOUT, streams$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVStream **streams
     * }
     */
    public static void streams(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(streams$LAYOUT, streams$OFFSET, fieldValue);
    }

    private static final AddressLayout url$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("url"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *url
     * }
     */
    public static final AddressLayout url$layout() {
        return url$LAYOUT;
    }

    private static final long url$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *url
     * }
     */
    public static final long url$offset() {
        return url$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *url
     * }
     */
    public static MemorySegment url(MemorySegment struct) {
        return struct.get(url$LAYOUT, url$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *url
     * }
     */
    public static void url(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(url$LAYOUT, url$OFFSET, fieldValue);
    }

    private static final OfLong start_time$LAYOUT = (OfLong)$LAYOUT.select(groupElement("start_time"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t start_time
     * }
     */
    public static final OfLong start_time$layout() {
        return start_time$LAYOUT;
    }

    private static final long start_time$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t start_time
     * }
     */
    public static final long start_time$offset() {
        return start_time$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t start_time
     * }
     */
    public static long start_time(MemorySegment struct) {
        return struct.get(start_time$LAYOUT, start_time$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t start_time
     * }
     */
    public static void start_time(MemorySegment struct, long fieldValue) {
        struct.set(start_time$LAYOUT, start_time$OFFSET, fieldValue);
    }

    private static final OfLong duration$LAYOUT = (OfLong)$LAYOUT.select(groupElement("duration"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t duration
     * }
     */
    public static final OfLong duration$layout() {
        return duration$LAYOUT;
    }

    private static final long duration$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t duration
     * }
     */
    public static final long duration$offset() {
        return duration$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t duration
     * }
     */
    public static long duration(MemorySegment struct) {
        return struct.get(duration$LAYOUT, duration$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t duration
     * }
     */
    public static void duration(MemorySegment struct, long fieldValue) {
        struct.set(duration$LAYOUT, duration$OFFSET, fieldValue);
    }

    private static final OfLong bit_rate$LAYOUT = (OfLong)$LAYOUT.select(groupElement("bit_rate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t bit_rate
     * }
     */
    public static final OfLong bit_rate$layout() {
        return bit_rate$LAYOUT;
    }

    private static final long bit_rate$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t bit_rate
     * }
     */
    public static final long bit_rate$offset() {
        return bit_rate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t bit_rate
     * }
     */
    public static long bit_rate(MemorySegment struct) {
        return struct.get(bit_rate$LAYOUT, bit_rate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t bit_rate
     * }
     */
    public static void bit_rate(MemorySegment struct, long fieldValue) {
        struct.set(bit_rate$LAYOUT, bit_rate$OFFSET, fieldValue);
    }

    private static final OfInt packet_size$LAYOUT = (OfInt)$LAYOUT.select(groupElement("packet_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int packet_size
     * }
     */
    public static final OfInt packet_size$layout() {
        return packet_size$LAYOUT;
    }

    private static final long packet_size$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int packet_size
     * }
     */
    public static final long packet_size$offset() {
        return packet_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int packet_size
     * }
     */
    public static int packet_size(MemorySegment struct) {
        return struct.get(packet_size$LAYOUT, packet_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int packet_size
     * }
     */
    public static void packet_size(MemorySegment struct, int fieldValue) {
        struct.set(packet_size$LAYOUT, packet_size$OFFSET, fieldValue);
    }

    private static final OfInt max_delay$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_delay"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_delay
     * }
     */
    public static final OfInt max_delay$layout() {
        return max_delay$LAYOUT;
    }

    private static final long max_delay$OFFSET = 92;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_delay
     * }
     */
    public static final long max_delay$offset() {
        return max_delay$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_delay
     * }
     */
    public static int max_delay(MemorySegment struct) {
        return struct.get(max_delay$LAYOUT, max_delay$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_delay
     * }
     */
    public static void max_delay(MemorySegment struct, int fieldValue) {
        struct.set(max_delay$LAYOUT, max_delay$OFFSET, fieldValue);
    }

    private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int flags
     * }
     */
    public static final OfInt flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int flags
     * }
     */
    public static int flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int flags
     * }
     */
    public static void flags(MemorySegment struct, int fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final OfLong probesize$LAYOUT = (OfLong)$LAYOUT.select(groupElement("probesize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t probesize
     * }
     */
    public static final OfLong probesize$layout() {
        return probesize$LAYOUT;
    }

    private static final long probesize$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t probesize
     * }
     */
    public static final long probesize$offset() {
        return probesize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t probesize
     * }
     */
    public static long probesize(MemorySegment struct) {
        return struct.get(probesize$LAYOUT, probesize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t probesize
     * }
     */
    public static void probesize(MemorySegment struct, long fieldValue) {
        struct.set(probesize$LAYOUT, probesize$OFFSET, fieldValue);
    }

    private static final OfLong max_analyze_duration$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_analyze_duration"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t max_analyze_duration
     * }
     */
    public static final OfLong max_analyze_duration$layout() {
        return max_analyze_duration$LAYOUT;
    }

    private static final long max_analyze_duration$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t max_analyze_duration
     * }
     */
    public static final long max_analyze_duration$offset() {
        return max_analyze_duration$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t max_analyze_duration
     * }
     */
    public static long max_analyze_duration(MemorySegment struct) {
        return struct.get(max_analyze_duration$LAYOUT, max_analyze_duration$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t max_analyze_duration
     * }
     */
    public static void max_analyze_duration(MemorySegment struct, long fieldValue) {
        struct.set(max_analyze_duration$LAYOUT, max_analyze_duration$OFFSET, fieldValue);
    }

    private static final AddressLayout key$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("key"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const uint8_t *key
     * }
     */
    public static final AddressLayout key$layout() {
        return key$LAYOUT;
    }

    private static final long key$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const uint8_t *key
     * }
     */
    public static final long key$offset() {
        return key$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const uint8_t *key
     * }
     */
    public static MemorySegment key(MemorySegment struct) {
        return struct.get(key$LAYOUT, key$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const uint8_t *key
     * }
     */
    public static void key(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(key$LAYOUT, key$OFFSET, fieldValue);
    }

    private static final OfInt keylen$LAYOUT = (OfInt)$LAYOUT.select(groupElement("keylen"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int keylen
     * }
     */
    public static final OfInt keylen$layout() {
        return keylen$LAYOUT;
    }

    private static final long keylen$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int keylen
     * }
     */
    public static final long keylen$offset() {
        return keylen$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int keylen
     * }
     */
    public static int keylen(MemorySegment struct) {
        return struct.get(keylen$LAYOUT, keylen$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int keylen
     * }
     */
    public static void keylen(MemorySegment struct, int fieldValue) {
        struct.set(keylen$LAYOUT, keylen$OFFSET, fieldValue);
    }

    private static final OfInt nb_programs$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nb_programs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int nb_programs
     * }
     */
    public static final OfInt nb_programs$layout() {
        return nb_programs$LAYOUT;
    }

    private static final long nb_programs$OFFSET = 132;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int nb_programs
     * }
     */
    public static final long nb_programs$offset() {
        return nb_programs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int nb_programs
     * }
     */
    public static int nb_programs(MemorySegment struct) {
        return struct.get(nb_programs$LAYOUT, nb_programs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int nb_programs
     * }
     */
    public static void nb_programs(MemorySegment struct, int fieldValue) {
        struct.set(nb_programs$LAYOUT, nb_programs$OFFSET, fieldValue);
    }

    private static final AddressLayout programs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("programs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVProgram **programs
     * }
     */
    public static final AddressLayout programs$layout() {
        return programs$LAYOUT;
    }

    private static final long programs$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVProgram **programs
     * }
     */
    public static final long programs$offset() {
        return programs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVProgram **programs
     * }
     */
    public static MemorySegment programs(MemorySegment struct) {
        return struct.get(programs$LAYOUT, programs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVProgram **programs
     * }
     */
    public static void programs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(programs$LAYOUT, programs$OFFSET, fieldValue);
    }

    private static final OfInt video_codec_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement("video_codec_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum AVCodecID video_codec_id
     * }
     */
    public static final OfInt video_codec_id$layout() {
        return video_codec_id$LAYOUT;
    }

    private static final long video_codec_id$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum AVCodecID video_codec_id
     * }
     */
    public static final long video_codec_id$offset() {
        return video_codec_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum AVCodecID video_codec_id
     * }
     */
    public static int video_codec_id(MemorySegment struct) {
        return struct.get(video_codec_id$LAYOUT, video_codec_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum AVCodecID video_codec_id
     * }
     */
    public static void video_codec_id(MemorySegment struct, int fieldValue) {
        struct.set(video_codec_id$LAYOUT, video_codec_id$OFFSET, fieldValue);
    }

    private static final OfInt audio_codec_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement("audio_codec_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum AVCodecID audio_codec_id
     * }
     */
    public static final OfInt audio_codec_id$layout() {
        return audio_codec_id$LAYOUT;
    }

    private static final long audio_codec_id$OFFSET = 148;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum AVCodecID audio_codec_id
     * }
     */
    public static final long audio_codec_id$offset() {
        return audio_codec_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum AVCodecID audio_codec_id
     * }
     */
    public static int audio_codec_id(MemorySegment struct) {
        return struct.get(audio_codec_id$LAYOUT, audio_codec_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum AVCodecID audio_codec_id
     * }
     */
    public static void audio_codec_id(MemorySegment struct, int fieldValue) {
        struct.set(audio_codec_id$LAYOUT, audio_codec_id$OFFSET, fieldValue);
    }

    private static final OfInt subtitle_codec_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement("subtitle_codec_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum AVCodecID subtitle_codec_id
     * }
     */
    public static final OfInt subtitle_codec_id$layout() {
        return subtitle_codec_id$LAYOUT;
    }

    private static final long subtitle_codec_id$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum AVCodecID subtitle_codec_id
     * }
     */
    public static final long subtitle_codec_id$offset() {
        return subtitle_codec_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum AVCodecID subtitle_codec_id
     * }
     */
    public static int subtitle_codec_id(MemorySegment struct) {
        return struct.get(subtitle_codec_id$LAYOUT, subtitle_codec_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum AVCodecID subtitle_codec_id
     * }
     */
    public static void subtitle_codec_id(MemorySegment struct, int fieldValue) {
        struct.set(subtitle_codec_id$LAYOUT, subtitle_codec_id$OFFSET, fieldValue);
    }

    private static final OfInt max_index_size$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_index_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int max_index_size
     * }
     */
    public static final OfInt max_index_size$layout() {
        return max_index_size$LAYOUT;
    }

    private static final long max_index_size$OFFSET = 156;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int max_index_size
     * }
     */
    public static final long max_index_size$offset() {
        return max_index_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int max_index_size
     * }
     */
    public static int max_index_size(MemorySegment struct) {
        return struct.get(max_index_size$LAYOUT, max_index_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int max_index_size
     * }
     */
    public static void max_index_size(MemorySegment struct, int fieldValue) {
        struct.set(max_index_size$LAYOUT, max_index_size$OFFSET, fieldValue);
    }

    private static final OfInt max_picture_buffer$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_picture_buffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int max_picture_buffer
     * }
     */
    public static final OfInt max_picture_buffer$layout() {
        return max_picture_buffer$LAYOUT;
    }

    private static final long max_picture_buffer$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int max_picture_buffer
     * }
     */
    public static final long max_picture_buffer$offset() {
        return max_picture_buffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int max_picture_buffer
     * }
     */
    public static int max_picture_buffer(MemorySegment struct) {
        return struct.get(max_picture_buffer$LAYOUT, max_picture_buffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int max_picture_buffer
     * }
     */
    public static void max_picture_buffer(MemorySegment struct, int fieldValue) {
        struct.set(max_picture_buffer$LAYOUT, max_picture_buffer$OFFSET, fieldValue);
    }

    private static final OfInt nb_chapters$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nb_chapters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int nb_chapters
     * }
     */
    public static final OfInt nb_chapters$layout() {
        return nb_chapters$LAYOUT;
    }

    private static final long nb_chapters$OFFSET = 164;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int nb_chapters
     * }
     */
    public static final long nb_chapters$offset() {
        return nb_chapters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int nb_chapters
     * }
     */
    public static int nb_chapters(MemorySegment struct) {
        return struct.get(nb_chapters$LAYOUT, nb_chapters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int nb_chapters
     * }
     */
    public static void nb_chapters(MemorySegment struct, int fieldValue) {
        struct.set(nb_chapters$LAYOUT, nb_chapters$OFFSET, fieldValue);
    }

    private static final AddressLayout chapters$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("chapters"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVChapter **chapters
     * }
     */
    public static final AddressLayout chapters$layout() {
        return chapters$LAYOUT;
    }

    private static final long chapters$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVChapter **chapters
     * }
     */
    public static final long chapters$offset() {
        return chapters$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVChapter **chapters
     * }
     */
    public static MemorySegment chapters(MemorySegment struct) {
        return struct.get(chapters$LAYOUT, chapters$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVChapter **chapters
     * }
     */
    public static void chapters(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(chapters$LAYOUT, chapters$OFFSET, fieldValue);
    }

    private static final AddressLayout metadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("metadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVDictionary *metadata
     * }
     */
    public static final AddressLayout metadata$layout() {
        return metadata$LAYOUT;
    }

    private static final long metadata$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVDictionary *metadata
     * }
     */
    public static final long metadata$offset() {
        return metadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVDictionary *metadata
     * }
     */
    public static MemorySegment metadata(MemorySegment struct) {
        return struct.get(metadata$LAYOUT, metadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVDictionary *metadata
     * }
     */
    public static void metadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(metadata$LAYOUT, metadata$OFFSET, fieldValue);
    }

    private static final OfLong start_time_realtime$LAYOUT = (OfLong)$LAYOUT.select(groupElement("start_time_realtime"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t start_time_realtime
     * }
     */
    public static final OfLong start_time_realtime$layout() {
        return start_time_realtime$LAYOUT;
    }

    private static final long start_time_realtime$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t start_time_realtime
     * }
     */
    public static final long start_time_realtime$offset() {
        return start_time_realtime$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t start_time_realtime
     * }
     */
    public static long start_time_realtime(MemorySegment struct) {
        return struct.get(start_time_realtime$LAYOUT, start_time_realtime$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t start_time_realtime
     * }
     */
    public static void start_time_realtime(MemorySegment struct, long fieldValue) {
        struct.set(start_time_realtime$LAYOUT, start_time_realtime$OFFSET, fieldValue);
    }

    private static final OfInt fps_probe_size$LAYOUT = (OfInt)$LAYOUT.select(groupElement("fps_probe_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int fps_probe_size
     * }
     */
    public static final OfInt fps_probe_size$layout() {
        return fps_probe_size$LAYOUT;
    }

    private static final long fps_probe_size$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int fps_probe_size
     * }
     */
    public static final long fps_probe_size$offset() {
        return fps_probe_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int fps_probe_size
     * }
     */
    public static int fps_probe_size(MemorySegment struct) {
        return struct.get(fps_probe_size$LAYOUT, fps_probe_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int fps_probe_size
     * }
     */
    public static void fps_probe_size(MemorySegment struct, int fieldValue) {
        struct.set(fps_probe_size$LAYOUT, fps_probe_size$OFFSET, fieldValue);
    }

    private static final OfInt error_recognition$LAYOUT = (OfInt)$LAYOUT.select(groupElement("error_recognition"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int error_recognition
     * }
     */
    public static final OfInt error_recognition$layout() {
        return error_recognition$LAYOUT;
    }

    private static final long error_recognition$OFFSET = 196;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int error_recognition
     * }
     */
    public static final long error_recognition$offset() {
        return error_recognition$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int error_recognition
     * }
     */
    public static int error_recognition(MemorySegment struct) {
        return struct.get(error_recognition$LAYOUT, error_recognition$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int error_recognition
     * }
     */
    public static void error_recognition(MemorySegment struct, int fieldValue) {
        struct.set(error_recognition$LAYOUT, error_recognition$OFFSET, fieldValue);
    }

    private static final GroupLayout interrupt_callback$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("interrupt_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVIOInterruptCB interrupt_callback
     * }
     */
    public static final GroupLayout interrupt_callback$layout() {
        return interrupt_callback$LAYOUT;
    }

    private static final long interrupt_callback$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVIOInterruptCB interrupt_callback
     * }
     */
    public static final long interrupt_callback$offset() {
        return interrupt_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVIOInterruptCB interrupt_callback
     * }
     */
    public static MemorySegment interrupt_callback(MemorySegment struct) {
        return struct.asSlice(interrupt_callback$OFFSET, interrupt_callback$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVIOInterruptCB interrupt_callback
     * }
     */
    public static void interrupt_callback(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, interrupt_callback$OFFSET, interrupt_callback$LAYOUT.byteSize());
    }

    private static final OfInt debug$LAYOUT = (OfInt)$LAYOUT.select(groupElement("debug"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int debug
     * }
     */
    public static final OfInt debug$layout() {
        return debug$LAYOUT;
    }

    private static final long debug$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int debug
     * }
     */
    public static final long debug$offset() {
        return debug$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int debug
     * }
     */
    public static int debug(MemorySegment struct) {
        return struct.get(debug$LAYOUT, debug$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int debug
     * }
     */
    public static void debug(MemorySegment struct, int fieldValue) {
        struct.set(debug$LAYOUT, debug$OFFSET, fieldValue);
    }

    private static final OfLong max_interleave_delta$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_interleave_delta"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t max_interleave_delta
     * }
     */
    public static final OfLong max_interleave_delta$layout() {
        return max_interleave_delta$LAYOUT;
    }

    private static final long max_interleave_delta$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t max_interleave_delta
     * }
     */
    public static final long max_interleave_delta$offset() {
        return max_interleave_delta$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t max_interleave_delta
     * }
     */
    public static long max_interleave_delta(MemorySegment struct) {
        return struct.get(max_interleave_delta$LAYOUT, max_interleave_delta$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t max_interleave_delta
     * }
     */
    public static void max_interleave_delta(MemorySegment struct, long fieldValue) {
        struct.set(max_interleave_delta$LAYOUT, max_interleave_delta$OFFSET, fieldValue);
    }

    private static final OfInt strict_std_compliance$LAYOUT = (OfInt)$LAYOUT.select(groupElement("strict_std_compliance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int strict_std_compliance
     * }
     */
    public static final OfInt strict_std_compliance$layout() {
        return strict_std_compliance$LAYOUT;
    }

    private static final long strict_std_compliance$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int strict_std_compliance
     * }
     */
    public static final long strict_std_compliance$offset() {
        return strict_std_compliance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int strict_std_compliance
     * }
     */
    public static int strict_std_compliance(MemorySegment struct) {
        return struct.get(strict_std_compliance$LAYOUT, strict_std_compliance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int strict_std_compliance
     * }
     */
    public static void strict_std_compliance(MemorySegment struct, int fieldValue) {
        struct.set(strict_std_compliance$LAYOUT, strict_std_compliance$OFFSET, fieldValue);
    }

    private static final OfInt event_flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("event_flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int event_flags
     * }
     */
    public static final OfInt event_flags$layout() {
        return event_flags$LAYOUT;
    }

    private static final long event_flags$OFFSET = 236;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int event_flags
     * }
     */
    public static final long event_flags$offset() {
        return event_flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int event_flags
     * }
     */
    public static int event_flags(MemorySegment struct) {
        return struct.get(event_flags$LAYOUT, event_flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int event_flags
     * }
     */
    public static void event_flags(MemorySegment struct, int fieldValue) {
        struct.set(event_flags$LAYOUT, event_flags$OFFSET, fieldValue);
    }

    private static final OfInt max_ts_probe$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_ts_probe"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_ts_probe
     * }
     */
    public static final OfInt max_ts_probe$layout() {
        return max_ts_probe$LAYOUT;
    }

    private static final long max_ts_probe$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_ts_probe
     * }
     */
    public static final long max_ts_probe$offset() {
        return max_ts_probe$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_ts_probe
     * }
     */
    public static int max_ts_probe(MemorySegment struct) {
        return struct.get(max_ts_probe$LAYOUT, max_ts_probe$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_ts_probe
     * }
     */
    public static void max_ts_probe(MemorySegment struct, int fieldValue) {
        struct.set(max_ts_probe$LAYOUT, max_ts_probe$OFFSET, fieldValue);
    }

    private static final OfInt avoid_negative_ts$LAYOUT = (OfInt)$LAYOUT.select(groupElement("avoid_negative_ts"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int avoid_negative_ts
     * }
     */
    public static final OfInt avoid_negative_ts$layout() {
        return avoid_negative_ts$LAYOUT;
    }

    private static final long avoid_negative_ts$OFFSET = 244;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int avoid_negative_ts
     * }
     */
    public static final long avoid_negative_ts$offset() {
        return avoid_negative_ts$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int avoid_negative_ts
     * }
     */
    public static int avoid_negative_ts(MemorySegment struct) {
        return struct.get(avoid_negative_ts$LAYOUT, avoid_negative_ts$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int avoid_negative_ts
     * }
     */
    public static void avoid_negative_ts(MemorySegment struct, int fieldValue) {
        struct.set(avoid_negative_ts$LAYOUT, avoid_negative_ts$OFFSET, fieldValue);
    }

    private static final OfInt ts_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ts_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int ts_id
     * }
     */
    public static final OfInt ts_id$layout() {
        return ts_id$LAYOUT;
    }

    private static final long ts_id$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int ts_id
     * }
     */
    public static final long ts_id$offset() {
        return ts_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int ts_id
     * }
     */
    public static int ts_id(MemorySegment struct) {
        return struct.get(ts_id$LAYOUT, ts_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int ts_id
     * }
     */
    public static void ts_id(MemorySegment struct, int fieldValue) {
        struct.set(ts_id$LAYOUT, ts_id$OFFSET, fieldValue);
    }

    private static final OfInt audio_preload$LAYOUT = (OfInt)$LAYOUT.select(groupElement("audio_preload"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int audio_preload
     * }
     */
    public static final OfInt audio_preload$layout() {
        return audio_preload$LAYOUT;
    }

    private static final long audio_preload$OFFSET = 252;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int audio_preload
     * }
     */
    public static final long audio_preload$offset() {
        return audio_preload$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int audio_preload
     * }
     */
    public static int audio_preload(MemorySegment struct) {
        return struct.get(audio_preload$LAYOUT, audio_preload$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int audio_preload
     * }
     */
    public static void audio_preload(MemorySegment struct, int fieldValue) {
        struct.set(audio_preload$LAYOUT, audio_preload$OFFSET, fieldValue);
    }

    private static final OfInt max_chunk_duration$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_chunk_duration"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_chunk_duration
     * }
     */
    public static final OfInt max_chunk_duration$layout() {
        return max_chunk_duration$LAYOUT;
    }

    private static final long max_chunk_duration$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_chunk_duration
     * }
     */
    public static final long max_chunk_duration$offset() {
        return max_chunk_duration$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_chunk_duration
     * }
     */
    public static int max_chunk_duration(MemorySegment struct) {
        return struct.get(max_chunk_duration$LAYOUT, max_chunk_duration$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_chunk_duration
     * }
     */
    public static void max_chunk_duration(MemorySegment struct, int fieldValue) {
        struct.set(max_chunk_duration$LAYOUT, max_chunk_duration$OFFSET, fieldValue);
    }

    private static final OfInt max_chunk_size$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_chunk_size"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_chunk_size
     * }
     */
    public static final OfInt max_chunk_size$layout() {
        return max_chunk_size$LAYOUT;
    }

    private static final long max_chunk_size$OFFSET = 260;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_chunk_size
     * }
     */
    public static final long max_chunk_size$offset() {
        return max_chunk_size$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_chunk_size
     * }
     */
    public static int max_chunk_size(MemorySegment struct) {
        return struct.get(max_chunk_size$LAYOUT, max_chunk_size$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_chunk_size
     * }
     */
    public static void max_chunk_size(MemorySegment struct, int fieldValue) {
        struct.set(max_chunk_size$LAYOUT, max_chunk_size$OFFSET, fieldValue);
    }

    private static final OfInt use_wallclock_as_timestamps$LAYOUT = (OfInt)$LAYOUT.select(groupElement("use_wallclock_as_timestamps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int use_wallclock_as_timestamps
     * }
     */
    public static final OfInt use_wallclock_as_timestamps$layout() {
        return use_wallclock_as_timestamps$LAYOUT;
    }

    private static final long use_wallclock_as_timestamps$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int use_wallclock_as_timestamps
     * }
     */
    public static final long use_wallclock_as_timestamps$offset() {
        return use_wallclock_as_timestamps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int use_wallclock_as_timestamps
     * }
     */
    public static int use_wallclock_as_timestamps(MemorySegment struct) {
        return struct.get(use_wallclock_as_timestamps$LAYOUT, use_wallclock_as_timestamps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int use_wallclock_as_timestamps
     * }
     */
    public static void use_wallclock_as_timestamps(MemorySegment struct, int fieldValue) {
        struct.set(use_wallclock_as_timestamps$LAYOUT, use_wallclock_as_timestamps$OFFSET, fieldValue);
    }

    private static final OfInt avio_flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("avio_flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int avio_flags
     * }
     */
    public static final OfInt avio_flags$layout() {
        return avio_flags$LAYOUT;
    }

    private static final long avio_flags$OFFSET = 268;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int avio_flags
     * }
     */
    public static final long avio_flags$offset() {
        return avio_flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int avio_flags
     * }
     */
    public static int avio_flags(MemorySegment struct) {
        return struct.get(avio_flags$LAYOUT, avio_flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int avio_flags
     * }
     */
    public static void avio_flags(MemorySegment struct, int fieldValue) {
        struct.set(avio_flags$LAYOUT, avio_flags$OFFSET, fieldValue);
    }

    private static final OfInt duration_estimation_method$LAYOUT = (OfInt)$LAYOUT.select(groupElement("duration_estimation_method"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod duration_estimation_method
     * }
     */
    public static final OfInt duration_estimation_method$layout() {
        return duration_estimation_method$LAYOUT;
    }

    private static final long duration_estimation_method$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod duration_estimation_method
     * }
     */
    public static final long duration_estimation_method$offset() {
        return duration_estimation_method$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod duration_estimation_method
     * }
     */
    public static int duration_estimation_method(MemorySegment struct) {
        return struct.get(duration_estimation_method$LAYOUT, duration_estimation_method$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod duration_estimation_method
     * }
     */
    public static void duration_estimation_method(MemorySegment struct, int fieldValue) {
        struct.set(duration_estimation_method$LAYOUT, duration_estimation_method$OFFSET, fieldValue);
    }

    private static final OfLong skip_initial_bytes$LAYOUT = (OfLong)$LAYOUT.select(groupElement("skip_initial_bytes"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t skip_initial_bytes
     * }
     */
    public static final OfLong skip_initial_bytes$layout() {
        return skip_initial_bytes$LAYOUT;
    }

    private static final long skip_initial_bytes$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t skip_initial_bytes
     * }
     */
    public static final long skip_initial_bytes$offset() {
        return skip_initial_bytes$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t skip_initial_bytes
     * }
     */
    public static long skip_initial_bytes(MemorySegment struct) {
        return struct.get(skip_initial_bytes$LAYOUT, skip_initial_bytes$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t skip_initial_bytes
     * }
     */
    public static void skip_initial_bytes(MemorySegment struct, long fieldValue) {
        struct.set(skip_initial_bytes$LAYOUT, skip_initial_bytes$OFFSET, fieldValue);
    }

    private static final OfInt correct_ts_overflow$LAYOUT = (OfInt)$LAYOUT.select(groupElement("correct_ts_overflow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int correct_ts_overflow
     * }
     */
    public static final OfInt correct_ts_overflow$layout() {
        return correct_ts_overflow$LAYOUT;
    }

    private static final long correct_ts_overflow$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int correct_ts_overflow
     * }
     */
    public static final long correct_ts_overflow$offset() {
        return correct_ts_overflow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int correct_ts_overflow
     * }
     */
    public static int correct_ts_overflow(MemorySegment struct) {
        return struct.get(correct_ts_overflow$LAYOUT, correct_ts_overflow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int correct_ts_overflow
     * }
     */
    public static void correct_ts_overflow(MemorySegment struct, int fieldValue) {
        struct.set(correct_ts_overflow$LAYOUT, correct_ts_overflow$OFFSET, fieldValue);
    }

    private static final OfInt seek2any$LAYOUT = (OfInt)$LAYOUT.select(groupElement("seek2any"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int seek2any
     * }
     */
    public static final OfInt seek2any$layout() {
        return seek2any$LAYOUT;
    }

    private static final long seek2any$OFFSET = 292;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int seek2any
     * }
     */
    public static final long seek2any$offset() {
        return seek2any$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int seek2any
     * }
     */
    public static int seek2any(MemorySegment struct) {
        return struct.get(seek2any$LAYOUT, seek2any$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int seek2any
     * }
     */
    public static void seek2any(MemorySegment struct, int fieldValue) {
        struct.set(seek2any$LAYOUT, seek2any$OFFSET, fieldValue);
    }

    private static final OfInt flush_packets$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flush_packets"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int flush_packets
     * }
     */
    public static final OfInt flush_packets$layout() {
        return flush_packets$LAYOUT;
    }

    private static final long flush_packets$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int flush_packets
     * }
     */
    public static final long flush_packets$offset() {
        return flush_packets$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int flush_packets
     * }
     */
    public static int flush_packets(MemorySegment struct) {
        return struct.get(flush_packets$LAYOUT, flush_packets$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int flush_packets
     * }
     */
    public static void flush_packets(MemorySegment struct, int fieldValue) {
        struct.set(flush_packets$LAYOUT, flush_packets$OFFSET, fieldValue);
    }

    private static final OfInt probe_score$LAYOUT = (OfInt)$LAYOUT.select(groupElement("probe_score"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int probe_score
     * }
     */
    public static final OfInt probe_score$layout() {
        return probe_score$LAYOUT;
    }

    private static final long probe_score$OFFSET = 300;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int probe_score
     * }
     */
    public static final long probe_score$offset() {
        return probe_score$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int probe_score
     * }
     */
    public static int probe_score(MemorySegment struct) {
        return struct.get(probe_score$LAYOUT, probe_score$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int probe_score
     * }
     */
    public static void probe_score(MemorySegment struct, int fieldValue) {
        struct.set(probe_score$LAYOUT, probe_score$OFFSET, fieldValue);
    }

    private static final OfInt format_probesize$LAYOUT = (OfInt)$LAYOUT.select(groupElement("format_probesize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int format_probesize
     * }
     */
    public static final OfInt format_probesize$layout() {
        return format_probesize$LAYOUT;
    }

    private static final long format_probesize$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int format_probesize
     * }
     */
    public static final long format_probesize$offset() {
        return format_probesize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int format_probesize
     * }
     */
    public static int format_probesize(MemorySegment struct) {
        return struct.get(format_probesize$LAYOUT, format_probesize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int format_probesize
     * }
     */
    public static void format_probesize(MemorySegment struct, int fieldValue) {
        struct.set(format_probesize$LAYOUT, format_probesize$OFFSET, fieldValue);
    }

    private static final AddressLayout codec_whitelist$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("codec_whitelist"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *codec_whitelist
     * }
     */
    public static final AddressLayout codec_whitelist$layout() {
        return codec_whitelist$LAYOUT;
    }

    private static final long codec_whitelist$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *codec_whitelist
     * }
     */
    public static final long codec_whitelist$offset() {
        return codec_whitelist$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *codec_whitelist
     * }
     */
    public static MemorySegment codec_whitelist(MemorySegment struct) {
        return struct.get(codec_whitelist$LAYOUT, codec_whitelist$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *codec_whitelist
     * }
     */
    public static void codec_whitelist(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(codec_whitelist$LAYOUT, codec_whitelist$OFFSET, fieldValue);
    }

    private static final AddressLayout format_whitelist$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("format_whitelist"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *format_whitelist
     * }
     */
    public static final AddressLayout format_whitelist$layout() {
        return format_whitelist$LAYOUT;
    }

    private static final long format_whitelist$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *format_whitelist
     * }
     */
    public static final long format_whitelist$offset() {
        return format_whitelist$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *format_whitelist
     * }
     */
    public static MemorySegment format_whitelist(MemorySegment struct) {
        return struct.get(format_whitelist$LAYOUT, format_whitelist$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *format_whitelist
     * }
     */
    public static void format_whitelist(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(format_whitelist$LAYOUT, format_whitelist$OFFSET, fieldValue);
    }

    private static final OfInt io_repositioned$LAYOUT = (OfInt)$LAYOUT.select(groupElement("io_repositioned"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int io_repositioned
     * }
     */
    public static final OfInt io_repositioned$layout() {
        return io_repositioned$LAYOUT;
    }

    private static final long io_repositioned$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int io_repositioned
     * }
     */
    public static final long io_repositioned$offset() {
        return io_repositioned$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int io_repositioned
     * }
     */
    public static int io_repositioned(MemorySegment struct) {
        return struct.get(io_repositioned$LAYOUT, io_repositioned$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int io_repositioned
     * }
     */
    public static void io_repositioned(MemorySegment struct, int fieldValue) {
        struct.set(io_repositioned$LAYOUT, io_repositioned$OFFSET, fieldValue);
    }

    private static final AddressLayout video_codec$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("video_codec"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct AVCodec *video_codec
     * }
     */
    public static final AddressLayout video_codec$layout() {
        return video_codec$LAYOUT;
    }

    private static final long video_codec$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct AVCodec *video_codec
     * }
     */
    public static final long video_codec$offset() {
        return video_codec$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct AVCodec *video_codec
     * }
     */
    public static MemorySegment video_codec(MemorySegment struct) {
        return struct.get(video_codec$LAYOUT, video_codec$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct AVCodec *video_codec
     * }
     */
    public static void video_codec(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(video_codec$LAYOUT, video_codec$OFFSET, fieldValue);
    }

    private static final AddressLayout audio_codec$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("audio_codec"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct AVCodec *audio_codec
     * }
     */
    public static final AddressLayout audio_codec$layout() {
        return audio_codec$LAYOUT;
    }

    private static final long audio_codec$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct AVCodec *audio_codec
     * }
     */
    public static final long audio_codec$offset() {
        return audio_codec$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct AVCodec *audio_codec
     * }
     */
    public static MemorySegment audio_codec(MemorySegment struct) {
        return struct.get(audio_codec$LAYOUT, audio_codec$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct AVCodec *audio_codec
     * }
     */
    public static void audio_codec(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(audio_codec$LAYOUT, audio_codec$OFFSET, fieldValue);
    }

    private static final AddressLayout subtitle_codec$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("subtitle_codec"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct AVCodec *subtitle_codec
     * }
     */
    public static final AddressLayout subtitle_codec$layout() {
        return subtitle_codec$LAYOUT;
    }

    private static final long subtitle_codec$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct AVCodec *subtitle_codec
     * }
     */
    public static final long subtitle_codec$offset() {
        return subtitle_codec$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct AVCodec *subtitle_codec
     * }
     */
    public static MemorySegment subtitle_codec(MemorySegment struct) {
        return struct.get(subtitle_codec$LAYOUT, subtitle_codec$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct AVCodec *subtitle_codec
     * }
     */
    public static void subtitle_codec(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(subtitle_codec$LAYOUT, subtitle_codec$OFFSET, fieldValue);
    }

    private static final AddressLayout data_codec$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("data_codec"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct AVCodec *data_codec
     * }
     */
    public static final AddressLayout data_codec$layout() {
        return data_codec$LAYOUT;
    }

    private static final long data_codec$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct AVCodec *data_codec
     * }
     */
    public static final long data_codec$offset() {
        return data_codec$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct AVCodec *data_codec
     * }
     */
    public static MemorySegment data_codec(MemorySegment struct) {
        return struct.get(data_codec$LAYOUT, data_codec$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct AVCodec *data_codec
     * }
     */
    public static void data_codec(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(data_codec$LAYOUT, data_codec$OFFSET, fieldValue);
    }

    private static final OfInt metadata_header_padding$LAYOUT = (OfInt)$LAYOUT.select(groupElement("metadata_header_padding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int metadata_header_padding
     * }
     */
    public static final OfInt metadata_header_padding$layout() {
        return metadata_header_padding$LAYOUT;
    }

    private static final long metadata_header_padding$OFFSET = 368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int metadata_header_padding
     * }
     */
    public static final long metadata_header_padding$offset() {
        return metadata_header_padding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int metadata_header_padding
     * }
     */
    public static int metadata_header_padding(MemorySegment struct) {
        return struct.get(metadata_header_padding$LAYOUT, metadata_header_padding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int metadata_header_padding
     * }
     */
    public static void metadata_header_padding(MemorySegment struct, int fieldValue) {
        struct.set(metadata_header_padding$LAYOUT, metadata_header_padding$OFFSET, fieldValue);
    }

    private static final AddressLayout opaque$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("opaque"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *opaque
     * }
     */
    public static final AddressLayout opaque$layout() {
        return opaque$LAYOUT;
    }

    private static final long opaque$OFFSET = 376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *opaque
     * }
     */
    public static final long opaque$offset() {
        return opaque$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *opaque
     * }
     */
    public static MemorySegment opaque(MemorySegment struct) {
        return struct.get(opaque$LAYOUT, opaque$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *opaque
     * }
     */
    public static void opaque(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(opaque$LAYOUT, opaque$OFFSET, fieldValue);
    }

    private static final AddressLayout control_message_cb$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("control_message_cb"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * av_format_control_message control_message_cb
     * }
     */
    public static final AddressLayout control_message_cb$layout() {
        return control_message_cb$LAYOUT;
    }

    private static final long control_message_cb$OFFSET = 384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * av_format_control_message control_message_cb
     * }
     */
    public static final long control_message_cb$offset() {
        return control_message_cb$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * av_format_control_message control_message_cb
     * }
     */
    public static MemorySegment control_message_cb(MemorySegment struct) {
        return struct.get(control_message_cb$LAYOUT, control_message_cb$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * av_format_control_message control_message_cb
     * }
     */
    public static void control_message_cb(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(control_message_cb$LAYOUT, control_message_cb$OFFSET, fieldValue);
    }

    private static final OfLong output_ts_offset$LAYOUT = (OfLong)$LAYOUT.select(groupElement("output_ts_offset"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int64_t output_ts_offset
     * }
     */
    public static final OfLong output_ts_offset$layout() {
        return output_ts_offset$LAYOUT;
    }

    private static final long output_ts_offset$OFFSET = 392;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int64_t output_ts_offset
     * }
     */
    public static final long output_ts_offset$offset() {
        return output_ts_offset$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int64_t output_ts_offset
     * }
     */
    public static long output_ts_offset(MemorySegment struct) {
        return struct.get(output_ts_offset$LAYOUT, output_ts_offset$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int64_t output_ts_offset
     * }
     */
    public static void output_ts_offset(MemorySegment struct, long fieldValue) {
        struct.set(output_ts_offset$LAYOUT, output_ts_offset$OFFSET, fieldValue);
    }

    private static final AddressLayout dump_separator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("dump_separator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint8_t *dump_separator
     * }
     */
    public static final AddressLayout dump_separator$layout() {
        return dump_separator$LAYOUT;
    }

    private static final long dump_separator$OFFSET = 400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint8_t *dump_separator
     * }
     */
    public static final long dump_separator$offset() {
        return dump_separator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint8_t *dump_separator
     * }
     */
    public static MemorySegment dump_separator(MemorySegment struct) {
        return struct.get(dump_separator$LAYOUT, dump_separator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint8_t *dump_separator
     * }
     */
    public static void dump_separator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(dump_separator$LAYOUT, dump_separator$OFFSET, fieldValue);
    }

    private static final OfInt data_codec_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement("data_codec_id"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum AVCodecID data_codec_id
     * }
     */
    public static final OfInt data_codec_id$layout() {
        return data_codec_id$LAYOUT;
    }

    private static final long data_codec_id$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum AVCodecID data_codec_id
     * }
     */
    public static final long data_codec_id$offset() {
        return data_codec_id$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum AVCodecID data_codec_id
     * }
     */
    public static int data_codec_id(MemorySegment struct) {
        return struct.get(data_codec_id$LAYOUT, data_codec_id$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum AVCodecID data_codec_id
     * }
     */
    public static void data_codec_id(MemorySegment struct, int fieldValue) {
        struct.set(data_codec_id$LAYOUT, data_codec_id$OFFSET, fieldValue);
    }

    private static final AddressLayout protocol_whitelist$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("protocol_whitelist"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *protocol_whitelist
     * }
     */
    public static final AddressLayout protocol_whitelist$layout() {
        return protocol_whitelist$LAYOUT;
    }

    private static final long protocol_whitelist$OFFSET = 416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *protocol_whitelist
     * }
     */
    public static final long protocol_whitelist$offset() {
        return protocol_whitelist$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *protocol_whitelist
     * }
     */
    public static MemorySegment protocol_whitelist(MemorySegment struct) {
        return struct.get(protocol_whitelist$LAYOUT, protocol_whitelist$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *protocol_whitelist
     * }
     */
    public static void protocol_whitelist(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(protocol_whitelist$LAYOUT, protocol_whitelist$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*io_open)(struct AVFormatContext *, AVIOContext **, const char *, int, AVDictionary **)
     * }
     */
    public static class io_open {

        io_open() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = FFmpeg.upcallHandle(io_open.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(io_open.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout io_open$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("io_open"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*io_open)(struct AVFormatContext *, AVIOContext **, const char *, int, AVDictionary **)
     * }
     */
    public static final AddressLayout io_open$layout() {
        return io_open$LAYOUT;
    }

    private static final long io_open$OFFSET = 424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*io_open)(struct AVFormatContext *, AVIOContext **, const char *, int, AVDictionary **)
     * }
     */
    public static final long io_open$offset() {
        return io_open$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*io_open)(struct AVFormatContext *, AVIOContext **, const char *, int, AVDictionary **)
     * }
     */
    public static MemorySegment io_open(MemorySegment struct) {
        return struct.get(io_open$LAYOUT, io_open$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*io_open)(struct AVFormatContext *, AVIOContext **, const char *, int, AVDictionary **)
     * }
     */
    public static void io_open(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(io_open$LAYOUT, io_open$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * void (*io_close)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static class io_close {

        io_close() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = FFmpeg.upcallHandle(io_close.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(io_close.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout io_close$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("io_close"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*io_close)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static final AddressLayout io_close$layout() {
        return io_close$LAYOUT;
    }

    private static final long io_close$OFFSET = 432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*io_close)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static final long io_close$offset() {
        return io_close$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*io_close)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static MemorySegment io_close(MemorySegment struct) {
        return struct.get(io_close$LAYOUT, io_close$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*io_close)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static void io_close(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(io_close$LAYOUT, io_close$OFFSET, fieldValue);
    }

    private static final AddressLayout protocol_blacklist$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("protocol_blacklist"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *protocol_blacklist
     * }
     */
    public static final AddressLayout protocol_blacklist$layout() {
        return protocol_blacklist$LAYOUT;
    }

    private static final long protocol_blacklist$OFFSET = 440;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *protocol_blacklist
     * }
     */
    public static final long protocol_blacklist$offset() {
        return protocol_blacklist$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *protocol_blacklist
     * }
     */
    public static MemorySegment protocol_blacklist(MemorySegment struct) {
        return struct.get(protocol_blacklist$LAYOUT, protocol_blacklist$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *protocol_blacklist
     * }
     */
    public static void protocol_blacklist(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(protocol_blacklist$LAYOUT, protocol_blacklist$OFFSET, fieldValue);
    }

    private static final OfInt max_streams$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_streams"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_streams
     * }
     */
    public static final OfInt max_streams$layout() {
        return max_streams$LAYOUT;
    }

    private static final long max_streams$OFFSET = 448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_streams
     * }
     */
    public static final long max_streams$offset() {
        return max_streams$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_streams
     * }
     */
    public static int max_streams(MemorySegment struct) {
        return struct.get(max_streams$LAYOUT, max_streams$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_streams
     * }
     */
    public static void max_streams(MemorySegment struct, int fieldValue) {
        struct.set(max_streams$LAYOUT, max_streams$OFFSET, fieldValue);
    }

    private static final OfInt skip_estimate_duration_from_pts$LAYOUT = (OfInt)$LAYOUT.select(groupElement("skip_estimate_duration_from_pts"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int skip_estimate_duration_from_pts
     * }
     */
    public static final OfInt skip_estimate_duration_from_pts$layout() {
        return skip_estimate_duration_from_pts$LAYOUT;
    }

    private static final long skip_estimate_duration_from_pts$OFFSET = 452;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int skip_estimate_duration_from_pts
     * }
     */
    public static final long skip_estimate_duration_from_pts$offset() {
        return skip_estimate_duration_from_pts$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int skip_estimate_duration_from_pts
     * }
     */
    public static int skip_estimate_duration_from_pts(MemorySegment struct) {
        return struct.get(skip_estimate_duration_from_pts$LAYOUT, skip_estimate_duration_from_pts$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int skip_estimate_duration_from_pts
     * }
     */
    public static void skip_estimate_duration_from_pts(MemorySegment struct, int fieldValue) {
        struct.set(skip_estimate_duration_from_pts$LAYOUT, skip_estimate_duration_from_pts$OFFSET, fieldValue);
    }

    private static final OfInt max_probe_packets$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_probe_packets"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_probe_packets
     * }
     */
    public static final OfInt max_probe_packets$layout() {
        return max_probe_packets$LAYOUT;
    }

    private static final long max_probe_packets$OFFSET = 456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_probe_packets
     * }
     */
    public static final long max_probe_packets$offset() {
        return max_probe_packets$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_probe_packets
     * }
     */
    public static int max_probe_packets(MemorySegment struct) {
        return struct.get(max_probe_packets$LAYOUT, max_probe_packets$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_probe_packets
     * }
     */
    public static void max_probe_packets(MemorySegment struct, int fieldValue) {
        struct.set(max_probe_packets$LAYOUT, max_probe_packets$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*io_close2)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static class io_close2 {

        io_close2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = FFmpeg.upcallHandle(io_close2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(io_close2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout io_close2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("io_close2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*io_close2)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static final AddressLayout io_close2$layout() {
        return io_close2$LAYOUT;
    }

    private static final long io_close2$OFFSET = 464;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*io_close2)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static final long io_close2$offset() {
        return io_close2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*io_close2)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static MemorySegment io_close2(MemorySegment struct) {
        return struct.get(io_close2$LAYOUT, io_close2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*io_close2)(struct AVFormatContext *, AVIOContext *)
     * }
     */
    public static void io_close2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(io_close2$LAYOUT, io_close2$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

