// Generated by jextract

package io.github.chrisribble.ffmpeg5;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class FFmpeg_1 extends FFmpeg_2 {

    FFmpeg_1() {
        // Should not be called directly
    }

    private static class av_hwdevice_ctx_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwdevice_ctx_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_alloc$descriptor() {
        return av_hwdevice_ctx_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_alloc$handle() {
        return av_hwdevice_ctx_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_alloc$address() {
        return av_hwdevice_ctx_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_alloc(int type) {
        var mh$ = av_hwdevice_ctx_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_alloc", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwdevice_ctx_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_init$descriptor() {
        return av_hwdevice_ctx_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_init$handle() {
        return av_hwdevice_ctx_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_init$address() {
        return av_hwdevice_ctx_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static int av_hwdevice_ctx_init(MemorySegment ref) {
        var mh$ = av_hwdevice_ctx_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_init", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwdevice_ctx_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_create$descriptor() {
        return av_hwdevice_ctx_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_create$handle() {
        return av_hwdevice_ctx_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_create$address() {
        return av_hwdevice_ctx_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static int av_hwdevice_ctx_create(MemorySegment device_ctx, int type, MemorySegment device, MemorySegment opts, int flags) {
        var mh$ = av_hwdevice_ctx_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_create", device_ctx, type, device, opts, flags);
            }
            return (int)mh$.invokeExact(device_ctx, type, device, opts, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_create_derived {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwdevice_ctx_create_derived");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_create_derived$descriptor() {
        return av_hwdevice_ctx_create_derived.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_create_derived$handle() {
        return av_hwdevice_ctx_create_derived.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_create_derived$address() {
        return av_hwdevice_ctx_create_derived.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static int av_hwdevice_ctx_create_derived(MemorySegment dst_ctx, int type, MemorySegment src_ctx, int flags) {
        var mh$ = av_hwdevice_ctx_create_derived.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_create_derived", dst_ctx, type, src_ctx, flags);
            }
            return (int)mh$.invokeExact(dst_ctx, type, src_ctx, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_create_derived_opts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwdevice_ctx_create_derived_opts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_create_derived_opts$descriptor() {
        return av_hwdevice_ctx_create_derived_opts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_create_derived_opts$handle() {
        return av_hwdevice_ctx_create_derived_opts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_create_derived_opts$address() {
        return av_hwdevice_ctx_create_derived_opts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static int av_hwdevice_ctx_create_derived_opts(MemorySegment dst_ctx, int type, MemorySegment src_ctx, MemorySegment options, int flags) {
        var mh$ = av_hwdevice_ctx_create_derived_opts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_create_derived_opts", dst_ctx, type, src_ctx, options, flags);
            }
            return (int)mh$.invokeExact(dst_ctx, type, src_ctx, options, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_ctx_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_ctx_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static FunctionDescriptor av_hwframe_ctx_alloc$descriptor() {
        return av_hwframe_ctx_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MethodHandle av_hwframe_ctx_alloc$handle() {
        return av_hwframe_ctx_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwframe_ctx_alloc$address() {
        return av_hwframe_ctx_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwframe_ctx_alloc(MemorySegment device_ctx) {
        var mh$ = av_hwframe_ctx_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_ctx_alloc", device_ctx);
            }
            return (MemorySegment)mh$.invokeExact(device_ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_ctx_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_ctx_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static FunctionDescriptor av_hwframe_ctx_init$descriptor() {
        return av_hwframe_ctx_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MethodHandle av_hwframe_ctx_init$handle() {
        return av_hwframe_ctx_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_hwframe_ctx_init$address() {
        return av_hwframe_ctx_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static int av_hwframe_ctx_init(MemorySegment ref) {
        var mh$ = av_hwframe_ctx_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_ctx_init", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_get_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_get_buffer$descriptor() {
        return av_hwframe_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_hwframe_get_buffer$handle() {
        return av_hwframe_get_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment av_hwframe_get_buffer$address() {
        return av_hwframe_get_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static int av_hwframe_get_buffer(MemorySegment hwframe_ctx, MemorySegment frame, int flags) {
        var mh$ = av_hwframe_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_get_buffer", hwframe_ctx, frame, flags);
            }
            return (int)mh$.invokeExact(hwframe_ctx, frame, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_transfer_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_transfer_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_transfer_data$descriptor() {
        return av_hwframe_transfer_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MethodHandle av_hwframe_transfer_data$handle() {
        return av_hwframe_transfer_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MemorySegment av_hwframe_transfer_data$address() {
        return av_hwframe_transfer_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static int av_hwframe_transfer_data(MemorySegment dst, MemorySegment src, int flags) {
        var mh$ = av_hwframe_transfer_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_transfer_data", dst, src, flags);
            }
            return (int)mh$.invokeExact(dst, src, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_HWFRAME_TRANSFER_DIRECTION_FROM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVHWFrameTransferDirection.AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0
     * }
     */
    public static int AV_HWFRAME_TRANSFER_DIRECTION_FROM() {
        return AV_HWFRAME_TRANSFER_DIRECTION_FROM;
    }
    private static final int AV_HWFRAME_TRANSFER_DIRECTION_TO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVHWFrameTransferDirection.AV_HWFRAME_TRANSFER_DIRECTION_TO = 1
     * }
     */
    public static int AV_HWFRAME_TRANSFER_DIRECTION_TO() {
        return AV_HWFRAME_TRANSFER_DIRECTION_TO;
    }

    private static class av_hwframe_transfer_get_formats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_transfer_get_formats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_transfer_get_formats$descriptor() {
        return av_hwframe_transfer_get_formats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static MethodHandle av_hwframe_transfer_get_formats$handle() {
        return av_hwframe_transfer_get_formats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static MemorySegment av_hwframe_transfer_get_formats$address() {
        return av_hwframe_transfer_get_formats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static int av_hwframe_transfer_get_formats(MemorySegment hwframe_ctx, int dir, MemorySegment formats, int flags) {
        var mh$ = av_hwframe_transfer_get_formats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_transfer_get_formats", hwframe_ctx, dir, formats, flags);
            }
            return (int)mh$.invokeExact(hwframe_ctx, dir, formats, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_hwconfig_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwdevice_hwconfig_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static FunctionDescriptor av_hwdevice_hwconfig_alloc$descriptor() {
        return av_hwdevice_hwconfig_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MethodHandle av_hwdevice_hwconfig_alloc$handle() {
        return av_hwdevice_hwconfig_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwdevice_hwconfig_alloc$address() {
        return av_hwdevice_hwconfig_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwdevice_hwconfig_alloc(MemorySegment device_ctx) {
        var mh$ = av_hwdevice_hwconfig_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_hwconfig_alloc", device_ctx);
            }
            return (MemorySegment)mh$.invokeExact(device_ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_get_hwframe_constraints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwdevice_get_hwframe_constraints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static FunctionDescriptor av_hwdevice_get_hwframe_constraints$descriptor() {
        return av_hwdevice_get_hwframe_constraints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static MethodHandle av_hwdevice_get_hwframe_constraints$handle() {
        return av_hwdevice_get_hwframe_constraints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static MemorySegment av_hwdevice_get_hwframe_constraints$address() {
        return av_hwdevice_get_hwframe_constraints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static MemorySegment av_hwdevice_get_hwframe_constraints(MemorySegment ref, MemorySegment hwconfig) {
        var mh$ = av_hwdevice_get_hwframe_constraints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_get_hwframe_constraints", ref, hwconfig);
            }
            return (MemorySegment)mh$.invokeExact(ref, hwconfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_constraints_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_constraints_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static FunctionDescriptor av_hwframe_constraints_free$descriptor() {
        return av_hwframe_constraints_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static MethodHandle av_hwframe_constraints_free$handle() {
        return av_hwframe_constraints_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static MemorySegment av_hwframe_constraints_free$address() {
        return av_hwframe_constraints_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static void av_hwframe_constraints_free(MemorySegment constraints) {
        var mh$ = av_hwframe_constraints_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_constraints_free", constraints);
            }
            mh$.invokeExact(constraints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_HWFRAME_MAP_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_READ = 1
     * }
     */
    public static int AV_HWFRAME_MAP_READ() {
        return AV_HWFRAME_MAP_READ;
    }
    private static final int AV_HWFRAME_MAP_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_WRITE = 2
     * }
     */
    public static int AV_HWFRAME_MAP_WRITE() {
        return AV_HWFRAME_MAP_WRITE;
    }
    private static final int AV_HWFRAME_MAP_OVERWRITE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_OVERWRITE = 4
     * }
     */
    public static int AV_HWFRAME_MAP_OVERWRITE() {
        return AV_HWFRAME_MAP_OVERWRITE;
    }
    private static final int AV_HWFRAME_MAP_DIRECT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_DIRECT = 8
     * }
     */
    public static int AV_HWFRAME_MAP_DIRECT() {
        return AV_HWFRAME_MAP_DIRECT;
    }

    private static class av_hwframe_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_map$descriptor() {
        return av_hwframe_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MethodHandle av_hwframe_map$handle() {
        return av_hwframe_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MemorySegment av_hwframe_map$address() {
        return av_hwframe_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static int av_hwframe_map(MemorySegment dst, MemorySegment src, int flags) {
        var mh$ = av_hwframe_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_map", dst, src, flags);
            }
            return (int)mh$.invokeExact(dst, src, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_ctx_create_derived {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hwframe_ctx_create_derived");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_ctx_create_derived$descriptor() {
        return av_hwframe_ctx_create_derived.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static MethodHandle av_hwframe_ctx_create_derived$handle() {
        return av_hwframe_ctx_create_derived.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static MemorySegment av_hwframe_ctx_create_derived$address() {
        return av_hwframe_ctx_create_derived.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static int av_hwframe_ctx_create_derived(MemorySegment derived_frame_ctx, int format, MemorySegment derived_device_ctx, MemorySegment source_frame_ctx, int flags) {
        var mh$ = av_hwframe_ctx_create_derived.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_ctx_create_derived", derived_frame_ctx, format, derived_device_ctx, source_frame_ctx, flags);
            }
            return (int)mh$.invokeExact(derived_frame_ctx, format, derived_device_ctx, source_frame_ctx, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CODEC_ID_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_NONE = 0
     * }
     */
    public static int AV_CODEC_ID_NONE() {
        return AV_CODEC_ID_NONE;
    }
    private static final int AV_CODEC_ID_MPEG1VIDEO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MPEG1VIDEO = 1
     * }
     */
    public static int AV_CODEC_ID_MPEG1VIDEO() {
        return AV_CODEC_ID_MPEG1VIDEO;
    }
    private static final int AV_CODEC_ID_MPEG2VIDEO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MPEG2VIDEO = 2
     * }
     */
    public static int AV_CODEC_ID_MPEG2VIDEO() {
        return AV_CODEC_ID_MPEG2VIDEO;
    }
    private static final int AV_CODEC_ID_H261 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_H261 = 3
     * }
     */
    public static int AV_CODEC_ID_H261() {
        return AV_CODEC_ID_H261;
    }
    private static final int AV_CODEC_ID_H263 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_H263 = 4
     * }
     */
    public static int AV_CODEC_ID_H263() {
        return AV_CODEC_ID_H263;
    }
    private static final int AV_CODEC_ID_RV10 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RV10 = 5
     * }
     */
    public static int AV_CODEC_ID_RV10() {
        return AV_CODEC_ID_RV10;
    }
    private static final int AV_CODEC_ID_RV20 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RV20 = 6
     * }
     */
    public static int AV_CODEC_ID_RV20() {
        return AV_CODEC_ID_RV20;
    }
    private static final int AV_CODEC_ID_MJPEG = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MJPEG = 7
     * }
     */
    public static int AV_CODEC_ID_MJPEG() {
        return AV_CODEC_ID_MJPEG;
    }
    private static final int AV_CODEC_ID_MJPEGB = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MJPEGB = 8
     * }
     */
    public static int AV_CODEC_ID_MJPEGB() {
        return AV_CODEC_ID_MJPEGB;
    }
    private static final int AV_CODEC_ID_LJPEG = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_LJPEG = 9
     * }
     */
    public static int AV_CODEC_ID_LJPEG() {
        return AV_CODEC_ID_LJPEG;
    }
    private static final int AV_CODEC_ID_SP5X = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SP5X = 10
     * }
     */
    public static int AV_CODEC_ID_SP5X() {
        return AV_CODEC_ID_SP5X;
    }
    private static final int AV_CODEC_ID_JPEGLS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_JPEGLS = 11
     * }
     */
    public static int AV_CODEC_ID_JPEGLS() {
        return AV_CODEC_ID_JPEGLS;
    }
    private static final int AV_CODEC_ID_MPEG4 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MPEG4 = 12
     * }
     */
    public static int AV_CODEC_ID_MPEG4() {
        return AV_CODEC_ID_MPEG4;
    }
    private static final int AV_CODEC_ID_RAWVIDEO = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RAWVIDEO = 13
     * }
     */
    public static int AV_CODEC_ID_RAWVIDEO() {
        return AV_CODEC_ID_RAWVIDEO;
    }
    private static final int AV_CODEC_ID_MSMPEG4V1 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSMPEG4V1 = 14
     * }
     */
    public static int AV_CODEC_ID_MSMPEG4V1() {
        return AV_CODEC_ID_MSMPEG4V1;
    }
    private static final int AV_CODEC_ID_MSMPEG4V2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSMPEG4V2 = 15
     * }
     */
    public static int AV_CODEC_ID_MSMPEG4V2() {
        return AV_CODEC_ID_MSMPEG4V2;
    }
    private static final int AV_CODEC_ID_MSMPEG4V3 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSMPEG4V3 = 16
     * }
     */
    public static int AV_CODEC_ID_MSMPEG4V3() {
        return AV_CODEC_ID_MSMPEG4V3;
    }
    private static final int AV_CODEC_ID_WMV1 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMV1 = 17
     * }
     */
    public static int AV_CODEC_ID_WMV1() {
        return AV_CODEC_ID_WMV1;
    }
    private static final int AV_CODEC_ID_WMV2 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMV2 = 18
     * }
     */
    public static int AV_CODEC_ID_WMV2() {
        return AV_CODEC_ID_WMV2;
    }
    private static final int AV_CODEC_ID_H263P = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_H263P = 19
     * }
     */
    public static int AV_CODEC_ID_H263P() {
        return AV_CODEC_ID_H263P;
    }
    private static final int AV_CODEC_ID_H263I = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_H263I = 20
     * }
     */
    public static int AV_CODEC_ID_H263I() {
        return AV_CODEC_ID_H263I;
    }
    private static final int AV_CODEC_ID_FLV1 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FLV1 = 21
     * }
     */
    public static int AV_CODEC_ID_FLV1() {
        return AV_CODEC_ID_FLV1;
    }
    private static final int AV_CODEC_ID_SVQ1 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SVQ1 = 22
     * }
     */
    public static int AV_CODEC_ID_SVQ1() {
        return AV_CODEC_ID_SVQ1;
    }
    private static final int AV_CODEC_ID_SVQ3 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SVQ3 = 23
     * }
     */
    public static int AV_CODEC_ID_SVQ3() {
        return AV_CODEC_ID_SVQ3;
    }
    private static final int AV_CODEC_ID_DVVIDEO = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DVVIDEO = 24
     * }
     */
    public static int AV_CODEC_ID_DVVIDEO() {
        return AV_CODEC_ID_DVVIDEO;
    }
    private static final int AV_CODEC_ID_HUFFYUV = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HUFFYUV = 25
     * }
     */
    public static int AV_CODEC_ID_HUFFYUV() {
        return AV_CODEC_ID_HUFFYUV;
    }
    private static final int AV_CODEC_ID_CYUV = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CYUV = 26
     * }
     */
    public static int AV_CODEC_ID_CYUV() {
        return AV_CODEC_ID_CYUV;
    }
    private static final int AV_CODEC_ID_H264 = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_H264 = 27
     * }
     */
    public static int AV_CODEC_ID_H264() {
        return AV_CODEC_ID_H264;
    }
    private static final int AV_CODEC_ID_INDEO3 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_INDEO3 = 28
     * }
     */
    public static int AV_CODEC_ID_INDEO3() {
        return AV_CODEC_ID_INDEO3;
    }
    private static final int AV_CODEC_ID_VP3 = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP3 = 29
     * }
     */
    public static int AV_CODEC_ID_VP3() {
        return AV_CODEC_ID_VP3;
    }
    private static final int AV_CODEC_ID_THEORA = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_THEORA = 30
     * }
     */
    public static int AV_CODEC_ID_THEORA() {
        return AV_CODEC_ID_THEORA;
    }
    private static final int AV_CODEC_ID_ASV1 = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ASV1 = 31
     * }
     */
    public static int AV_CODEC_ID_ASV1() {
        return AV_CODEC_ID_ASV1;
    }
    private static final int AV_CODEC_ID_ASV2 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ASV2 = 32
     * }
     */
    public static int AV_CODEC_ID_ASV2() {
        return AV_CODEC_ID_ASV2;
    }
    private static final int AV_CODEC_ID_FFV1 = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FFV1 = 33
     * }
     */
    public static int AV_CODEC_ID_FFV1() {
        return AV_CODEC_ID_FFV1;
    }
    private static final int AV_CODEC_ID_4XM = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_4XM = 34
     * }
     */
    public static int AV_CODEC_ID_4XM() {
        return AV_CODEC_ID_4XM;
    }
    private static final int AV_CODEC_ID_VCR1 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VCR1 = 35
     * }
     */
    public static int AV_CODEC_ID_VCR1() {
        return AV_CODEC_ID_VCR1;
    }
    private static final int AV_CODEC_ID_CLJR = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CLJR = 36
     * }
     */
    public static int AV_CODEC_ID_CLJR() {
        return AV_CODEC_ID_CLJR;
    }
    private static final int AV_CODEC_ID_MDEC = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MDEC = 37
     * }
     */
    public static int AV_CODEC_ID_MDEC() {
        return AV_CODEC_ID_MDEC;
    }
    private static final int AV_CODEC_ID_ROQ = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ROQ = 38
     * }
     */
    public static int AV_CODEC_ID_ROQ() {
        return AV_CODEC_ID_ROQ;
    }
    private static final int AV_CODEC_ID_INTERPLAY_VIDEO = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_INTERPLAY_VIDEO = 39
     * }
     */
    public static int AV_CODEC_ID_INTERPLAY_VIDEO() {
        return AV_CODEC_ID_INTERPLAY_VIDEO;
    }
    private static final int AV_CODEC_ID_XAN_WC3 = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XAN_WC3 = 40
     * }
     */
    public static int AV_CODEC_ID_XAN_WC3() {
        return AV_CODEC_ID_XAN_WC3;
    }
    private static final int AV_CODEC_ID_XAN_WC4 = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XAN_WC4 = 41
     * }
     */
    public static int AV_CODEC_ID_XAN_WC4() {
        return AV_CODEC_ID_XAN_WC4;
    }
    private static final int AV_CODEC_ID_RPZA = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RPZA = 42
     * }
     */
    public static int AV_CODEC_ID_RPZA() {
        return AV_CODEC_ID_RPZA;
    }
    private static final int AV_CODEC_ID_CINEPAK = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CINEPAK = 43
     * }
     */
    public static int AV_CODEC_ID_CINEPAK() {
        return AV_CODEC_ID_CINEPAK;
    }
    private static final int AV_CODEC_ID_WS_VQA = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WS_VQA = 44
     * }
     */
    public static int AV_CODEC_ID_WS_VQA() {
        return AV_CODEC_ID_WS_VQA;
    }
    private static final int AV_CODEC_ID_MSRLE = (int)45L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSRLE = 45
     * }
     */
    public static int AV_CODEC_ID_MSRLE() {
        return AV_CODEC_ID_MSRLE;
    }
    private static final int AV_CODEC_ID_MSVIDEO1 = (int)46L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSVIDEO1 = 46
     * }
     */
    public static int AV_CODEC_ID_MSVIDEO1() {
        return AV_CODEC_ID_MSVIDEO1;
    }
    private static final int AV_CODEC_ID_IDCIN = (int)47L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IDCIN = 47
     * }
     */
    public static int AV_CODEC_ID_IDCIN() {
        return AV_CODEC_ID_IDCIN;
    }
    private static final int AV_CODEC_ID_8BPS = (int)48L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_8BPS = 48
     * }
     */
    public static int AV_CODEC_ID_8BPS() {
        return AV_CODEC_ID_8BPS;
    }
    private static final int AV_CODEC_ID_SMC = (int)49L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SMC = 49
     * }
     */
    public static int AV_CODEC_ID_SMC() {
        return AV_CODEC_ID_SMC;
    }
    private static final int AV_CODEC_ID_FLIC = (int)50L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FLIC = 50
     * }
     */
    public static int AV_CODEC_ID_FLIC() {
        return AV_CODEC_ID_FLIC;
    }
    private static final int AV_CODEC_ID_TRUEMOTION1 = (int)51L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TRUEMOTION1 = 51
     * }
     */
    public static int AV_CODEC_ID_TRUEMOTION1() {
        return AV_CODEC_ID_TRUEMOTION1;
    }
    private static final int AV_CODEC_ID_VMDVIDEO = (int)52L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VMDVIDEO = 52
     * }
     */
    public static int AV_CODEC_ID_VMDVIDEO() {
        return AV_CODEC_ID_VMDVIDEO;
    }
    private static final int AV_CODEC_ID_MSZH = (int)53L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSZH = 53
     * }
     */
    public static int AV_CODEC_ID_MSZH() {
        return AV_CODEC_ID_MSZH;
    }
    private static final int AV_CODEC_ID_ZLIB = (int)54L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ZLIB = 54
     * }
     */
    public static int AV_CODEC_ID_ZLIB() {
        return AV_CODEC_ID_ZLIB;
    }
    private static final int AV_CODEC_ID_QTRLE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_QTRLE = 55
     * }
     */
    public static int AV_CODEC_ID_QTRLE() {
        return AV_CODEC_ID_QTRLE;
    }
    private static final int AV_CODEC_ID_TSCC = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TSCC = 56
     * }
     */
    public static int AV_CODEC_ID_TSCC() {
        return AV_CODEC_ID_TSCC;
    }
    private static final int AV_CODEC_ID_ULTI = (int)57L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ULTI = 57
     * }
     */
    public static int AV_CODEC_ID_ULTI() {
        return AV_CODEC_ID_ULTI;
    }
    private static final int AV_CODEC_ID_QDRAW = (int)58L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_QDRAW = 58
     * }
     */
    public static int AV_CODEC_ID_QDRAW() {
        return AV_CODEC_ID_QDRAW;
    }
    private static final int AV_CODEC_ID_VIXL = (int)59L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VIXL = 59
     * }
     */
    public static int AV_CODEC_ID_VIXL() {
        return AV_CODEC_ID_VIXL;
    }
    private static final int AV_CODEC_ID_QPEG = (int)60L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_QPEG = 60
     * }
     */
    public static int AV_CODEC_ID_QPEG() {
        return AV_CODEC_ID_QPEG;
    }
    private static final int AV_CODEC_ID_PNG = (int)61L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PNG = 61
     * }
     */
    public static int AV_CODEC_ID_PNG() {
        return AV_CODEC_ID_PNG;
    }
    private static final int AV_CODEC_ID_PPM = (int)62L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PPM = 62
     * }
     */
    public static int AV_CODEC_ID_PPM() {
        return AV_CODEC_ID_PPM;
    }
    private static final int AV_CODEC_ID_PBM = (int)63L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PBM = 63
     * }
     */
    public static int AV_CODEC_ID_PBM() {
        return AV_CODEC_ID_PBM;
    }
    private static final int AV_CODEC_ID_PGM = (int)64L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PGM = 64
     * }
     */
    public static int AV_CODEC_ID_PGM() {
        return AV_CODEC_ID_PGM;
    }
    private static final int AV_CODEC_ID_PGMYUV = (int)65L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PGMYUV = 65
     * }
     */
    public static int AV_CODEC_ID_PGMYUV() {
        return AV_CODEC_ID_PGMYUV;
    }
    private static final int AV_CODEC_ID_PAM = (int)66L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PAM = 66
     * }
     */
    public static int AV_CODEC_ID_PAM() {
        return AV_CODEC_ID_PAM;
    }
    private static final int AV_CODEC_ID_FFVHUFF = (int)67L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FFVHUFF = 67
     * }
     */
    public static int AV_CODEC_ID_FFVHUFF() {
        return AV_CODEC_ID_FFVHUFF;
    }
    private static final int AV_CODEC_ID_RV30 = (int)68L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RV30 = 68
     * }
     */
    public static int AV_CODEC_ID_RV30() {
        return AV_CODEC_ID_RV30;
    }
    private static final int AV_CODEC_ID_RV40 = (int)69L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RV40 = 69
     * }
     */
    public static int AV_CODEC_ID_RV40() {
        return AV_CODEC_ID_RV40;
    }
    private static final int AV_CODEC_ID_VC1 = (int)70L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VC1 = 70
     * }
     */
    public static int AV_CODEC_ID_VC1() {
        return AV_CODEC_ID_VC1;
    }
    private static final int AV_CODEC_ID_WMV3 = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMV3 = 71
     * }
     */
    public static int AV_CODEC_ID_WMV3() {
        return AV_CODEC_ID_WMV3;
    }
    private static final int AV_CODEC_ID_LOCO = (int)72L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_LOCO = 72
     * }
     */
    public static int AV_CODEC_ID_LOCO() {
        return AV_CODEC_ID_LOCO;
    }
    private static final int AV_CODEC_ID_WNV1 = (int)73L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WNV1 = 73
     * }
     */
    public static int AV_CODEC_ID_WNV1() {
        return AV_CODEC_ID_WNV1;
    }
    private static final int AV_CODEC_ID_AASC = (int)74L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AASC = 74
     * }
     */
    public static int AV_CODEC_ID_AASC() {
        return AV_CODEC_ID_AASC;
    }
    private static final int AV_CODEC_ID_INDEO2 = (int)75L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_INDEO2 = 75
     * }
     */
    public static int AV_CODEC_ID_INDEO2() {
        return AV_CODEC_ID_INDEO2;
    }
    private static final int AV_CODEC_ID_FRAPS = (int)76L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FRAPS = 76
     * }
     */
    public static int AV_CODEC_ID_FRAPS() {
        return AV_CODEC_ID_FRAPS;
    }
    private static final int AV_CODEC_ID_TRUEMOTION2 = (int)77L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TRUEMOTION2 = 77
     * }
     */
    public static int AV_CODEC_ID_TRUEMOTION2() {
        return AV_CODEC_ID_TRUEMOTION2;
    }
    private static final int AV_CODEC_ID_BMP = (int)78L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BMP = 78
     * }
     */
    public static int AV_CODEC_ID_BMP() {
        return AV_CODEC_ID_BMP;
    }
    private static final int AV_CODEC_ID_CSCD = (int)79L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CSCD = 79
     * }
     */
    public static int AV_CODEC_ID_CSCD() {
        return AV_CODEC_ID_CSCD;
    }
    private static final int AV_CODEC_ID_MMVIDEO = (int)80L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MMVIDEO = 80
     * }
     */
    public static int AV_CODEC_ID_MMVIDEO() {
        return AV_CODEC_ID_MMVIDEO;
    }
    private static final int AV_CODEC_ID_ZMBV = (int)81L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ZMBV = 81
     * }
     */
    public static int AV_CODEC_ID_ZMBV() {
        return AV_CODEC_ID_ZMBV;
    }
    private static final int AV_CODEC_ID_AVS = (int)82L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AVS = 82
     * }
     */
    public static int AV_CODEC_ID_AVS() {
        return AV_CODEC_ID_AVS;
    }
    private static final int AV_CODEC_ID_SMACKVIDEO = (int)83L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SMACKVIDEO = 83
     * }
     */
    public static int AV_CODEC_ID_SMACKVIDEO() {
        return AV_CODEC_ID_SMACKVIDEO;
    }
    private static final int AV_CODEC_ID_NUV = (int)84L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_NUV = 84
     * }
     */
    public static int AV_CODEC_ID_NUV() {
        return AV_CODEC_ID_NUV;
    }
    private static final int AV_CODEC_ID_KMVC = (int)85L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_KMVC = 85
     * }
     */
    public static int AV_CODEC_ID_KMVC() {
        return AV_CODEC_ID_KMVC;
    }
    private static final int AV_CODEC_ID_FLASHSV = (int)86L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FLASHSV = 86
     * }
     */
    public static int AV_CODEC_ID_FLASHSV() {
        return AV_CODEC_ID_FLASHSV;
    }
    private static final int AV_CODEC_ID_CAVS = (int)87L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CAVS = 87
     * }
     */
    public static int AV_CODEC_ID_CAVS() {
        return AV_CODEC_ID_CAVS;
    }
    private static final int AV_CODEC_ID_JPEG2000 = (int)88L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_JPEG2000 = 88
     * }
     */
    public static int AV_CODEC_ID_JPEG2000() {
        return AV_CODEC_ID_JPEG2000;
    }
    private static final int AV_CODEC_ID_VMNC = (int)89L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VMNC = 89
     * }
     */
    public static int AV_CODEC_ID_VMNC() {
        return AV_CODEC_ID_VMNC;
    }
    private static final int AV_CODEC_ID_VP5 = (int)90L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP5 = 90
     * }
     */
    public static int AV_CODEC_ID_VP5() {
        return AV_CODEC_ID_VP5;
    }
    private static final int AV_CODEC_ID_VP6 = (int)91L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP6 = 91
     * }
     */
    public static int AV_CODEC_ID_VP6() {
        return AV_CODEC_ID_VP6;
    }
    private static final int AV_CODEC_ID_VP6F = (int)92L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP6F = 92
     * }
     */
    public static int AV_CODEC_ID_VP6F() {
        return AV_CODEC_ID_VP6F;
    }
    private static final int AV_CODEC_ID_TARGA = (int)93L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TARGA = 93
     * }
     */
    public static int AV_CODEC_ID_TARGA() {
        return AV_CODEC_ID_TARGA;
    }
    private static final int AV_CODEC_ID_DSICINVIDEO = (int)94L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DSICINVIDEO = 94
     * }
     */
    public static int AV_CODEC_ID_DSICINVIDEO() {
        return AV_CODEC_ID_DSICINVIDEO;
    }
    private static final int AV_CODEC_ID_TIERTEXSEQVIDEO = (int)95L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TIERTEXSEQVIDEO = 95
     * }
     */
    public static int AV_CODEC_ID_TIERTEXSEQVIDEO() {
        return AV_CODEC_ID_TIERTEXSEQVIDEO;
    }
    private static final int AV_CODEC_ID_TIFF = (int)96L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TIFF = 96
     * }
     */
    public static int AV_CODEC_ID_TIFF() {
        return AV_CODEC_ID_TIFF;
    }
    private static final int AV_CODEC_ID_GIF = (int)97L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_GIF = 97
     * }
     */
    public static int AV_CODEC_ID_GIF() {
        return AV_CODEC_ID_GIF;
    }
    private static final int AV_CODEC_ID_DXA = (int)98L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DXA = 98
     * }
     */
    public static int AV_CODEC_ID_DXA() {
        return AV_CODEC_ID_DXA;
    }
    private static final int AV_CODEC_ID_DNXHD = (int)99L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DNXHD = 99
     * }
     */
    public static int AV_CODEC_ID_DNXHD() {
        return AV_CODEC_ID_DNXHD;
    }
    private static final int AV_CODEC_ID_THP = (int)100L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_THP = 100
     * }
     */
    public static int AV_CODEC_ID_THP() {
        return AV_CODEC_ID_THP;
    }
    private static final int AV_CODEC_ID_SGI = (int)101L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SGI = 101
     * }
     */
    public static int AV_CODEC_ID_SGI() {
        return AV_CODEC_ID_SGI;
    }
    private static final int AV_CODEC_ID_C93 = (int)102L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_C93 = 102
     * }
     */
    public static int AV_CODEC_ID_C93() {
        return AV_CODEC_ID_C93;
    }
    private static final int AV_CODEC_ID_BETHSOFTVID = (int)103L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BETHSOFTVID = 103
     * }
     */
    public static int AV_CODEC_ID_BETHSOFTVID() {
        return AV_CODEC_ID_BETHSOFTVID;
    }
    private static final int AV_CODEC_ID_PTX = (int)104L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PTX = 104
     * }
     */
    public static int AV_CODEC_ID_PTX() {
        return AV_CODEC_ID_PTX;
    }
    private static final int AV_CODEC_ID_TXD = (int)105L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TXD = 105
     * }
     */
    public static int AV_CODEC_ID_TXD() {
        return AV_CODEC_ID_TXD;
    }
    private static final int AV_CODEC_ID_VP6A = (int)106L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP6A = 106
     * }
     */
    public static int AV_CODEC_ID_VP6A() {
        return AV_CODEC_ID_VP6A;
    }
    private static final int AV_CODEC_ID_AMV = (int)107L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AMV = 107
     * }
     */
    public static int AV_CODEC_ID_AMV() {
        return AV_CODEC_ID_AMV;
    }
    private static final int AV_CODEC_ID_VB = (int)108L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VB = 108
     * }
     */
    public static int AV_CODEC_ID_VB() {
        return AV_CODEC_ID_VB;
    }
    private static final int AV_CODEC_ID_PCX = (int)109L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCX = 109
     * }
     */
    public static int AV_CODEC_ID_PCX() {
        return AV_CODEC_ID_PCX;
    }
    private static final int AV_CODEC_ID_SUNRAST = (int)110L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SUNRAST = 110
     * }
     */
    public static int AV_CODEC_ID_SUNRAST() {
        return AV_CODEC_ID_SUNRAST;
    }
    private static final int AV_CODEC_ID_INDEO4 = (int)111L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_INDEO4 = 111
     * }
     */
    public static int AV_CODEC_ID_INDEO4() {
        return AV_CODEC_ID_INDEO4;
    }
    private static final int AV_CODEC_ID_INDEO5 = (int)112L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_INDEO5 = 112
     * }
     */
    public static int AV_CODEC_ID_INDEO5() {
        return AV_CODEC_ID_INDEO5;
    }
    private static final int AV_CODEC_ID_MIMIC = (int)113L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MIMIC = 113
     * }
     */
    public static int AV_CODEC_ID_MIMIC() {
        return AV_CODEC_ID_MIMIC;
    }
    private static final int AV_CODEC_ID_RL2 = (int)114L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RL2 = 114
     * }
     */
    public static int AV_CODEC_ID_RL2() {
        return AV_CODEC_ID_RL2;
    }
    private static final int AV_CODEC_ID_ESCAPE124 = (int)115L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ESCAPE124 = 115
     * }
     */
    public static int AV_CODEC_ID_ESCAPE124() {
        return AV_CODEC_ID_ESCAPE124;
    }
    private static final int AV_CODEC_ID_DIRAC = (int)116L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DIRAC = 116
     * }
     */
    public static int AV_CODEC_ID_DIRAC() {
        return AV_CODEC_ID_DIRAC;
    }
    private static final int AV_CODEC_ID_BFI = (int)117L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BFI = 117
     * }
     */
    public static int AV_CODEC_ID_BFI() {
        return AV_CODEC_ID_BFI;
    }
    private static final int AV_CODEC_ID_CMV = (int)118L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CMV = 118
     * }
     */
    public static int AV_CODEC_ID_CMV() {
        return AV_CODEC_ID_CMV;
    }
    private static final int AV_CODEC_ID_MOTIONPIXELS = (int)119L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MOTIONPIXELS = 119
     * }
     */
    public static int AV_CODEC_ID_MOTIONPIXELS() {
        return AV_CODEC_ID_MOTIONPIXELS;
    }
    private static final int AV_CODEC_ID_TGV = (int)120L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TGV = 120
     * }
     */
    public static int AV_CODEC_ID_TGV() {
        return AV_CODEC_ID_TGV;
    }
    private static final int AV_CODEC_ID_TGQ = (int)121L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TGQ = 121
     * }
     */
    public static int AV_CODEC_ID_TGQ() {
        return AV_CODEC_ID_TGQ;
    }
    private static final int AV_CODEC_ID_TQI = (int)122L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TQI = 122
     * }
     */
    public static int AV_CODEC_ID_TQI() {
        return AV_CODEC_ID_TQI;
    }
    private static final int AV_CODEC_ID_AURA = (int)123L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AURA = 123
     * }
     */
    public static int AV_CODEC_ID_AURA() {
        return AV_CODEC_ID_AURA;
    }
    private static final int AV_CODEC_ID_AURA2 = (int)124L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AURA2 = 124
     * }
     */
    public static int AV_CODEC_ID_AURA2() {
        return AV_CODEC_ID_AURA2;
    }
    private static final int AV_CODEC_ID_V210X = (int)125L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_V210X = 125
     * }
     */
    public static int AV_CODEC_ID_V210X() {
        return AV_CODEC_ID_V210X;
    }
    private static final int AV_CODEC_ID_TMV = (int)126L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TMV = 126
     * }
     */
    public static int AV_CODEC_ID_TMV() {
        return AV_CODEC_ID_TMV;
    }
    private static final int AV_CODEC_ID_V210 = (int)127L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_V210 = 127
     * }
     */
    public static int AV_CODEC_ID_V210() {
        return AV_CODEC_ID_V210;
    }
    private static final int AV_CODEC_ID_DPX = (int)128L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DPX = 128
     * }
     */
    public static int AV_CODEC_ID_DPX() {
        return AV_CODEC_ID_DPX;
    }
    private static final int AV_CODEC_ID_MAD = (int)129L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MAD = 129
     * }
     */
    public static int AV_CODEC_ID_MAD() {
        return AV_CODEC_ID_MAD;
    }
    private static final int AV_CODEC_ID_FRWU = (int)130L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FRWU = 130
     * }
     */
    public static int AV_CODEC_ID_FRWU() {
        return AV_CODEC_ID_FRWU;
    }
    private static final int AV_CODEC_ID_FLASHSV2 = (int)131L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FLASHSV2 = 131
     * }
     */
    public static int AV_CODEC_ID_FLASHSV2() {
        return AV_CODEC_ID_FLASHSV2;
    }
    private static final int AV_CODEC_ID_CDGRAPHICS = (int)132L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CDGRAPHICS = 132
     * }
     */
    public static int AV_CODEC_ID_CDGRAPHICS() {
        return AV_CODEC_ID_CDGRAPHICS;
    }
    private static final int AV_CODEC_ID_R210 = (int)133L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_R210 = 133
     * }
     */
    public static int AV_CODEC_ID_R210() {
        return AV_CODEC_ID_R210;
    }
    private static final int AV_CODEC_ID_ANM = (int)134L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ANM = 134
     * }
     */
    public static int AV_CODEC_ID_ANM() {
        return AV_CODEC_ID_ANM;
    }
    private static final int AV_CODEC_ID_BINKVIDEO = (int)135L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BINKVIDEO = 135
     * }
     */
    public static int AV_CODEC_ID_BINKVIDEO() {
        return AV_CODEC_ID_BINKVIDEO;
    }
    private static final int AV_CODEC_ID_IFF_ILBM = (int)136L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IFF_ILBM = 136
     * }
     */
    public static int AV_CODEC_ID_IFF_ILBM() {
        return AV_CODEC_ID_IFF_ILBM;
    }
    private static final int AV_CODEC_ID_KGV1 = (int)137L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_KGV1 = 137
     * }
     */
    public static int AV_CODEC_ID_KGV1() {
        return AV_CODEC_ID_KGV1;
    }
    private static final int AV_CODEC_ID_YOP = (int)138L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_YOP = 138
     * }
     */
    public static int AV_CODEC_ID_YOP() {
        return AV_CODEC_ID_YOP;
    }
    private static final int AV_CODEC_ID_VP8 = (int)139L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP8 = 139
     * }
     */
    public static int AV_CODEC_ID_VP8() {
        return AV_CODEC_ID_VP8;
    }
    private static final int AV_CODEC_ID_PICTOR = (int)140L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PICTOR = 140
     * }
     */
    public static int AV_CODEC_ID_PICTOR() {
        return AV_CODEC_ID_PICTOR;
    }
    private static final int AV_CODEC_ID_ANSI = (int)141L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ANSI = 141
     * }
     */
    public static int AV_CODEC_ID_ANSI() {
        return AV_CODEC_ID_ANSI;
    }
    private static final int AV_CODEC_ID_A64_MULTI = (int)142L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_A64_MULTI = 142
     * }
     */
    public static int AV_CODEC_ID_A64_MULTI() {
        return AV_CODEC_ID_A64_MULTI;
    }
    private static final int AV_CODEC_ID_A64_MULTI5 = (int)143L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_A64_MULTI5 = 143
     * }
     */
    public static int AV_CODEC_ID_A64_MULTI5() {
        return AV_CODEC_ID_A64_MULTI5;
    }
    private static final int AV_CODEC_ID_R10K = (int)144L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_R10K = 144
     * }
     */
    public static int AV_CODEC_ID_R10K() {
        return AV_CODEC_ID_R10K;
    }
    private static final int AV_CODEC_ID_MXPEG = (int)145L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MXPEG = 145
     * }
     */
    public static int AV_CODEC_ID_MXPEG() {
        return AV_CODEC_ID_MXPEG;
    }
    private static final int AV_CODEC_ID_LAGARITH = (int)146L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_LAGARITH = 146
     * }
     */
    public static int AV_CODEC_ID_LAGARITH() {
        return AV_CODEC_ID_LAGARITH;
    }
    private static final int AV_CODEC_ID_PRORES = (int)147L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PRORES = 147
     * }
     */
    public static int AV_CODEC_ID_PRORES() {
        return AV_CODEC_ID_PRORES;
    }
    private static final int AV_CODEC_ID_JV = (int)148L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_JV = 148
     * }
     */
    public static int AV_CODEC_ID_JV() {
        return AV_CODEC_ID_JV;
    }
    private static final int AV_CODEC_ID_DFA = (int)149L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DFA = 149
     * }
     */
    public static int AV_CODEC_ID_DFA() {
        return AV_CODEC_ID_DFA;
    }
    private static final int AV_CODEC_ID_WMV3IMAGE = (int)150L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMV3IMAGE = 150
     * }
     */
    public static int AV_CODEC_ID_WMV3IMAGE() {
        return AV_CODEC_ID_WMV3IMAGE;
    }
    private static final int AV_CODEC_ID_VC1IMAGE = (int)151L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VC1IMAGE = 151
     * }
     */
    public static int AV_CODEC_ID_VC1IMAGE() {
        return AV_CODEC_ID_VC1IMAGE;
    }
    private static final int AV_CODEC_ID_UTVIDEO = (int)152L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_UTVIDEO = 152
     * }
     */
    public static int AV_CODEC_ID_UTVIDEO() {
        return AV_CODEC_ID_UTVIDEO;
    }
    private static final int AV_CODEC_ID_BMV_VIDEO = (int)153L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BMV_VIDEO = 153
     * }
     */
    public static int AV_CODEC_ID_BMV_VIDEO() {
        return AV_CODEC_ID_BMV_VIDEO;
    }
    private static final int AV_CODEC_ID_VBLE = (int)154L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VBLE = 154
     * }
     */
    public static int AV_CODEC_ID_VBLE() {
        return AV_CODEC_ID_VBLE;
    }
    private static final int AV_CODEC_ID_DXTORY = (int)155L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DXTORY = 155
     * }
     */
    public static int AV_CODEC_ID_DXTORY() {
        return AV_CODEC_ID_DXTORY;
    }
    private static final int AV_CODEC_ID_V410 = (int)156L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_V410 = 156
     * }
     */
    public static int AV_CODEC_ID_V410() {
        return AV_CODEC_ID_V410;
    }
    private static final int AV_CODEC_ID_XWD = (int)157L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XWD = 157
     * }
     */
    public static int AV_CODEC_ID_XWD() {
        return AV_CODEC_ID_XWD;
    }
    private static final int AV_CODEC_ID_CDXL = (int)158L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CDXL = 158
     * }
     */
    public static int AV_CODEC_ID_CDXL() {
        return AV_CODEC_ID_CDXL;
    }
    private static final int AV_CODEC_ID_XBM = (int)159L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XBM = 159
     * }
     */
    public static int AV_CODEC_ID_XBM() {
        return AV_CODEC_ID_XBM;
    }
    private static final int AV_CODEC_ID_ZEROCODEC = (int)160L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ZEROCODEC = 160
     * }
     */
    public static int AV_CODEC_ID_ZEROCODEC() {
        return AV_CODEC_ID_ZEROCODEC;
    }
    private static final int AV_CODEC_ID_MSS1 = (int)161L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSS1 = 161
     * }
     */
    public static int AV_CODEC_ID_MSS1() {
        return AV_CODEC_ID_MSS1;
    }
    private static final int AV_CODEC_ID_MSA1 = (int)162L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSA1 = 162
     * }
     */
    public static int AV_CODEC_ID_MSA1() {
        return AV_CODEC_ID_MSA1;
    }
    private static final int AV_CODEC_ID_TSCC2 = (int)163L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TSCC2 = 163
     * }
     */
    public static int AV_CODEC_ID_TSCC2() {
        return AV_CODEC_ID_TSCC2;
    }
    private static final int AV_CODEC_ID_MTS2 = (int)164L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MTS2 = 164
     * }
     */
    public static int AV_CODEC_ID_MTS2() {
        return AV_CODEC_ID_MTS2;
    }
    private static final int AV_CODEC_ID_CLLC = (int)165L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CLLC = 165
     * }
     */
    public static int AV_CODEC_ID_CLLC() {
        return AV_CODEC_ID_CLLC;
    }
    private static final int AV_CODEC_ID_MSS2 = (int)166L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSS2 = 166
     * }
     */
    public static int AV_CODEC_ID_MSS2() {
        return AV_CODEC_ID_MSS2;
    }
    private static final int AV_CODEC_ID_VP9 = (int)167L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP9 = 167
     * }
     */
    public static int AV_CODEC_ID_VP9() {
        return AV_CODEC_ID_VP9;
    }
    private static final int AV_CODEC_ID_AIC = (int)168L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AIC = 168
     * }
     */
    public static int AV_CODEC_ID_AIC() {
        return AV_CODEC_ID_AIC;
    }
    private static final int AV_CODEC_ID_ESCAPE130 = (int)169L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ESCAPE130 = 169
     * }
     */
    public static int AV_CODEC_ID_ESCAPE130() {
        return AV_CODEC_ID_ESCAPE130;
    }
    private static final int AV_CODEC_ID_G2M = (int)170L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_G2M = 170
     * }
     */
    public static int AV_CODEC_ID_G2M() {
        return AV_CODEC_ID_G2M;
    }
    private static final int AV_CODEC_ID_WEBP = (int)171L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WEBP = 171
     * }
     */
    public static int AV_CODEC_ID_WEBP() {
        return AV_CODEC_ID_WEBP;
    }
    private static final int AV_CODEC_ID_HNM4_VIDEO = (int)172L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HNM4_VIDEO = 172
     * }
     */
    public static int AV_CODEC_ID_HNM4_VIDEO() {
        return AV_CODEC_ID_HNM4_VIDEO;
    }
    private static final int AV_CODEC_ID_HEVC = (int)173L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HEVC = 173
     * }
     */
    public static int AV_CODEC_ID_HEVC() {
        return AV_CODEC_ID_HEVC;
    }
    private static final int AV_CODEC_ID_FIC = (int)174L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FIC = 174
     * }
     */
    public static int AV_CODEC_ID_FIC() {
        return AV_CODEC_ID_FIC;
    }
    private static final int AV_CODEC_ID_ALIAS_PIX = (int)175L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ALIAS_PIX = 175
     * }
     */
    public static int AV_CODEC_ID_ALIAS_PIX() {
        return AV_CODEC_ID_ALIAS_PIX;
    }
    private static final int AV_CODEC_ID_BRENDER_PIX = (int)176L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BRENDER_PIX = 176
     * }
     */
    public static int AV_CODEC_ID_BRENDER_PIX() {
        return AV_CODEC_ID_BRENDER_PIX;
    }
    private static final int AV_CODEC_ID_PAF_VIDEO = (int)177L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PAF_VIDEO = 177
     * }
     */
    public static int AV_CODEC_ID_PAF_VIDEO() {
        return AV_CODEC_ID_PAF_VIDEO;
    }
    private static final int AV_CODEC_ID_EXR = (int)178L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_EXR = 178
     * }
     */
    public static int AV_CODEC_ID_EXR() {
        return AV_CODEC_ID_EXR;
    }
    private static final int AV_CODEC_ID_VP7 = (int)179L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP7 = 179
     * }
     */
    public static int AV_CODEC_ID_VP7() {
        return AV_CODEC_ID_VP7;
    }
    private static final int AV_CODEC_ID_SANM = (int)180L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SANM = 180
     * }
     */
    public static int AV_CODEC_ID_SANM() {
        return AV_CODEC_ID_SANM;
    }
    private static final int AV_CODEC_ID_SGIRLE = (int)181L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SGIRLE = 181
     * }
     */
    public static int AV_CODEC_ID_SGIRLE() {
        return AV_CODEC_ID_SGIRLE;
    }
    private static final int AV_CODEC_ID_MVC1 = (int)182L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MVC1 = 182
     * }
     */
    public static int AV_CODEC_ID_MVC1() {
        return AV_CODEC_ID_MVC1;
    }
    private static final int AV_CODEC_ID_MVC2 = (int)183L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MVC2 = 183
     * }
     */
    public static int AV_CODEC_ID_MVC2() {
        return AV_CODEC_ID_MVC2;
    }
    private static final int AV_CODEC_ID_HQX = (int)184L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HQX = 184
     * }
     */
    public static int AV_CODEC_ID_HQX() {
        return AV_CODEC_ID_HQX;
    }
    private static final int AV_CODEC_ID_TDSC = (int)185L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TDSC = 185
     * }
     */
    public static int AV_CODEC_ID_TDSC() {
        return AV_CODEC_ID_TDSC;
    }
    private static final int AV_CODEC_ID_HQ_HQA = (int)186L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HQ_HQA = 186
     * }
     */
    public static int AV_CODEC_ID_HQ_HQA() {
        return AV_CODEC_ID_HQ_HQA;
    }
    private static final int AV_CODEC_ID_HAP = (int)187L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HAP = 187
     * }
     */
    public static int AV_CODEC_ID_HAP() {
        return AV_CODEC_ID_HAP;
    }
    private static final int AV_CODEC_ID_DDS = (int)188L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DDS = 188
     * }
     */
    public static int AV_CODEC_ID_DDS() {
        return AV_CODEC_ID_DDS;
    }
    private static final int AV_CODEC_ID_DXV = (int)189L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DXV = 189
     * }
     */
    public static int AV_CODEC_ID_DXV() {
        return AV_CODEC_ID_DXV;
    }
    private static final int AV_CODEC_ID_SCREENPRESSO = (int)190L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SCREENPRESSO = 190
     * }
     */
    public static int AV_CODEC_ID_SCREENPRESSO() {
        return AV_CODEC_ID_SCREENPRESSO;
    }
    private static final int AV_CODEC_ID_RSCC = (int)191L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RSCC = 191
     * }
     */
    public static int AV_CODEC_ID_RSCC() {
        return AV_CODEC_ID_RSCC;
    }
    private static final int AV_CODEC_ID_AVS2 = (int)192L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AVS2 = 192
     * }
     */
    public static int AV_CODEC_ID_AVS2() {
        return AV_CODEC_ID_AVS2;
    }
    private static final int AV_CODEC_ID_PGX = (int)193L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PGX = 193
     * }
     */
    public static int AV_CODEC_ID_PGX() {
        return AV_CODEC_ID_PGX;
    }
    private static final int AV_CODEC_ID_AVS3 = (int)194L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AVS3 = 194
     * }
     */
    public static int AV_CODEC_ID_AVS3() {
        return AV_CODEC_ID_AVS3;
    }
    private static final int AV_CODEC_ID_MSP2 = (int)195L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSP2 = 195
     * }
     */
    public static int AV_CODEC_ID_MSP2() {
        return AV_CODEC_ID_MSP2;
    }
    private static final int AV_CODEC_ID_VVC = (int)196L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VVC = 196
     * }
     */
    public static int AV_CODEC_ID_VVC() {
        return AV_CODEC_ID_VVC;
    }
    private static final int AV_CODEC_ID_Y41P = (int)197L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_Y41P = 197
     * }
     */
    public static int AV_CODEC_ID_Y41P() {
        return AV_CODEC_ID_Y41P;
    }
    private static final int AV_CODEC_ID_AVRP = (int)198L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AVRP = 198
     * }
     */
    public static int AV_CODEC_ID_AVRP() {
        return AV_CODEC_ID_AVRP;
    }
    private static final int AV_CODEC_ID_012V = (int)199L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_012V = 199
     * }
     */
    public static int AV_CODEC_ID_012V() {
        return AV_CODEC_ID_012V;
    }
    private static final int AV_CODEC_ID_AVUI = (int)200L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AVUI = 200
     * }
     */
    public static int AV_CODEC_ID_AVUI() {
        return AV_CODEC_ID_AVUI;
    }
    private static final int AV_CODEC_ID_AYUV = (int)201L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AYUV = 201
     * }
     */
    public static int AV_CODEC_ID_AYUV() {
        return AV_CODEC_ID_AYUV;
    }
    private static final int AV_CODEC_ID_TARGA_Y216 = (int)202L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TARGA_Y216 = 202
     * }
     */
    public static int AV_CODEC_ID_TARGA_Y216() {
        return AV_CODEC_ID_TARGA_Y216;
    }
    private static final int AV_CODEC_ID_V308 = (int)203L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_V308 = 203
     * }
     */
    public static int AV_CODEC_ID_V308() {
        return AV_CODEC_ID_V308;
    }
    private static final int AV_CODEC_ID_V408 = (int)204L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_V408 = 204
     * }
     */
    public static int AV_CODEC_ID_V408() {
        return AV_CODEC_ID_V408;
    }
    private static final int AV_CODEC_ID_YUV4 = (int)205L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_YUV4 = 205
     * }
     */
    public static int AV_CODEC_ID_YUV4() {
        return AV_CODEC_ID_YUV4;
    }
    private static final int AV_CODEC_ID_AVRN = (int)206L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AVRN = 206
     * }
     */
    public static int AV_CODEC_ID_AVRN() {
        return AV_CODEC_ID_AVRN;
    }
    private static final int AV_CODEC_ID_CPIA = (int)207L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CPIA = 207
     * }
     */
    public static int AV_CODEC_ID_CPIA() {
        return AV_CODEC_ID_CPIA;
    }
    private static final int AV_CODEC_ID_XFACE = (int)208L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XFACE = 208
     * }
     */
    public static int AV_CODEC_ID_XFACE() {
        return AV_CODEC_ID_XFACE;
    }
    private static final int AV_CODEC_ID_SNOW = (int)209L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SNOW = 209
     * }
     */
    public static int AV_CODEC_ID_SNOW() {
        return AV_CODEC_ID_SNOW;
    }
    private static final int AV_CODEC_ID_SMVJPEG = (int)210L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SMVJPEG = 210
     * }
     */
    public static int AV_CODEC_ID_SMVJPEG() {
        return AV_CODEC_ID_SMVJPEG;
    }
    private static final int AV_CODEC_ID_APNG = (int)211L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_APNG = 211
     * }
     */
    public static int AV_CODEC_ID_APNG() {
        return AV_CODEC_ID_APNG;
    }
    private static final int AV_CODEC_ID_DAALA = (int)212L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DAALA = 212
     * }
     */
    public static int AV_CODEC_ID_DAALA() {
        return AV_CODEC_ID_DAALA;
    }
    private static final int AV_CODEC_ID_CFHD = (int)213L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CFHD = 213
     * }
     */
    public static int AV_CODEC_ID_CFHD() {
        return AV_CODEC_ID_CFHD;
    }
    private static final int AV_CODEC_ID_TRUEMOTION2RT = (int)214L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TRUEMOTION2RT = 214
     * }
     */
    public static int AV_CODEC_ID_TRUEMOTION2RT() {
        return AV_CODEC_ID_TRUEMOTION2RT;
    }
    private static final int AV_CODEC_ID_M101 = (int)215L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_M101 = 215
     * }
     */
    public static int AV_CODEC_ID_M101() {
        return AV_CODEC_ID_M101;
    }
    private static final int AV_CODEC_ID_MAGICYUV = (int)216L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MAGICYUV = 216
     * }
     */
    public static int AV_CODEC_ID_MAGICYUV() {
        return AV_CODEC_ID_MAGICYUV;
    }
    private static final int AV_CODEC_ID_SHEERVIDEO = (int)217L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SHEERVIDEO = 217
     * }
     */
    public static int AV_CODEC_ID_SHEERVIDEO() {
        return AV_CODEC_ID_SHEERVIDEO;
    }
    private static final int AV_CODEC_ID_YLC = (int)218L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_YLC = 218
     * }
     */
    public static int AV_CODEC_ID_YLC() {
        return AV_CODEC_ID_YLC;
    }
    private static final int AV_CODEC_ID_PSD = (int)219L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PSD = 219
     * }
     */
    public static int AV_CODEC_ID_PSD() {
        return AV_CODEC_ID_PSD;
    }
    private static final int AV_CODEC_ID_PIXLET = (int)220L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PIXLET = 220
     * }
     */
    public static int AV_CODEC_ID_PIXLET() {
        return AV_CODEC_ID_PIXLET;
    }
    private static final int AV_CODEC_ID_SPEEDHQ = (int)221L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SPEEDHQ = 221
     * }
     */
    public static int AV_CODEC_ID_SPEEDHQ() {
        return AV_CODEC_ID_SPEEDHQ;
    }
    private static final int AV_CODEC_ID_FMVC = (int)222L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FMVC = 222
     * }
     */
    public static int AV_CODEC_ID_FMVC() {
        return AV_CODEC_ID_FMVC;
    }
    private static final int AV_CODEC_ID_SCPR = (int)223L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SCPR = 223
     * }
     */
    public static int AV_CODEC_ID_SCPR() {
        return AV_CODEC_ID_SCPR;
    }
    private static final int AV_CODEC_ID_CLEARVIDEO = (int)224L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CLEARVIDEO = 224
     * }
     */
    public static int AV_CODEC_ID_CLEARVIDEO() {
        return AV_CODEC_ID_CLEARVIDEO;
    }
    private static final int AV_CODEC_ID_XPM = (int)225L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XPM = 225
     * }
     */
    public static int AV_CODEC_ID_XPM() {
        return AV_CODEC_ID_XPM;
    }
    private static final int AV_CODEC_ID_AV1 = (int)226L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AV1 = 226
     * }
     */
    public static int AV_CODEC_ID_AV1() {
        return AV_CODEC_ID_AV1;
    }
    private static final int AV_CODEC_ID_BITPACKED = (int)227L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BITPACKED = 227
     * }
     */
    public static int AV_CODEC_ID_BITPACKED() {
        return AV_CODEC_ID_BITPACKED;
    }
    private static final int AV_CODEC_ID_MSCC = (int)228L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSCC = 228
     * }
     */
    public static int AV_CODEC_ID_MSCC() {
        return AV_CODEC_ID_MSCC;
    }
    private static final int AV_CODEC_ID_SRGC = (int)229L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SRGC = 229
     * }
     */
    public static int AV_CODEC_ID_SRGC() {
        return AV_CODEC_ID_SRGC;
    }
    private static final int AV_CODEC_ID_SVG = (int)230L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SVG = 230
     * }
     */
    public static int AV_CODEC_ID_SVG() {
        return AV_CODEC_ID_SVG;
    }
    private static final int AV_CODEC_ID_GDV = (int)231L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_GDV = 231
     * }
     */
    public static int AV_CODEC_ID_GDV() {
        return AV_CODEC_ID_GDV;
    }
    private static final int AV_CODEC_ID_FITS = (int)232L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FITS = 232
     * }
     */
    public static int AV_CODEC_ID_FITS() {
        return AV_CODEC_ID_FITS;
    }
    private static final int AV_CODEC_ID_IMM4 = (int)233L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IMM4 = 233
     * }
     */
    public static int AV_CODEC_ID_IMM4() {
        return AV_CODEC_ID_IMM4;
    }
    private static final int AV_CODEC_ID_PROSUMER = (int)234L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PROSUMER = 234
     * }
     */
    public static int AV_CODEC_ID_PROSUMER() {
        return AV_CODEC_ID_PROSUMER;
    }
    private static final int AV_CODEC_ID_MWSC = (int)235L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MWSC = 235
     * }
     */
    public static int AV_CODEC_ID_MWSC() {
        return AV_CODEC_ID_MWSC;
    }
    private static final int AV_CODEC_ID_WCMV = (int)236L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WCMV = 236
     * }
     */
    public static int AV_CODEC_ID_WCMV() {
        return AV_CODEC_ID_WCMV;
    }
    private static final int AV_CODEC_ID_RASC = (int)237L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RASC = 237
     * }
     */
    public static int AV_CODEC_ID_RASC() {
        return AV_CODEC_ID_RASC;
    }
    private static final int AV_CODEC_ID_HYMT = (int)238L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HYMT = 238
     * }
     */
    public static int AV_CODEC_ID_HYMT() {
        return AV_CODEC_ID_HYMT;
    }
    private static final int AV_CODEC_ID_ARBC = (int)239L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ARBC = 239
     * }
     */
    public static int AV_CODEC_ID_ARBC() {
        return AV_CODEC_ID_ARBC;
    }
    private static final int AV_CODEC_ID_AGM = (int)240L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AGM = 240
     * }
     */
    public static int AV_CODEC_ID_AGM() {
        return AV_CODEC_ID_AGM;
    }
    private static final int AV_CODEC_ID_LSCR = (int)241L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_LSCR = 241
     * }
     */
    public static int AV_CODEC_ID_LSCR() {
        return AV_CODEC_ID_LSCR;
    }
    private static final int AV_CODEC_ID_VP4 = (int)242L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VP4 = 242
     * }
     */
    public static int AV_CODEC_ID_VP4() {
        return AV_CODEC_ID_VP4;
    }
    private static final int AV_CODEC_ID_IMM5 = (int)243L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IMM5 = 243
     * }
     */
    public static int AV_CODEC_ID_IMM5() {
        return AV_CODEC_ID_IMM5;
    }
    private static final int AV_CODEC_ID_MVDV = (int)244L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MVDV = 244
     * }
     */
    public static int AV_CODEC_ID_MVDV() {
        return AV_CODEC_ID_MVDV;
    }
    private static final int AV_CODEC_ID_MVHA = (int)245L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MVHA = 245
     * }
     */
    public static int AV_CODEC_ID_MVHA() {
        return AV_CODEC_ID_MVHA;
    }
    private static final int AV_CODEC_ID_CDTOONS = (int)246L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CDTOONS = 246
     * }
     */
    public static int AV_CODEC_ID_CDTOONS() {
        return AV_CODEC_ID_CDTOONS;
    }
    private static final int AV_CODEC_ID_MV30 = (int)247L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MV30 = 247
     * }
     */
    public static int AV_CODEC_ID_MV30() {
        return AV_CODEC_ID_MV30;
    }
    private static final int AV_CODEC_ID_NOTCHLC = (int)248L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_NOTCHLC = 248
     * }
     */
    public static int AV_CODEC_ID_NOTCHLC() {
        return AV_CODEC_ID_NOTCHLC;
    }
    private static final int AV_CODEC_ID_PFM = (int)249L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PFM = 249
     * }
     */
    public static int AV_CODEC_ID_PFM() {
        return AV_CODEC_ID_PFM;
    }
    private static final int AV_CODEC_ID_MOBICLIP = (int)250L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MOBICLIP = 250
     * }
     */
    public static int AV_CODEC_ID_MOBICLIP() {
        return AV_CODEC_ID_MOBICLIP;
    }
    private static final int AV_CODEC_ID_PHOTOCD = (int)251L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PHOTOCD = 251
     * }
     */
    public static int AV_CODEC_ID_PHOTOCD() {
        return AV_CODEC_ID_PHOTOCD;
    }
    private static final int AV_CODEC_ID_IPU = (int)252L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IPU = 252
     * }
     */
    public static int AV_CODEC_ID_IPU() {
        return AV_CODEC_ID_IPU;
    }
    private static final int AV_CODEC_ID_ARGO = (int)253L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ARGO = 253
     * }
     */
    public static int AV_CODEC_ID_ARGO() {
        return AV_CODEC_ID_ARGO;
    }
    private static final int AV_CODEC_ID_CRI = (int)254L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CRI = 254
     * }
     */
    public static int AV_CODEC_ID_CRI() {
        return AV_CODEC_ID_CRI;
    }
    private static final int AV_CODEC_ID_SIMBIOSIS_IMX = (int)255L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SIMBIOSIS_IMX = 255
     * }
     */
    public static int AV_CODEC_ID_SIMBIOSIS_IMX() {
        return AV_CODEC_ID_SIMBIOSIS_IMX;
    }
    private static final int AV_CODEC_ID_SGA_VIDEO = (int)256L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SGA_VIDEO = 256
     * }
     */
    public static int AV_CODEC_ID_SGA_VIDEO() {
        return AV_CODEC_ID_SGA_VIDEO;
    }
    private static final int AV_CODEC_ID_GEM = (int)257L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_GEM = 257
     * }
     */
    public static int AV_CODEC_ID_GEM() {
        return AV_CODEC_ID_GEM;
    }
    private static final int AV_CODEC_ID_VBN = (int)258L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VBN = 258
     * }
     */
    public static int AV_CODEC_ID_VBN() {
        return AV_CODEC_ID_VBN;
    }
    private static final int AV_CODEC_ID_JPEGXL = (int)259L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_JPEGXL = 259
     * }
     */
    public static int AV_CODEC_ID_JPEGXL() {
        return AV_CODEC_ID_JPEGXL;
    }
    private static final int AV_CODEC_ID_QOI = (int)260L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_QOI = 260
     * }
     */
    public static int AV_CODEC_ID_QOI() {
        return AV_CODEC_ID_QOI;
    }
    private static final int AV_CODEC_ID_PHM = (int)261L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PHM = 261
     * }
     */
    public static int AV_CODEC_ID_PHM() {
        return AV_CODEC_ID_PHM;
    }
    private static final int AV_CODEC_ID_FIRST_AUDIO = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FIRST_AUDIO = 65536
     * }
     */
    public static int AV_CODEC_ID_FIRST_AUDIO() {
        return AV_CODEC_ID_FIRST_AUDIO;
    }
    private static final int AV_CODEC_ID_PCM_S16LE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S16LE = 65536
     * }
     */
    public static int AV_CODEC_ID_PCM_S16LE() {
        return AV_CODEC_ID_PCM_S16LE;
    }
    private static final int AV_CODEC_ID_PCM_S16BE = (int)65537L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S16BE = 65537
     * }
     */
    public static int AV_CODEC_ID_PCM_S16BE() {
        return AV_CODEC_ID_PCM_S16BE;
    }
    private static final int AV_CODEC_ID_PCM_U16LE = (int)65538L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_U16LE = 65538
     * }
     */
    public static int AV_CODEC_ID_PCM_U16LE() {
        return AV_CODEC_ID_PCM_U16LE;
    }
    private static final int AV_CODEC_ID_PCM_U16BE = (int)65539L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_U16BE = 65539
     * }
     */
    public static int AV_CODEC_ID_PCM_U16BE() {
        return AV_CODEC_ID_PCM_U16BE;
    }
    private static final int AV_CODEC_ID_PCM_S8 = (int)65540L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S8 = 65540
     * }
     */
    public static int AV_CODEC_ID_PCM_S8() {
        return AV_CODEC_ID_PCM_S8;
    }
    private static final int AV_CODEC_ID_PCM_U8 = (int)65541L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_U8 = 65541
     * }
     */
    public static int AV_CODEC_ID_PCM_U8() {
        return AV_CODEC_ID_PCM_U8;
    }
    private static final int AV_CODEC_ID_PCM_MULAW = (int)65542L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_MULAW = 65542
     * }
     */
    public static int AV_CODEC_ID_PCM_MULAW() {
        return AV_CODEC_ID_PCM_MULAW;
    }
    private static final int AV_CODEC_ID_PCM_ALAW = (int)65543L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_ALAW = 65543
     * }
     */
    public static int AV_CODEC_ID_PCM_ALAW() {
        return AV_CODEC_ID_PCM_ALAW;
    }
    private static final int AV_CODEC_ID_PCM_S32LE = (int)65544L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S32LE = 65544
     * }
     */
    public static int AV_CODEC_ID_PCM_S32LE() {
        return AV_CODEC_ID_PCM_S32LE;
    }
    private static final int AV_CODEC_ID_PCM_S32BE = (int)65545L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S32BE = 65545
     * }
     */
    public static int AV_CODEC_ID_PCM_S32BE() {
        return AV_CODEC_ID_PCM_S32BE;
    }
    private static final int AV_CODEC_ID_PCM_U32LE = (int)65546L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_U32LE = 65546
     * }
     */
    public static int AV_CODEC_ID_PCM_U32LE() {
        return AV_CODEC_ID_PCM_U32LE;
    }
    private static final int AV_CODEC_ID_PCM_U32BE = (int)65547L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_U32BE = 65547
     * }
     */
    public static int AV_CODEC_ID_PCM_U32BE() {
        return AV_CODEC_ID_PCM_U32BE;
    }
    private static final int AV_CODEC_ID_PCM_S24LE = (int)65548L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S24LE = 65548
     * }
     */
    public static int AV_CODEC_ID_PCM_S24LE() {
        return AV_CODEC_ID_PCM_S24LE;
    }
    private static final int AV_CODEC_ID_PCM_S24BE = (int)65549L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S24BE = 65549
     * }
     */
    public static int AV_CODEC_ID_PCM_S24BE() {
        return AV_CODEC_ID_PCM_S24BE;
    }
    private static final int AV_CODEC_ID_PCM_U24LE = (int)65550L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_U24LE = 65550
     * }
     */
    public static int AV_CODEC_ID_PCM_U24LE() {
        return AV_CODEC_ID_PCM_U24LE;
    }
    private static final int AV_CODEC_ID_PCM_U24BE = (int)65551L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_U24BE = 65551
     * }
     */
    public static int AV_CODEC_ID_PCM_U24BE() {
        return AV_CODEC_ID_PCM_U24BE;
    }
    private static final int AV_CODEC_ID_PCM_S24DAUD = (int)65552L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S24DAUD = 65552
     * }
     */
    public static int AV_CODEC_ID_PCM_S24DAUD() {
        return AV_CODEC_ID_PCM_S24DAUD;
    }
    private static final int AV_CODEC_ID_PCM_ZORK = (int)65553L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_ZORK = 65553
     * }
     */
    public static int AV_CODEC_ID_PCM_ZORK() {
        return AV_CODEC_ID_PCM_ZORK;
    }
    private static final int AV_CODEC_ID_PCM_S16LE_PLANAR = (int)65554L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S16LE_PLANAR = 65554
     * }
     */
    public static int AV_CODEC_ID_PCM_S16LE_PLANAR() {
        return AV_CODEC_ID_PCM_S16LE_PLANAR;
    }
    private static final int AV_CODEC_ID_PCM_DVD = (int)65555L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_DVD = 65555
     * }
     */
    public static int AV_CODEC_ID_PCM_DVD() {
        return AV_CODEC_ID_PCM_DVD;
    }
    private static final int AV_CODEC_ID_PCM_F32BE = (int)65556L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_F32BE = 65556
     * }
     */
    public static int AV_CODEC_ID_PCM_F32BE() {
        return AV_CODEC_ID_PCM_F32BE;
    }
    private static final int AV_CODEC_ID_PCM_F32LE = (int)65557L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_F32LE = 65557
     * }
     */
    public static int AV_CODEC_ID_PCM_F32LE() {
        return AV_CODEC_ID_PCM_F32LE;
    }
    private static final int AV_CODEC_ID_PCM_F64BE = (int)65558L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_F64BE = 65558
     * }
     */
    public static int AV_CODEC_ID_PCM_F64BE() {
        return AV_CODEC_ID_PCM_F64BE;
    }
    private static final int AV_CODEC_ID_PCM_F64LE = (int)65559L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_F64LE = 65559
     * }
     */
    public static int AV_CODEC_ID_PCM_F64LE() {
        return AV_CODEC_ID_PCM_F64LE;
    }
    private static final int AV_CODEC_ID_PCM_BLURAY = (int)65560L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_BLURAY = 65560
     * }
     */
    public static int AV_CODEC_ID_PCM_BLURAY() {
        return AV_CODEC_ID_PCM_BLURAY;
    }
    private static final int AV_CODEC_ID_PCM_LXF = (int)65561L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_LXF = 65561
     * }
     */
    public static int AV_CODEC_ID_PCM_LXF() {
        return AV_CODEC_ID_PCM_LXF;
    }
    private static final int AV_CODEC_ID_S302M = (int)65562L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_S302M = 65562
     * }
     */
    public static int AV_CODEC_ID_S302M() {
        return AV_CODEC_ID_S302M;
    }
    private static final int AV_CODEC_ID_PCM_S8_PLANAR = (int)65563L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S8_PLANAR = 65563
     * }
     */
    public static int AV_CODEC_ID_PCM_S8_PLANAR() {
        return AV_CODEC_ID_PCM_S8_PLANAR;
    }
    private static final int AV_CODEC_ID_PCM_S24LE_PLANAR = (int)65564L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S24LE_PLANAR = 65564
     * }
     */
    public static int AV_CODEC_ID_PCM_S24LE_PLANAR() {
        return AV_CODEC_ID_PCM_S24LE_PLANAR;
    }
    private static final int AV_CODEC_ID_PCM_S32LE_PLANAR = (int)65565L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S32LE_PLANAR = 65565
     * }
     */
    public static int AV_CODEC_ID_PCM_S32LE_PLANAR() {
        return AV_CODEC_ID_PCM_S32LE_PLANAR;
    }
    private static final int AV_CODEC_ID_PCM_S16BE_PLANAR = (int)65566L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S16BE_PLANAR = 65566
     * }
     */
    public static int AV_CODEC_ID_PCM_S16BE_PLANAR() {
        return AV_CODEC_ID_PCM_S16BE_PLANAR;
    }
    private static final int AV_CODEC_ID_PCM_S64LE = (int)65567L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S64LE = 65567
     * }
     */
    public static int AV_CODEC_ID_PCM_S64LE() {
        return AV_CODEC_ID_PCM_S64LE;
    }
    private static final int AV_CODEC_ID_PCM_S64BE = (int)65568L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_S64BE = 65568
     * }
     */
    public static int AV_CODEC_ID_PCM_S64BE() {
        return AV_CODEC_ID_PCM_S64BE;
    }
    private static final int AV_CODEC_ID_PCM_F16LE = (int)65569L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_F16LE = 65569
     * }
     */
    public static int AV_CODEC_ID_PCM_F16LE() {
        return AV_CODEC_ID_PCM_F16LE;
    }
    private static final int AV_CODEC_ID_PCM_F24LE = (int)65570L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_F24LE = 65570
     * }
     */
    public static int AV_CODEC_ID_PCM_F24LE() {
        return AV_CODEC_ID_PCM_F24LE;
    }
    private static final int AV_CODEC_ID_PCM_VIDC = (int)65571L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_VIDC = 65571
     * }
     */
    public static int AV_CODEC_ID_PCM_VIDC() {
        return AV_CODEC_ID_PCM_VIDC;
    }
    private static final int AV_CODEC_ID_PCM_SGA = (int)65572L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PCM_SGA = 65572
     * }
     */
    public static int AV_CODEC_ID_PCM_SGA() {
        return AV_CODEC_ID_PCM_SGA;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_QT = (int)69632L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_QT = 69632
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_QT() {
        return AV_CODEC_ID_ADPCM_IMA_QT;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_WAV = (int)69633L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_WAV = 69633
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_WAV() {
        return AV_CODEC_ID_ADPCM_IMA_WAV;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_DK3 = (int)69634L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_DK3 = 69634
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_DK3() {
        return AV_CODEC_ID_ADPCM_IMA_DK3;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_DK4 = (int)69635L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_DK4 = 69635
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_DK4() {
        return AV_CODEC_ID_ADPCM_IMA_DK4;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_WS = (int)69636L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_WS = 69636
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_WS() {
        return AV_CODEC_ID_ADPCM_IMA_WS;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_SMJPEG = (int)69637L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_SMJPEG() {
        return AV_CODEC_ID_ADPCM_IMA_SMJPEG;
    }
    private static final int AV_CODEC_ID_ADPCM_MS = (int)69638L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_MS = 69638
     * }
     */
    public static int AV_CODEC_ID_ADPCM_MS() {
        return AV_CODEC_ID_ADPCM_MS;
    }
    private static final int AV_CODEC_ID_ADPCM_4XM = (int)69639L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_4XM = 69639
     * }
     */
    public static int AV_CODEC_ID_ADPCM_4XM() {
        return AV_CODEC_ID_ADPCM_4XM;
    }
    private static final int AV_CODEC_ID_ADPCM_XA = (int)69640L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_XA = 69640
     * }
     */
    public static int AV_CODEC_ID_ADPCM_XA() {
        return AV_CODEC_ID_ADPCM_XA;
    }
    private static final int AV_CODEC_ID_ADPCM_ADX = (int)69641L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_ADX = 69641
     * }
     */
    public static int AV_CODEC_ID_ADPCM_ADX() {
        return AV_CODEC_ID_ADPCM_ADX;
    }
    private static final int AV_CODEC_ID_ADPCM_EA = (int)69642L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_EA = 69642
     * }
     */
    public static int AV_CODEC_ID_ADPCM_EA() {
        return AV_CODEC_ID_ADPCM_EA;
    }
    private static final int AV_CODEC_ID_ADPCM_G726 = (int)69643L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_G726 = 69643
     * }
     */
    public static int AV_CODEC_ID_ADPCM_G726() {
        return AV_CODEC_ID_ADPCM_G726;
    }
    private static final int AV_CODEC_ID_ADPCM_CT = (int)69644L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_CT = 69644
     * }
     */
    public static int AV_CODEC_ID_ADPCM_CT() {
        return AV_CODEC_ID_ADPCM_CT;
    }
    private static final int AV_CODEC_ID_ADPCM_SWF = (int)69645L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_SWF = 69645
     * }
     */
    public static int AV_CODEC_ID_ADPCM_SWF() {
        return AV_CODEC_ID_ADPCM_SWF;
    }
    private static final int AV_CODEC_ID_ADPCM_YAMAHA = (int)69646L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_YAMAHA = 69646
     * }
     */
    public static int AV_CODEC_ID_ADPCM_YAMAHA() {
        return AV_CODEC_ID_ADPCM_YAMAHA;
    }
    private static final int AV_CODEC_ID_ADPCM_SBPRO_4 = (int)69647L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_SBPRO_4 = 69647
     * }
     */
    public static int AV_CODEC_ID_ADPCM_SBPRO_4() {
        return AV_CODEC_ID_ADPCM_SBPRO_4;
    }
    private static final int AV_CODEC_ID_ADPCM_SBPRO_3 = (int)69648L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_SBPRO_3 = 69648
     * }
     */
    public static int AV_CODEC_ID_ADPCM_SBPRO_3() {
        return AV_CODEC_ID_ADPCM_SBPRO_3;
    }
    private static final int AV_CODEC_ID_ADPCM_SBPRO_2 = (int)69649L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_SBPRO_2 = 69649
     * }
     */
    public static int AV_CODEC_ID_ADPCM_SBPRO_2() {
        return AV_CODEC_ID_ADPCM_SBPRO_2;
    }
    private static final int AV_CODEC_ID_ADPCM_THP = (int)69650L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_THP = 69650
     * }
     */
    public static int AV_CODEC_ID_ADPCM_THP() {
        return AV_CODEC_ID_ADPCM_THP;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_AMV = (int)69651L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_AMV = 69651
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_AMV() {
        return AV_CODEC_ID_ADPCM_IMA_AMV;
    }
    private static final int AV_CODEC_ID_ADPCM_EA_R1 = (int)69652L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_EA_R1 = 69652
     * }
     */
    public static int AV_CODEC_ID_ADPCM_EA_R1() {
        return AV_CODEC_ID_ADPCM_EA_R1;
    }
    private static final int AV_CODEC_ID_ADPCM_EA_R3 = (int)69653L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_EA_R3 = 69653
     * }
     */
    public static int AV_CODEC_ID_ADPCM_EA_R3() {
        return AV_CODEC_ID_ADPCM_EA_R3;
    }
    private static final int AV_CODEC_ID_ADPCM_EA_R2 = (int)69654L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_EA_R2 = 69654
     * }
     */
    public static int AV_CODEC_ID_ADPCM_EA_R2() {
        return AV_CODEC_ID_ADPCM_EA_R2;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_EA_SEAD = (int)69655L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_EA_SEAD() {
        return AV_CODEC_ID_ADPCM_IMA_EA_SEAD;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_EA_EACS = (int)69656L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_EA_EACS() {
        return AV_CODEC_ID_ADPCM_IMA_EA_EACS;
    }
    private static final int AV_CODEC_ID_ADPCM_EA_XAS = (int)69657L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_EA_XAS = 69657
     * }
     */
    public static int AV_CODEC_ID_ADPCM_EA_XAS() {
        return AV_CODEC_ID_ADPCM_EA_XAS;
    }
    private static final int AV_CODEC_ID_ADPCM_EA_MAXIS_XA = (int)69658L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658
     * }
     */
    public static int AV_CODEC_ID_ADPCM_EA_MAXIS_XA() {
        return AV_CODEC_ID_ADPCM_EA_MAXIS_XA;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_ISS = (int)69659L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_ISS = 69659
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_ISS() {
        return AV_CODEC_ID_ADPCM_IMA_ISS;
    }
    private static final int AV_CODEC_ID_ADPCM_G722 = (int)69660L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_G722 = 69660
     * }
     */
    public static int AV_CODEC_ID_ADPCM_G722() {
        return AV_CODEC_ID_ADPCM_G722;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_APC = (int)69661L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_APC = 69661
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_APC() {
        return AV_CODEC_ID_ADPCM_IMA_APC;
    }
    private static final int AV_CODEC_ID_ADPCM_VIMA = (int)69662L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_VIMA = 69662
     * }
     */
    public static int AV_CODEC_ID_ADPCM_VIMA() {
        return AV_CODEC_ID_ADPCM_VIMA;
    }
    private static final int AV_CODEC_ID_ADPCM_AFC = (int)69663L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_AFC = 69663
     * }
     */
    public static int AV_CODEC_ID_ADPCM_AFC() {
        return AV_CODEC_ID_ADPCM_AFC;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_OKI = (int)69664L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_OKI = 69664
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_OKI() {
        return AV_CODEC_ID_ADPCM_IMA_OKI;
    }
    private static final int AV_CODEC_ID_ADPCM_DTK = (int)69665L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_DTK = 69665
     * }
     */
    public static int AV_CODEC_ID_ADPCM_DTK() {
        return AV_CODEC_ID_ADPCM_DTK;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_RAD = (int)69666L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_RAD = 69666
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_RAD() {
        return AV_CODEC_ID_ADPCM_IMA_RAD;
    }
    private static final int AV_CODEC_ID_ADPCM_G726LE = (int)69667L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_G726LE = 69667
     * }
     */
    public static int AV_CODEC_ID_ADPCM_G726LE() {
        return AV_CODEC_ID_ADPCM_G726LE;
    }
    private static final int AV_CODEC_ID_ADPCM_THP_LE = (int)69668L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_THP_LE = 69668
     * }
     */
    public static int AV_CODEC_ID_ADPCM_THP_LE() {
        return AV_CODEC_ID_ADPCM_THP_LE;
    }
    private static final int AV_CODEC_ID_ADPCM_PSX = (int)69669L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_PSX = 69669
     * }
     */
    public static int AV_CODEC_ID_ADPCM_PSX() {
        return AV_CODEC_ID_ADPCM_PSX;
    }
    private static final int AV_CODEC_ID_ADPCM_AICA = (int)69670L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_AICA = 69670
     * }
     */
    public static int AV_CODEC_ID_ADPCM_AICA() {
        return AV_CODEC_ID_ADPCM_AICA;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_DAT4 = (int)69671L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_DAT4 = 69671
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_DAT4() {
        return AV_CODEC_ID_ADPCM_IMA_DAT4;
    }
    private static final int AV_CODEC_ID_ADPCM_MTAF = (int)69672L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_MTAF = 69672
     * }
     */
    public static int AV_CODEC_ID_ADPCM_MTAF() {
        return AV_CODEC_ID_ADPCM_MTAF;
    }
    private static final int AV_CODEC_ID_ADPCM_AGM = (int)69673L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_AGM = 69673
     * }
     */
    public static int AV_CODEC_ID_ADPCM_AGM() {
        return AV_CODEC_ID_ADPCM_AGM;
    }
    private static final int AV_CODEC_ID_ADPCM_ARGO = (int)69674L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_ARGO = 69674
     * }
     */
    public static int AV_CODEC_ID_ADPCM_ARGO() {
        return AV_CODEC_ID_ADPCM_ARGO;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_SSI = (int)69675L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_SSI = 69675
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_SSI() {
        return AV_CODEC_ID_ADPCM_IMA_SSI;
    }
    private static final int AV_CODEC_ID_ADPCM_ZORK = (int)69676L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_ZORK = 69676
     * }
     */
    public static int AV_CODEC_ID_ADPCM_ZORK() {
        return AV_CODEC_ID_ADPCM_ZORK;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_APM = (int)69677L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_APM = 69677
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_APM() {
        return AV_CODEC_ID_ADPCM_IMA_APM;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_ALP = (int)69678L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_ALP = 69678
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_ALP() {
        return AV_CODEC_ID_ADPCM_IMA_ALP;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_MTF = (int)69679L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_MTF = 69679
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_MTF() {
        return AV_CODEC_ID_ADPCM_IMA_MTF;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_CUNNING = (int)69680L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_CUNNING = 69680
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_CUNNING() {
        return AV_CODEC_ID_ADPCM_IMA_CUNNING;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_MOFLEX = (int)69681L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_MOFLEX = 69681
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_MOFLEX() {
        return AV_CODEC_ID_ADPCM_IMA_MOFLEX;
    }
    private static final int AV_CODEC_ID_ADPCM_IMA_ACORN = (int)69682L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ADPCM_IMA_ACORN = 69682
     * }
     */
    public static int AV_CODEC_ID_ADPCM_IMA_ACORN() {
        return AV_CODEC_ID_ADPCM_IMA_ACORN;
    }
    private static final int AV_CODEC_ID_AMR_NB = (int)73728L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AMR_NB = 73728
     * }
     */
    public static int AV_CODEC_ID_AMR_NB() {
        return AV_CODEC_ID_AMR_NB;
    }
    private static final int AV_CODEC_ID_AMR_WB = (int)73729L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AMR_WB = 73729
     * }
     */
    public static int AV_CODEC_ID_AMR_WB() {
        return AV_CODEC_ID_AMR_WB;
    }
    private static final int AV_CODEC_ID_RA_144 = (int)77824L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RA_144 = 77824
     * }
     */
    public static int AV_CODEC_ID_RA_144() {
        return AV_CODEC_ID_RA_144;
    }
    private static final int AV_CODEC_ID_RA_288 = (int)77825L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RA_288 = 77825
     * }
     */
    public static int AV_CODEC_ID_RA_288() {
        return AV_CODEC_ID_RA_288;
    }
    private static final int AV_CODEC_ID_ROQ_DPCM = (int)81920L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ROQ_DPCM = 81920
     * }
     */
    public static int AV_CODEC_ID_ROQ_DPCM() {
        return AV_CODEC_ID_ROQ_DPCM;
    }
    private static final int AV_CODEC_ID_INTERPLAY_DPCM = (int)81921L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_INTERPLAY_DPCM = 81921
     * }
     */
    public static int AV_CODEC_ID_INTERPLAY_DPCM() {
        return AV_CODEC_ID_INTERPLAY_DPCM;
    }
    private static final int AV_CODEC_ID_XAN_DPCM = (int)81922L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XAN_DPCM = 81922
     * }
     */
    public static int AV_CODEC_ID_XAN_DPCM() {
        return AV_CODEC_ID_XAN_DPCM;
    }
    private static final int AV_CODEC_ID_SOL_DPCM = (int)81923L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SOL_DPCM = 81923
     * }
     */
    public static int AV_CODEC_ID_SOL_DPCM() {
        return AV_CODEC_ID_SOL_DPCM;
    }
    private static final int AV_CODEC_ID_SDX2_DPCM = (int)81924L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SDX2_DPCM = 81924
     * }
     */
    public static int AV_CODEC_ID_SDX2_DPCM() {
        return AV_CODEC_ID_SDX2_DPCM;
    }
    private static final int AV_CODEC_ID_GREMLIN_DPCM = (int)81925L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_GREMLIN_DPCM = 81925
     * }
     */
    public static int AV_CODEC_ID_GREMLIN_DPCM() {
        return AV_CODEC_ID_GREMLIN_DPCM;
    }
    private static final int AV_CODEC_ID_DERF_DPCM = (int)81926L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DERF_DPCM = 81926
     * }
     */
    public static int AV_CODEC_ID_DERF_DPCM() {
        return AV_CODEC_ID_DERF_DPCM;
    }
    private static final int AV_CODEC_ID_MP2 = (int)86016L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MP2 = 86016
     * }
     */
    public static int AV_CODEC_ID_MP2() {
        return AV_CODEC_ID_MP2;
    }
    private static final int AV_CODEC_ID_MP3 = (int)86017L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MP3 = 86017
     * }
     */
    public static int AV_CODEC_ID_MP3() {
        return AV_CODEC_ID_MP3;
    }
    private static final int AV_CODEC_ID_AAC = (int)86018L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AAC = 86018
     * }
     */
    public static int AV_CODEC_ID_AAC() {
        return AV_CODEC_ID_AAC;
    }
    private static final int AV_CODEC_ID_AC3 = (int)86019L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AC3 = 86019
     * }
     */
    public static int AV_CODEC_ID_AC3() {
        return AV_CODEC_ID_AC3;
    }
    private static final int AV_CODEC_ID_DTS = (int)86020L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DTS = 86020
     * }
     */
    public static int AV_CODEC_ID_DTS() {
        return AV_CODEC_ID_DTS;
    }
    private static final int AV_CODEC_ID_VORBIS = (int)86021L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VORBIS = 86021
     * }
     */
    public static int AV_CODEC_ID_VORBIS() {
        return AV_CODEC_ID_VORBIS;
    }
    private static final int AV_CODEC_ID_DVAUDIO = (int)86022L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DVAUDIO = 86022
     * }
     */
    public static int AV_CODEC_ID_DVAUDIO() {
        return AV_CODEC_ID_DVAUDIO;
    }
    private static final int AV_CODEC_ID_WMAV1 = (int)86023L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMAV1 = 86023
     * }
     */
    public static int AV_CODEC_ID_WMAV1() {
        return AV_CODEC_ID_WMAV1;
    }
    private static final int AV_CODEC_ID_WMAV2 = (int)86024L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMAV2 = 86024
     * }
     */
    public static int AV_CODEC_ID_WMAV2() {
        return AV_CODEC_ID_WMAV2;
    }
    private static final int AV_CODEC_ID_MACE3 = (int)86025L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MACE3 = 86025
     * }
     */
    public static int AV_CODEC_ID_MACE3() {
        return AV_CODEC_ID_MACE3;
    }
    private static final int AV_CODEC_ID_MACE6 = (int)86026L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MACE6 = 86026
     * }
     */
    public static int AV_CODEC_ID_MACE6() {
        return AV_CODEC_ID_MACE6;
    }
    private static final int AV_CODEC_ID_VMDAUDIO = (int)86027L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VMDAUDIO = 86027
     * }
     */
    public static int AV_CODEC_ID_VMDAUDIO() {
        return AV_CODEC_ID_VMDAUDIO;
    }
    private static final int AV_CODEC_ID_FLAC = (int)86028L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FLAC = 86028
     * }
     */
    public static int AV_CODEC_ID_FLAC() {
        return AV_CODEC_ID_FLAC;
    }
    private static final int AV_CODEC_ID_MP3ADU = (int)86029L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MP3ADU = 86029
     * }
     */
    public static int AV_CODEC_ID_MP3ADU() {
        return AV_CODEC_ID_MP3ADU;
    }
    private static final int AV_CODEC_ID_MP3ON4 = (int)86030L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MP3ON4 = 86030
     * }
     */
    public static int AV_CODEC_ID_MP3ON4() {
        return AV_CODEC_ID_MP3ON4;
    }
    private static final int AV_CODEC_ID_SHORTEN = (int)86031L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SHORTEN = 86031
     * }
     */
    public static int AV_CODEC_ID_SHORTEN() {
        return AV_CODEC_ID_SHORTEN;
    }
    private static final int AV_CODEC_ID_ALAC = (int)86032L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ALAC = 86032
     * }
     */
    public static int AV_CODEC_ID_ALAC() {
        return AV_CODEC_ID_ALAC;
    }
    private static final int AV_CODEC_ID_WESTWOOD_SND1 = (int)86033L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WESTWOOD_SND1 = 86033
     * }
     */
    public static int AV_CODEC_ID_WESTWOOD_SND1() {
        return AV_CODEC_ID_WESTWOOD_SND1;
    }
    private static final int AV_CODEC_ID_GSM = (int)86034L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_GSM = 86034
     * }
     */
    public static int AV_CODEC_ID_GSM() {
        return AV_CODEC_ID_GSM;
    }
    private static final int AV_CODEC_ID_QDM2 = (int)86035L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_QDM2 = 86035
     * }
     */
    public static int AV_CODEC_ID_QDM2() {
        return AV_CODEC_ID_QDM2;
    }
    private static final int AV_CODEC_ID_COOK = (int)86036L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_COOK = 86036
     * }
     */
    public static int AV_CODEC_ID_COOK() {
        return AV_CODEC_ID_COOK;
    }
    private static final int AV_CODEC_ID_TRUESPEECH = (int)86037L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TRUESPEECH = 86037
     * }
     */
    public static int AV_CODEC_ID_TRUESPEECH() {
        return AV_CODEC_ID_TRUESPEECH;
    }
    private static final int AV_CODEC_ID_TTA = (int)86038L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TTA = 86038
     * }
     */
    public static int AV_CODEC_ID_TTA() {
        return AV_CODEC_ID_TTA;
    }
    private static final int AV_CODEC_ID_SMACKAUDIO = (int)86039L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SMACKAUDIO = 86039
     * }
     */
    public static int AV_CODEC_ID_SMACKAUDIO() {
        return AV_CODEC_ID_SMACKAUDIO;
    }
    private static final int AV_CODEC_ID_QCELP = (int)86040L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_QCELP = 86040
     * }
     */
    public static int AV_CODEC_ID_QCELP() {
        return AV_CODEC_ID_QCELP;
    }
    private static final int AV_CODEC_ID_WAVPACK = (int)86041L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WAVPACK = 86041
     * }
     */
    public static int AV_CODEC_ID_WAVPACK() {
        return AV_CODEC_ID_WAVPACK;
    }
    private static final int AV_CODEC_ID_DSICINAUDIO = (int)86042L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DSICINAUDIO = 86042
     * }
     */
    public static int AV_CODEC_ID_DSICINAUDIO() {
        return AV_CODEC_ID_DSICINAUDIO;
    }
    private static final int AV_CODEC_ID_IMC = (int)86043L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IMC = 86043
     * }
     */
    public static int AV_CODEC_ID_IMC() {
        return AV_CODEC_ID_IMC;
    }
    private static final int AV_CODEC_ID_MUSEPACK7 = (int)86044L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MUSEPACK7 = 86044
     * }
     */
    public static int AV_CODEC_ID_MUSEPACK7() {
        return AV_CODEC_ID_MUSEPACK7;
    }
    private static final int AV_CODEC_ID_MLP = (int)86045L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MLP = 86045
     * }
     */
    public static int AV_CODEC_ID_MLP() {
        return AV_CODEC_ID_MLP;
    }
    private static final int AV_CODEC_ID_GSM_MS = (int)86046L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_GSM_MS = 86046
     * }
     */
    public static int AV_CODEC_ID_GSM_MS() {
        return AV_CODEC_ID_GSM_MS;
    }
    private static final int AV_CODEC_ID_ATRAC3 = (int)86047L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ATRAC3 = 86047
     * }
     */
    public static int AV_CODEC_ID_ATRAC3() {
        return AV_CODEC_ID_ATRAC3;
    }
    private static final int AV_CODEC_ID_APE = (int)86048L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_APE = 86048
     * }
     */
    public static int AV_CODEC_ID_APE() {
        return AV_CODEC_ID_APE;
    }
    private static final int AV_CODEC_ID_NELLYMOSER = (int)86049L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_NELLYMOSER = 86049
     * }
     */
    public static int AV_CODEC_ID_NELLYMOSER() {
        return AV_CODEC_ID_NELLYMOSER;
    }
    private static final int AV_CODEC_ID_MUSEPACK8 = (int)86050L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MUSEPACK8 = 86050
     * }
     */
    public static int AV_CODEC_ID_MUSEPACK8() {
        return AV_CODEC_ID_MUSEPACK8;
    }
    private static final int AV_CODEC_ID_SPEEX = (int)86051L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SPEEX = 86051
     * }
     */
    public static int AV_CODEC_ID_SPEEX() {
        return AV_CODEC_ID_SPEEX;
    }
    private static final int AV_CODEC_ID_WMAVOICE = (int)86052L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMAVOICE = 86052
     * }
     */
    public static int AV_CODEC_ID_WMAVOICE() {
        return AV_CODEC_ID_WMAVOICE;
    }
    private static final int AV_CODEC_ID_WMAPRO = (int)86053L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMAPRO = 86053
     * }
     */
    public static int AV_CODEC_ID_WMAPRO() {
        return AV_CODEC_ID_WMAPRO;
    }
    private static final int AV_CODEC_ID_WMALOSSLESS = (int)86054L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WMALOSSLESS = 86054
     * }
     */
    public static int AV_CODEC_ID_WMALOSSLESS() {
        return AV_CODEC_ID_WMALOSSLESS;
    }
    private static final int AV_CODEC_ID_ATRAC3P = (int)86055L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ATRAC3P = 86055
     * }
     */
    public static int AV_CODEC_ID_ATRAC3P() {
        return AV_CODEC_ID_ATRAC3P;
    }
    private static final int AV_CODEC_ID_EAC3 = (int)86056L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_EAC3 = 86056
     * }
     */
    public static int AV_CODEC_ID_EAC3() {
        return AV_CODEC_ID_EAC3;
    }
    private static final int AV_CODEC_ID_SIPR = (int)86057L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SIPR = 86057
     * }
     */
    public static int AV_CODEC_ID_SIPR() {
        return AV_CODEC_ID_SIPR;
    }
    private static final int AV_CODEC_ID_MP1 = (int)86058L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MP1 = 86058
     * }
     */
    public static int AV_CODEC_ID_MP1() {
        return AV_CODEC_ID_MP1;
    }
    private static final int AV_CODEC_ID_TWINVQ = (int)86059L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TWINVQ = 86059
     * }
     */
    public static int AV_CODEC_ID_TWINVQ() {
        return AV_CODEC_ID_TWINVQ;
    }
    private static final int AV_CODEC_ID_TRUEHD = (int)86060L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TRUEHD = 86060
     * }
     */
    public static int AV_CODEC_ID_TRUEHD() {
        return AV_CODEC_ID_TRUEHD;
    }
    private static final int AV_CODEC_ID_MP4ALS = (int)86061L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MP4ALS = 86061
     * }
     */
    public static int AV_CODEC_ID_MP4ALS() {
        return AV_CODEC_ID_MP4ALS;
    }
    private static final int AV_CODEC_ID_ATRAC1 = (int)86062L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ATRAC1 = 86062
     * }
     */
    public static int AV_CODEC_ID_ATRAC1() {
        return AV_CODEC_ID_ATRAC1;
    }
    private static final int AV_CODEC_ID_BINKAUDIO_RDFT = (int)86063L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BINKAUDIO_RDFT = 86063
     * }
     */
    public static int AV_CODEC_ID_BINKAUDIO_RDFT() {
        return AV_CODEC_ID_BINKAUDIO_RDFT;
    }
    private static final int AV_CODEC_ID_BINKAUDIO_DCT = (int)86064L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BINKAUDIO_DCT = 86064
     * }
     */
    public static int AV_CODEC_ID_BINKAUDIO_DCT() {
        return AV_CODEC_ID_BINKAUDIO_DCT;
    }
    private static final int AV_CODEC_ID_AAC_LATM = (int)86065L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_AAC_LATM = 86065
     * }
     */
    public static int AV_CODEC_ID_AAC_LATM() {
        return AV_CODEC_ID_AAC_LATM;
    }
    private static final int AV_CODEC_ID_QDMC = (int)86066L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_QDMC = 86066
     * }
     */
    public static int AV_CODEC_ID_QDMC() {
        return AV_CODEC_ID_QDMC;
    }
    private static final int AV_CODEC_ID_CELT = (int)86067L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CELT = 86067
     * }
     */
    public static int AV_CODEC_ID_CELT() {
        return AV_CODEC_ID_CELT;
    }
    private static final int AV_CODEC_ID_G723_1 = (int)86068L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_G723_1 = 86068
     * }
     */
    public static int AV_CODEC_ID_G723_1() {
        return AV_CODEC_ID_G723_1;
    }
    private static final int AV_CODEC_ID_G729 = (int)86069L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_G729 = 86069
     * }
     */
    public static int AV_CODEC_ID_G729() {
        return AV_CODEC_ID_G729;
    }
    private static final int AV_CODEC_ID_8SVX_EXP = (int)86070L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_8SVX_EXP = 86070
     * }
     */
    public static int AV_CODEC_ID_8SVX_EXP() {
        return AV_CODEC_ID_8SVX_EXP;
    }
    private static final int AV_CODEC_ID_8SVX_FIB = (int)86071L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_8SVX_FIB = 86071
     * }
     */
    public static int AV_CODEC_ID_8SVX_FIB() {
        return AV_CODEC_ID_8SVX_FIB;
    }
    private static final int AV_CODEC_ID_BMV_AUDIO = (int)86072L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BMV_AUDIO = 86072
     * }
     */
    public static int AV_CODEC_ID_BMV_AUDIO() {
        return AV_CODEC_ID_BMV_AUDIO;
    }
    private static final int AV_CODEC_ID_RALF = (int)86073L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_RALF = 86073
     * }
     */
    public static int AV_CODEC_ID_RALF() {
        return AV_CODEC_ID_RALF;
    }
    private static final int AV_CODEC_ID_IAC = (int)86074L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IAC = 86074
     * }
     */
    public static int AV_CODEC_ID_IAC() {
        return AV_CODEC_ID_IAC;
    }
    private static final int AV_CODEC_ID_ILBC = (int)86075L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ILBC = 86075
     * }
     */
    public static int AV_CODEC_ID_ILBC() {
        return AV_CODEC_ID_ILBC;
    }
    private static final int AV_CODEC_ID_OPUS = (int)86076L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_OPUS = 86076
     * }
     */
    public static int AV_CODEC_ID_OPUS() {
        return AV_CODEC_ID_OPUS;
    }
    private static final int AV_CODEC_ID_COMFORT_NOISE = (int)86077L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_COMFORT_NOISE = 86077
     * }
     */
    public static int AV_CODEC_ID_COMFORT_NOISE() {
        return AV_CODEC_ID_COMFORT_NOISE;
    }
    private static final int AV_CODEC_ID_TAK = (int)86078L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TAK = 86078
     * }
     */
    public static int AV_CODEC_ID_TAK() {
        return AV_CODEC_ID_TAK;
    }
    private static final int AV_CODEC_ID_METASOUND = (int)86079L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_METASOUND = 86079
     * }
     */
    public static int AV_CODEC_ID_METASOUND() {
        return AV_CODEC_ID_METASOUND;
    }
    private static final int AV_CODEC_ID_PAF_AUDIO = (int)86080L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PAF_AUDIO = 86080
     * }
     */
    public static int AV_CODEC_ID_PAF_AUDIO() {
        return AV_CODEC_ID_PAF_AUDIO;
    }
    private static final int AV_CODEC_ID_ON2AVC = (int)86081L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ON2AVC = 86081
     * }
     */
    public static int AV_CODEC_ID_ON2AVC() {
        return AV_CODEC_ID_ON2AVC;
    }
    private static final int AV_CODEC_ID_DSS_SP = (int)86082L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DSS_SP = 86082
     * }
     */
    public static int AV_CODEC_ID_DSS_SP() {
        return AV_CODEC_ID_DSS_SP;
    }
    private static final int AV_CODEC_ID_CODEC2 = (int)86083L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_CODEC2 = 86083
     * }
     */
    public static int AV_CODEC_ID_CODEC2() {
        return AV_CODEC_ID_CODEC2;
    }
    private static final int AV_CODEC_ID_FFWAVESYNTH = (int)86084L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FFWAVESYNTH = 86084
     * }
     */
    public static int AV_CODEC_ID_FFWAVESYNTH() {
        return AV_CODEC_ID_FFWAVESYNTH;
    }
    private static final int AV_CODEC_ID_SONIC = (int)86085L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SONIC = 86085
     * }
     */
    public static int AV_CODEC_ID_SONIC() {
        return AV_CODEC_ID_SONIC;
    }
    private static final int AV_CODEC_ID_SONIC_LS = (int)86086L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SONIC_LS = 86086
     * }
     */
    public static int AV_CODEC_ID_SONIC_LS() {
        return AV_CODEC_ID_SONIC_LS;
    }
    private static final int AV_CODEC_ID_EVRC = (int)86087L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_EVRC = 86087
     * }
     */
    public static int AV_CODEC_ID_EVRC() {
        return AV_CODEC_ID_EVRC;
    }
    private static final int AV_CODEC_ID_SMV = (int)86088L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SMV = 86088
     * }
     */
    public static int AV_CODEC_ID_SMV() {
        return AV_CODEC_ID_SMV;
    }
    private static final int AV_CODEC_ID_DSD_LSBF = (int)86089L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DSD_LSBF = 86089
     * }
     */
    public static int AV_CODEC_ID_DSD_LSBF() {
        return AV_CODEC_ID_DSD_LSBF;
    }
    private static final int AV_CODEC_ID_DSD_MSBF = (int)86090L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DSD_MSBF = 86090
     * }
     */
    public static int AV_CODEC_ID_DSD_MSBF() {
        return AV_CODEC_ID_DSD_MSBF;
    }
    private static final int AV_CODEC_ID_DSD_LSBF_PLANAR = (int)86091L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DSD_LSBF_PLANAR = 86091
     * }
     */
    public static int AV_CODEC_ID_DSD_LSBF_PLANAR() {
        return AV_CODEC_ID_DSD_LSBF_PLANAR;
    }
    private static final int AV_CODEC_ID_DSD_MSBF_PLANAR = (int)86092L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DSD_MSBF_PLANAR = 86092
     * }
     */
    public static int AV_CODEC_ID_DSD_MSBF_PLANAR() {
        return AV_CODEC_ID_DSD_MSBF_PLANAR;
    }
    private static final int AV_CODEC_ID_4GV = (int)86093L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_4GV = 86093
     * }
     */
    public static int AV_CODEC_ID_4GV() {
        return AV_CODEC_ID_4GV;
    }
    private static final int AV_CODEC_ID_INTERPLAY_ACM = (int)86094L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_INTERPLAY_ACM = 86094
     * }
     */
    public static int AV_CODEC_ID_INTERPLAY_ACM() {
        return AV_CODEC_ID_INTERPLAY_ACM;
    }
    private static final int AV_CODEC_ID_XMA1 = (int)86095L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XMA1 = 86095
     * }
     */
    public static int AV_CODEC_ID_XMA1() {
        return AV_CODEC_ID_XMA1;
    }
    private static final int AV_CODEC_ID_XMA2 = (int)86096L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XMA2 = 86096
     * }
     */
    public static int AV_CODEC_ID_XMA2() {
        return AV_CODEC_ID_XMA2;
    }
    private static final int AV_CODEC_ID_DST = (int)86097L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DST = 86097
     * }
     */
    public static int AV_CODEC_ID_DST() {
        return AV_CODEC_ID_DST;
    }
    private static final int AV_CODEC_ID_ATRAC3AL = (int)86098L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ATRAC3AL = 86098
     * }
     */
    public static int AV_CODEC_ID_ATRAC3AL() {
        return AV_CODEC_ID_ATRAC3AL;
    }
    private static final int AV_CODEC_ID_ATRAC3PAL = (int)86099L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ATRAC3PAL = 86099
     * }
     */
    public static int AV_CODEC_ID_ATRAC3PAL() {
        return AV_CODEC_ID_ATRAC3PAL;
    }
    private static final int AV_CODEC_ID_DOLBY_E = (int)86100L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DOLBY_E = 86100
     * }
     */
    public static int AV_CODEC_ID_DOLBY_E() {
        return AV_CODEC_ID_DOLBY_E;
    }
    private static final int AV_CODEC_ID_APTX = (int)86101L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_APTX = 86101
     * }
     */
    public static int AV_CODEC_ID_APTX() {
        return AV_CODEC_ID_APTX;
    }
    private static final int AV_CODEC_ID_APTX_HD = (int)86102L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_APTX_HD = 86102
     * }
     */
    public static int AV_CODEC_ID_APTX_HD() {
        return AV_CODEC_ID_APTX_HD;
    }
    private static final int AV_CODEC_ID_SBC = (int)86103L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SBC = 86103
     * }
     */
    public static int AV_CODEC_ID_SBC() {
        return AV_CODEC_ID_SBC;
    }
    private static final int AV_CODEC_ID_ATRAC9 = (int)86104L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ATRAC9 = 86104
     * }
     */
    public static int AV_CODEC_ID_ATRAC9() {
        return AV_CODEC_ID_ATRAC9;
    }
    private static final int AV_CODEC_ID_HCOM = (int)86105L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HCOM = 86105
     * }
     */
    public static int AV_CODEC_ID_HCOM() {
        return AV_CODEC_ID_HCOM;
    }
    private static final int AV_CODEC_ID_ACELP_KELVIN = (int)86106L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ACELP_KELVIN = 86106
     * }
     */
    public static int AV_CODEC_ID_ACELP_KELVIN() {
        return AV_CODEC_ID_ACELP_KELVIN;
    }
    private static final int AV_CODEC_ID_MPEGH_3D_AUDIO = (int)86107L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MPEGH_3D_AUDIO = 86107
     * }
     */
    public static int AV_CODEC_ID_MPEGH_3D_AUDIO() {
        return AV_CODEC_ID_MPEGH_3D_AUDIO;
    }
    private static final int AV_CODEC_ID_SIREN = (int)86108L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SIREN = 86108
     * }
     */
    public static int AV_CODEC_ID_SIREN() {
        return AV_CODEC_ID_SIREN;
    }
    private static final int AV_CODEC_ID_HCA = (int)86109L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HCA = 86109
     * }
     */
    public static int AV_CODEC_ID_HCA() {
        return AV_CODEC_ID_HCA;
    }
    private static final int AV_CODEC_ID_FASTAUDIO = (int)86110L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FASTAUDIO = 86110
     * }
     */
    public static int AV_CODEC_ID_FASTAUDIO() {
        return AV_CODEC_ID_FASTAUDIO;
    }
    private static final int AV_CODEC_ID_MSNSIREN = (int)86111L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MSNSIREN = 86111
     * }
     */
    public static int AV_CODEC_ID_MSNSIREN() {
        return AV_CODEC_ID_MSNSIREN;
    }
    private static final int AV_CODEC_ID_DFPWM = (int)86112L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DFPWM = 86112
     * }
     */
    public static int AV_CODEC_ID_DFPWM() {
        return AV_CODEC_ID_DFPWM;
    }
    private static final int AV_CODEC_ID_FIRST_SUBTITLE = (int)94208L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FIRST_SUBTITLE = 94208
     * }
     */
    public static int AV_CODEC_ID_FIRST_SUBTITLE() {
        return AV_CODEC_ID_FIRST_SUBTITLE;
    }
    private static final int AV_CODEC_ID_DVD_SUBTITLE = (int)94208L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DVD_SUBTITLE = 94208
     * }
     */
    public static int AV_CODEC_ID_DVD_SUBTITLE() {
        return AV_CODEC_ID_DVD_SUBTITLE;
    }
    private static final int AV_CODEC_ID_DVB_SUBTITLE = (int)94209L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DVB_SUBTITLE = 94209
     * }
     */
    public static int AV_CODEC_ID_DVB_SUBTITLE() {
        return AV_CODEC_ID_DVB_SUBTITLE;
    }
    private static final int AV_CODEC_ID_TEXT = (int)94210L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TEXT = 94210
     * }
     */
    public static int AV_CODEC_ID_TEXT() {
        return AV_CODEC_ID_TEXT;
    }
    private static final int AV_CODEC_ID_XSUB = (int)94211L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XSUB = 94211
     * }
     */
    public static int AV_CODEC_ID_XSUB() {
        return AV_CODEC_ID_XSUB;
    }
    private static final int AV_CODEC_ID_SSA = (int)94212L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SSA = 94212
     * }
     */
    public static int AV_CODEC_ID_SSA() {
        return AV_CODEC_ID_SSA;
    }
    private static final int AV_CODEC_ID_MOV_TEXT = (int)94213L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MOV_TEXT = 94213
     * }
     */
    public static int AV_CODEC_ID_MOV_TEXT() {
        return AV_CODEC_ID_MOV_TEXT;
    }
    private static final int AV_CODEC_ID_HDMV_PGS_SUBTITLE = (int)94214L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214
     * }
     */
    public static int AV_CODEC_ID_HDMV_PGS_SUBTITLE() {
        return AV_CODEC_ID_HDMV_PGS_SUBTITLE;
    }
    private static final int AV_CODEC_ID_DVB_TELETEXT = (int)94215L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DVB_TELETEXT = 94215
     * }
     */
    public static int AV_CODEC_ID_DVB_TELETEXT() {
        return AV_CODEC_ID_DVB_TELETEXT;
    }
    private static final int AV_CODEC_ID_SRT = (int)94216L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SRT = 94216
     * }
     */
    public static int AV_CODEC_ID_SRT() {
        return AV_CODEC_ID_SRT;
    }
    private static final int AV_CODEC_ID_MICRODVD = (int)94217L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MICRODVD = 94217
     * }
     */
    public static int AV_CODEC_ID_MICRODVD() {
        return AV_CODEC_ID_MICRODVD;
    }
    private static final int AV_CODEC_ID_EIA_608 = (int)94218L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_EIA_608 = 94218
     * }
     */
    public static int AV_CODEC_ID_EIA_608() {
        return AV_CODEC_ID_EIA_608;
    }
    private static final int AV_CODEC_ID_JACOSUB = (int)94219L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_JACOSUB = 94219
     * }
     */
    public static int AV_CODEC_ID_JACOSUB() {
        return AV_CODEC_ID_JACOSUB;
    }
    private static final int AV_CODEC_ID_SAMI = (int)94220L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SAMI = 94220
     * }
     */
    public static int AV_CODEC_ID_SAMI() {
        return AV_CODEC_ID_SAMI;
    }
    private static final int AV_CODEC_ID_REALTEXT = (int)94221L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_REALTEXT = 94221
     * }
     */
    public static int AV_CODEC_ID_REALTEXT() {
        return AV_CODEC_ID_REALTEXT;
    }
    private static final int AV_CODEC_ID_STL = (int)94222L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_STL = 94222
     * }
     */
    public static int AV_CODEC_ID_STL() {
        return AV_CODEC_ID_STL;
    }
    private static final int AV_CODEC_ID_SUBVIEWER1 = (int)94223L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SUBVIEWER1 = 94223
     * }
     */
    public static int AV_CODEC_ID_SUBVIEWER1() {
        return AV_CODEC_ID_SUBVIEWER1;
    }
    private static final int AV_CODEC_ID_SUBVIEWER = (int)94224L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SUBVIEWER = 94224
     * }
     */
    public static int AV_CODEC_ID_SUBVIEWER() {
        return AV_CODEC_ID_SUBVIEWER;
    }
    private static final int AV_CODEC_ID_SUBRIP = (int)94225L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SUBRIP = 94225
     * }
     */
    public static int AV_CODEC_ID_SUBRIP() {
        return AV_CODEC_ID_SUBRIP;
    }
    private static final int AV_CODEC_ID_WEBVTT = (int)94226L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WEBVTT = 94226
     * }
     */
    public static int AV_CODEC_ID_WEBVTT() {
        return AV_CODEC_ID_WEBVTT;
    }
    private static final int AV_CODEC_ID_MPL2 = (int)94227L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MPL2 = 94227
     * }
     */
    public static int AV_CODEC_ID_MPL2() {
        return AV_CODEC_ID_MPL2;
    }
    private static final int AV_CODEC_ID_VPLAYER = (int)94228L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_VPLAYER = 94228
     * }
     */
    public static int AV_CODEC_ID_VPLAYER() {
        return AV_CODEC_ID_VPLAYER;
    }
    private static final int AV_CODEC_ID_PJS = (int)94229L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PJS = 94229
     * }
     */
    public static int AV_CODEC_ID_PJS() {
        return AV_CODEC_ID_PJS;
    }
    private static final int AV_CODEC_ID_ASS = (int)94230L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ASS = 94230
     * }
     */
    public static int AV_CODEC_ID_ASS() {
        return AV_CODEC_ID_ASS;
    }
    private static final int AV_CODEC_ID_HDMV_TEXT_SUBTITLE = (int)94231L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 94231
     * }
     */
    public static int AV_CODEC_ID_HDMV_TEXT_SUBTITLE() {
        return AV_CODEC_ID_HDMV_TEXT_SUBTITLE;
    }
    private static final int AV_CODEC_ID_TTML = (int)94232L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TTML = 94232
     * }
     */
    public static int AV_CODEC_ID_TTML() {
        return AV_CODEC_ID_TTML;
    }
    private static final int AV_CODEC_ID_ARIB_CAPTION = (int)94233L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_ARIB_CAPTION = 94233
     * }
     */
    public static int AV_CODEC_ID_ARIB_CAPTION() {
        return AV_CODEC_ID_ARIB_CAPTION;
    }
    private static final int AV_CODEC_ID_FIRST_UNKNOWN = (int)98304L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FIRST_UNKNOWN = 98304
     * }
     */
    public static int AV_CODEC_ID_FIRST_UNKNOWN() {
        return AV_CODEC_ID_FIRST_UNKNOWN;
    }
    private static final int AV_CODEC_ID_TTF = (int)98304L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TTF = 98304
     * }
     */
    public static int AV_CODEC_ID_TTF() {
        return AV_CODEC_ID_TTF;
    }
    private static final int AV_CODEC_ID_SCTE_35 = (int)98305L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SCTE_35 = 98305
     * }
     */
    public static int AV_CODEC_ID_SCTE_35() {
        return AV_CODEC_ID_SCTE_35;
    }
    private static final int AV_CODEC_ID_EPG = (int)98306L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_EPG = 98306
     * }
     */
    public static int AV_CODEC_ID_EPG() {
        return AV_CODEC_ID_EPG;
    }
    private static final int AV_CODEC_ID_BINTEXT = (int)98307L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BINTEXT = 98307
     * }
     */
    public static int AV_CODEC_ID_BINTEXT() {
        return AV_CODEC_ID_BINTEXT;
    }
    private static final int AV_CODEC_ID_XBIN = (int)98308L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_XBIN = 98308
     * }
     */
    public static int AV_CODEC_ID_XBIN() {
        return AV_CODEC_ID_XBIN;
    }
    private static final int AV_CODEC_ID_IDF = (int)98309L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_IDF = 98309
     * }
     */
    public static int AV_CODEC_ID_IDF() {
        return AV_CODEC_ID_IDF;
    }
    private static final int AV_CODEC_ID_OTF = (int)98310L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_OTF = 98310
     * }
     */
    public static int AV_CODEC_ID_OTF() {
        return AV_CODEC_ID_OTF;
    }
    private static final int AV_CODEC_ID_SMPTE_KLV = (int)98311L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_SMPTE_KLV = 98311
     * }
     */
    public static int AV_CODEC_ID_SMPTE_KLV() {
        return AV_CODEC_ID_SMPTE_KLV;
    }
    private static final int AV_CODEC_ID_DVD_NAV = (int)98312L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_DVD_NAV = 98312
     * }
     */
    public static int AV_CODEC_ID_DVD_NAV() {
        return AV_CODEC_ID_DVD_NAV;
    }
    private static final int AV_CODEC_ID_TIMED_ID3 = (int)98313L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_TIMED_ID3 = 98313
     * }
     */
    public static int AV_CODEC_ID_TIMED_ID3() {
        return AV_CODEC_ID_TIMED_ID3;
    }
    private static final int AV_CODEC_ID_BIN_DATA = (int)98314L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_BIN_DATA = 98314
     * }
     */
    public static int AV_CODEC_ID_BIN_DATA() {
        return AV_CODEC_ID_BIN_DATA;
    }
    private static final int AV_CODEC_ID_PROBE = (int)102400L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_PROBE = 102400
     * }
     */
    public static int AV_CODEC_ID_PROBE() {
        return AV_CODEC_ID_PROBE;
    }
    private static final int AV_CODEC_ID_MPEG2TS = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MPEG2TS = 131072
     * }
     */
    public static int AV_CODEC_ID_MPEG2TS() {
        return AV_CODEC_ID_MPEG2TS;
    }
    private static final int AV_CODEC_ID_MPEG4SYSTEMS = (int)131073L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_MPEG4SYSTEMS = 131073
     * }
     */
    public static int AV_CODEC_ID_MPEG4SYSTEMS() {
        return AV_CODEC_ID_MPEG4SYSTEMS;
    }
    private static final int AV_CODEC_ID_FFMETADATA = (int)135168L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_FFMETADATA = 135168
     * }
     */
    public static int AV_CODEC_ID_FFMETADATA() {
        return AV_CODEC_ID_FFMETADATA;
    }
    private static final int AV_CODEC_ID_WRAPPED_AVFRAME = (int)135169L;
    /**
     * {@snippet lang=c :
     * enum AVCodecID.AV_CODEC_ID_WRAPPED_AVFRAME = 135169
     * }
     */
    public static int AV_CODEC_ID_WRAPPED_AVFRAME() {
        return AV_CODEC_ID_WRAPPED_AVFRAME;
    }

    private static class avcodec_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVMediaType avcodec_get_type(enum AVCodecID codec_id)
     * }
     */
    public static FunctionDescriptor avcodec_get_type$descriptor() {
        return avcodec_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVMediaType avcodec_get_type(enum AVCodecID codec_id)
     * }
     */
    public static MethodHandle avcodec_get_type$handle() {
        return avcodec_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVMediaType avcodec_get_type(enum AVCodecID codec_id)
     * }
     */
    public static MemorySegment avcodec_get_type$address() {
        return avcodec_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVMediaType avcodec_get_type(enum AVCodecID codec_id)
     * }
     */
    public static int avcodec_get_type(int codec_id) {
        var mh$ = avcodec_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_type", codec_id);
            }
            return (int)mh$.invokeExact(codec_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_get_name(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_get_name$descriptor() {
        return avcodec_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_get_name(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_get_name$handle() {
        return avcodec_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_get_name(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_get_name$address() {
        return avcodec_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_get_name(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_get_name(int id) {
        var mh$ = avcodec_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_name", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_bits_per_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_bits_per_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static FunctionDescriptor av_get_bits_per_sample$descriptor() {
        return av_get_bits_per_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static MethodHandle av_get_bits_per_sample$handle() {
        return av_get_bits_per_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static MemorySegment av_get_bits_per_sample$address() {
        return av_get_bits_per_sample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static int av_get_bits_per_sample(int codec_id) {
        var mh$ = av_get_bits_per_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_bits_per_sample", codec_id);
            }
            return (int)mh$.invokeExact(codec_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_exact_bits_per_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_exact_bits_per_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_exact_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static FunctionDescriptor av_get_exact_bits_per_sample$descriptor() {
        return av_get_exact_bits_per_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_exact_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static MethodHandle av_get_exact_bits_per_sample$handle() {
        return av_get_exact_bits_per_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_exact_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static MemorySegment av_get_exact_bits_per_sample$address() {
        return av_get_exact_bits_per_sample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_exact_bits_per_sample(enum AVCodecID codec_id)
     * }
     */
    public static int av_get_exact_bits_per_sample(int codec_id) {
        var mh$ = av_get_exact_bits_per_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_exact_bits_per_sample", codec_id);
            }
            return (int)mh$.invokeExact(codec_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_profile_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_profile_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_profile_name(enum AVCodecID codec_id, int profile)
     * }
     */
    public static FunctionDescriptor avcodec_profile_name$descriptor() {
        return avcodec_profile_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_profile_name(enum AVCodecID codec_id, int profile)
     * }
     */
    public static MethodHandle avcodec_profile_name$handle() {
        return avcodec_profile_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_profile_name(enum AVCodecID codec_id, int profile)
     * }
     */
    public static MemorySegment avcodec_profile_name$address() {
        return avcodec_profile_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_profile_name(enum AVCodecID codec_id, int profile)
     * }
     */
    public static MemorySegment avcodec_profile_name(int codec_id, int profile) {
        var mh$ = avcodec_profile_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_profile_name", codec_id, profile);
            }
            return (MemorySegment)mh$.invokeExact(codec_id, profile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pcm_codec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_pcm_codec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be)
     * }
     */
    public static FunctionDescriptor av_get_pcm_codec$descriptor() {
        return av_get_pcm_codec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be)
     * }
     */
    public static MethodHandle av_get_pcm_codec$handle() {
        return av_get_pcm_codec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be)
     * }
     */
    public static MemorySegment av_get_pcm_codec$address() {
        return av_get_pcm_codec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be)
     * }
     */
    public static int av_get_pcm_codec(int fmt, int be) {
        var mh$ = av_get_pcm_codec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pcm_codec", fmt, be);
            }
            return (int)mh$.invokeExact(fmt, be);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_codec_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_codec_iterate$descriptor() {
        return av_codec_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_codec_iterate$handle() {
        return av_codec_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_codec_iterate$address() {
        return av_codec_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_codec_iterate(MemorySegment opaque) {
        var mh$ = av_codec_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_find_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_find_decoder$descriptor() {
        return avcodec_find_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_find_decoder$handle() {
        return avcodec_find_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_decoder$address() {
        return avcodec_find_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_decoder(int id) {
        var mh$ = avcodec_find_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_decoder", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_decoder_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_find_decoder_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_find_decoder_by_name$descriptor() {
        return avcodec_find_decoder_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_find_decoder_by_name$handle() {
        return avcodec_find_decoder_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_decoder_by_name$address() {
        return avcodec_find_decoder_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_decoder_by_name(MemorySegment name) {
        var mh$ = avcodec_find_decoder_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_decoder_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_find_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_find_encoder$descriptor() {
        return avcodec_find_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_find_encoder$handle() {
        return avcodec_find_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_encoder$address() {
        return avcodec_find_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_encoder(int id) {
        var mh$ = avcodec_find_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_encoder", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_encoder_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_find_encoder_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_find_encoder_by_name$descriptor() {
        return avcodec_find_encoder_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_find_encoder_by_name$handle() {
        return avcodec_find_encoder_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_encoder_by_name$address() {
        return avcodec_find_encoder_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_encoder_by_name(MemorySegment name) {
        var mh$ = avcodec_find_encoder_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_encoder_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_is_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_codec_is_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor av_codec_is_encoder$descriptor() {
        return av_codec_is_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static MethodHandle av_codec_is_encoder$handle() {
        return av_codec_is_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static MemorySegment av_codec_is_encoder$address() {
        return av_codec_is_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static int av_codec_is_encoder(MemorySegment codec) {
        var mh$ = av_codec_is_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_is_encoder", codec);
            }
            return (int)mh$.invokeExact(codec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_is_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_codec_is_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor av_codec_is_decoder$descriptor() {
        return av_codec_is_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static MethodHandle av_codec_is_decoder$handle() {
        return av_codec_is_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static MemorySegment av_codec_is_decoder$address() {
        return av_codec_is_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static int av_codec_is_decoder(MemorySegment codec) {
        var mh$ = av_codec_is_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_is_decoder", codec);
            }
            return (int)mh$.invokeExact(codec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_profile_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_profile_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static FunctionDescriptor av_get_profile_name$descriptor() {
        return av_get_profile_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MethodHandle av_get_profile_name$handle() {
        return av_get_profile_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MemorySegment av_get_profile_name$address() {
        return av_get_profile_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MemorySegment av_get_profile_name(MemorySegment codec, int profile) {
        var mh$ = av_get_profile_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_profile_name", codec, profile);
            }
            return (MemorySegment)mh$.invokeExact(codec, profile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX() {
        return AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX;
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX() {
        return AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX;
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_INTERNAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_INTERNAL() {
        return AV_CODEC_HW_CONFIG_METHOD_INTERNAL;
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_AD_HOC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_AD_HOC() {
        return AV_CODEC_HW_CONFIG_METHOD_AD_HOC;
    }

    private static class avcodec_get_hw_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_get_hw_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static FunctionDescriptor avcodec_get_hw_config$descriptor() {
        return avcodec_get_hw_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MethodHandle avcodec_get_hw_config$handle() {
        return avcodec_get_hw_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MemorySegment avcodec_get_hw_config$address() {
        return avcodec_get_hw_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MemorySegment avcodec_get_hw_config(MemorySegment codec, int index) {
        var mh$ = avcodec_get_hw_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_hw_config", codec, index);
            }
            return (MemorySegment)mh$.invokeExact(codec, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_descriptor_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_descriptor_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_descriptor_get$descriptor() {
        return avcodec_descriptor_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_descriptor_get$handle() {
        return avcodec_descriptor_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_descriptor_get$address() {
        return avcodec_descriptor_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_descriptor_get(int id) {
        var mh$ = avcodec_descriptor_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_descriptor_get", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_descriptor_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_descriptor_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static FunctionDescriptor avcodec_descriptor_next$descriptor() {
        return avcodec_descriptor_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static MethodHandle avcodec_descriptor_next$handle() {
        return avcodec_descriptor_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static MemorySegment avcodec_descriptor_next$address() {
        return avcodec_descriptor_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static MemorySegment avcodec_descriptor_next(MemorySegment prev) {
        var mh$ = avcodec_descriptor_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_descriptor_next", prev);
            }
            return (MemorySegment)mh$.invokeExact(prev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_descriptor_get_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_descriptor_get_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_descriptor_get_by_name$descriptor() {
        return avcodec_descriptor_get_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_descriptor_get_by_name$handle() {
        return avcodec_descriptor_get_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_descriptor_get_by_name$address() {
        return avcodec_descriptor_get_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_descriptor_get_by_name(MemorySegment name) {
        var mh$ = avcodec_descriptor_get_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_descriptor_get_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_FIELD_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVFieldOrder.AV_FIELD_UNKNOWN = 0
     * }
     */
    public static int AV_FIELD_UNKNOWN() {
        return AV_FIELD_UNKNOWN;
    }
    private static final int AV_FIELD_PROGRESSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVFieldOrder.AV_FIELD_PROGRESSIVE = 1
     * }
     */
    public static int AV_FIELD_PROGRESSIVE() {
        return AV_FIELD_PROGRESSIVE;
    }
    private static final int AV_FIELD_TT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVFieldOrder.AV_FIELD_TT = 2
     * }
     */
    public static int AV_FIELD_TT() {
        return AV_FIELD_TT;
    }
    private static final int AV_FIELD_BB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVFieldOrder.AV_FIELD_BB = 3
     * }
     */
    public static int AV_FIELD_BB() {
        return AV_FIELD_BB;
    }
    private static final int AV_FIELD_TB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVFieldOrder.AV_FIELD_TB = 4
     * }
     */
    public static int AV_FIELD_TB() {
        return AV_FIELD_TB;
    }
    private static final int AV_FIELD_BT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVFieldOrder.AV_FIELD_BT = 5
     * }
     */
    public static int AV_FIELD_BT() {
        return AV_FIELD_BT;
    }

    private static class avcodec_parameters_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_parameters_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static FunctionDescriptor avcodec_parameters_alloc$descriptor() {
        return avcodec_parameters_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static MethodHandle avcodec_parameters_alloc$handle() {
        return avcodec_parameters_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static MemorySegment avcodec_parameters_alloc$address() {
        return avcodec_parameters_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecParameters *avcodec_parameters_alloc()
     * }
     */
    public static MemorySegment avcodec_parameters_alloc() {
        var mh$ = avcodec_parameters_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_parameters_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_free$descriptor() {
        return avcodec_parameters_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static MethodHandle avcodec_parameters_free$handle() {
        return avcodec_parameters_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static MemorySegment avcodec_parameters_free$address() {
        return avcodec_parameters_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_parameters_free(AVCodecParameters **par)
     * }
     */
    public static void avcodec_parameters_free(MemorySegment par) {
        var mh$ = avcodec_parameters_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_free", par);
            }
            mh$.invokeExact(par);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_parameters_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_copy$descriptor() {
        return avcodec_parameters_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static MethodHandle avcodec_parameters_copy$handle() {
        return avcodec_parameters_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static MemorySegment avcodec_parameters_copy$address() {
        return avcodec_parameters_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
     * }
     */
    public static int avcodec_parameters_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = avcodec_parameters_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_audio_frame_duration2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_audio_frame_duration2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static FunctionDescriptor av_get_audio_frame_duration2$descriptor() {
        return av_get_audio_frame_duration2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static MethodHandle av_get_audio_frame_duration2$handle() {
        return av_get_audio_frame_duration2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static MemorySegment av_get_audio_frame_duration2$address() {
        return av_get_audio_frame_duration2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
     * }
     */
    public static int av_get_audio_frame_duration2(MemorySegment par, int frame_bytes) {
        var mh$ = av_get_audio_frame_duration2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_audio_frame_duration2", par, frame_bytes);
            }
            return (int)mh$.invokeExact(par, frame_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVDISCARD_NONE = (int)-16L;
    /**
     * {@snippet lang=c :
     * enum AVDiscard.AVDISCARD_NONE = -16
     * }
     */
    public static int AVDISCARD_NONE() {
        return AVDISCARD_NONE;
    }
    private static final int AVDISCARD_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVDiscard.AVDISCARD_DEFAULT = 0
     * }
     */
    public static int AVDISCARD_DEFAULT() {
        return AVDISCARD_DEFAULT;
    }
    private static final int AVDISCARD_NONREF = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVDiscard.AVDISCARD_NONREF = 8
     * }
     */
    public static int AVDISCARD_NONREF() {
        return AVDISCARD_NONREF;
    }
    private static final int AVDISCARD_BIDIR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVDiscard.AVDISCARD_BIDIR = 16
     * }
     */
    public static int AVDISCARD_BIDIR() {
        return AVDISCARD_BIDIR;
    }
    private static final int AVDISCARD_NONINTRA = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVDiscard.AVDISCARD_NONINTRA = 24
     * }
     */
    public static int AVDISCARD_NONINTRA() {
        return AVDISCARD_NONINTRA;
    }
    private static final int AVDISCARD_NONKEY = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVDiscard.AVDISCARD_NONKEY = 32
     * }
     */
    public static int AVDISCARD_NONKEY() {
        return AVDISCARD_NONKEY;
    }
    private static final int AVDISCARD_ALL = (int)48L;
    /**
     * {@snippet lang=c :
     * enum AVDiscard.AVDISCARD_ALL = 48
     * }
     */
    public static int AVDISCARD_ALL() {
        return AVDISCARD_ALL;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_MAIN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_MAIN = 0
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_MAIN() {
        return AV_AUDIO_SERVICE_TYPE_MAIN;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_EFFECTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_EFFECTS = 1
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_EFFECTS() {
        return AV_AUDIO_SERVICE_TYPE_EFFECTS;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED() {
        return AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED() {
        return AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_DIALOGUE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_DIALOGUE() {
        return AV_AUDIO_SERVICE_TYPE_DIALOGUE;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_COMMENTARY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_COMMENTARY() {
        return AV_AUDIO_SERVICE_TYPE_COMMENTARY;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_EMERGENCY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_EMERGENCY() {
        return AV_AUDIO_SERVICE_TYPE_EMERGENCY;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_VOICE_OVER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_VOICE_OVER() {
        return AV_AUDIO_SERVICE_TYPE_VOICE_OVER;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_KARAOKE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_KARAOKE = 8
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_KARAOKE() {
        return AV_AUDIO_SERVICE_TYPE_KARAOKE;
    }
    private static final int AV_AUDIO_SERVICE_TYPE_NB = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_NB = 9
     * }
     */
    public static int AV_AUDIO_SERVICE_TYPE_NB() {
        return AV_AUDIO_SERVICE_TYPE_NB;
    }

    private static class av_cpb_properties_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_cpb_properties_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCPBProperties *av_cpb_properties_alloc(size_t *size)
     * }
     */
    public static FunctionDescriptor av_cpb_properties_alloc$descriptor() {
        return av_cpb_properties_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCPBProperties *av_cpb_properties_alloc(size_t *size)
     * }
     */
    public static MethodHandle av_cpb_properties_alloc$handle() {
        return av_cpb_properties_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCPBProperties *av_cpb_properties_alloc(size_t *size)
     * }
     */
    public static MemorySegment av_cpb_properties_alloc$address() {
        return av_cpb_properties_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCPBProperties *av_cpb_properties_alloc(size_t *size)
     * }
     */
    public static MemorySegment av_cpb_properties_alloc(MemorySegment size) {
        var mh$ = av_cpb_properties_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_cpb_properties_alloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_xiphlacing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_xiphlacing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_xiphlacing(unsigned char *s, unsigned int v)
     * }
     */
    public static FunctionDescriptor av_xiphlacing$descriptor() {
        return av_xiphlacing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_xiphlacing(unsigned char *s, unsigned int v)
     * }
     */
    public static MethodHandle av_xiphlacing$handle() {
        return av_xiphlacing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_xiphlacing(unsigned char *s, unsigned int v)
     * }
     */
    public static MemorySegment av_xiphlacing$address() {
        return av_xiphlacing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_xiphlacing(unsigned char *s, unsigned int v)
     * }
     */
    public static int av_xiphlacing(MemorySegment s, int v) {
        var mh$ = av_xiphlacing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_xiphlacing", s, v);
            }
            return (int)mh$.invokeExact(s, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PKT_DATA_PALETTE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_PALETTE = 0
     * }
     */
    public static int AV_PKT_DATA_PALETTE() {
        return AV_PKT_DATA_PALETTE;
    }
    private static final int AV_PKT_DATA_NEW_EXTRADATA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA = 1
     * }
     */
    public static int AV_PKT_DATA_NEW_EXTRADATA() {
        return AV_PKT_DATA_NEW_EXTRADATA;
    }
    private static final int AV_PKT_DATA_PARAM_CHANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_PARAM_CHANGE = 2
     * }
     */
    public static int AV_PKT_DATA_PARAM_CHANGE() {
        return AV_PKT_DATA_PARAM_CHANGE;
    }
    private static final int AV_PKT_DATA_H263_MB_INFO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_H263_MB_INFO = 3
     * }
     */
    public static int AV_PKT_DATA_H263_MB_INFO() {
        return AV_PKT_DATA_H263_MB_INFO;
    }
    private static final int AV_PKT_DATA_REPLAYGAIN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_REPLAYGAIN = 4
     * }
     */
    public static int AV_PKT_DATA_REPLAYGAIN() {
        return AV_PKT_DATA_REPLAYGAIN;
    }
    private static final int AV_PKT_DATA_DISPLAYMATRIX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_DISPLAYMATRIX = 5
     * }
     */
    public static int AV_PKT_DATA_DISPLAYMATRIX() {
        return AV_PKT_DATA_DISPLAYMATRIX;
    }
    private static final int AV_PKT_DATA_STEREO3D = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_STEREO3D = 6
     * }
     */
    public static int AV_PKT_DATA_STEREO3D() {
        return AV_PKT_DATA_STEREO3D;
    }
    private static final int AV_PKT_DATA_AUDIO_SERVICE_TYPE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7
     * }
     */
    public static int AV_PKT_DATA_AUDIO_SERVICE_TYPE() {
        return AV_PKT_DATA_AUDIO_SERVICE_TYPE;
    }
    private static final int AV_PKT_DATA_QUALITY_STATS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_QUALITY_STATS = 8
     * }
     */
    public static int AV_PKT_DATA_QUALITY_STATS() {
        return AV_PKT_DATA_QUALITY_STATS;
    }
    private static final int AV_PKT_DATA_FALLBACK_TRACK = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_FALLBACK_TRACK = 9
     * }
     */
    public static int AV_PKT_DATA_FALLBACK_TRACK() {
        return AV_PKT_DATA_FALLBACK_TRACK;
    }
    private static final int AV_PKT_DATA_CPB_PROPERTIES = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_CPB_PROPERTIES = 10
     * }
     */
    public static int AV_PKT_DATA_CPB_PROPERTIES() {
        return AV_PKT_DATA_CPB_PROPERTIES;
    }
    private static final int AV_PKT_DATA_SKIP_SAMPLES = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_SKIP_SAMPLES = 11
     * }
     */
    public static int AV_PKT_DATA_SKIP_SAMPLES() {
        return AV_PKT_DATA_SKIP_SAMPLES;
    }
    private static final int AV_PKT_DATA_JP_DUALMONO = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_JP_DUALMONO = 12
     * }
     */
    public static int AV_PKT_DATA_JP_DUALMONO() {
        return AV_PKT_DATA_JP_DUALMONO;
    }
    private static final int AV_PKT_DATA_STRINGS_METADATA = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_STRINGS_METADATA = 13
     * }
     */
    public static int AV_PKT_DATA_STRINGS_METADATA() {
        return AV_PKT_DATA_STRINGS_METADATA;
    }
    private static final int AV_PKT_DATA_SUBTITLE_POSITION = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_SUBTITLE_POSITION = 14
     * }
     */
    public static int AV_PKT_DATA_SUBTITLE_POSITION() {
        return AV_PKT_DATA_SUBTITLE_POSITION;
    }
    private static final int AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15
     * }
     */
    public static int AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL() {
        return AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL;
    }
    private static final int AV_PKT_DATA_WEBVTT_IDENTIFIER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_WEBVTT_IDENTIFIER = 16
     * }
     */
    public static int AV_PKT_DATA_WEBVTT_IDENTIFIER() {
        return AV_PKT_DATA_WEBVTT_IDENTIFIER;
    }
    private static final int AV_PKT_DATA_WEBVTT_SETTINGS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_WEBVTT_SETTINGS = 17
     * }
     */
    public static int AV_PKT_DATA_WEBVTT_SETTINGS() {
        return AV_PKT_DATA_WEBVTT_SETTINGS;
    }
    private static final int AV_PKT_DATA_METADATA_UPDATE = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_METADATA_UPDATE = 18
     * }
     */
    public static int AV_PKT_DATA_METADATA_UPDATE() {
        return AV_PKT_DATA_METADATA_UPDATE;
    }
    private static final int AV_PKT_DATA_MPEGTS_STREAM_ID = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_MPEGTS_STREAM_ID = 19
     * }
     */
    public static int AV_PKT_DATA_MPEGTS_STREAM_ID() {
        return AV_PKT_DATA_MPEGTS_STREAM_ID;
    }
    private static final int AV_PKT_DATA_MASTERING_DISPLAY_METADATA = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20
     * }
     */
    public static int AV_PKT_DATA_MASTERING_DISPLAY_METADATA() {
        return AV_PKT_DATA_MASTERING_DISPLAY_METADATA;
    }
    private static final int AV_PKT_DATA_SPHERICAL = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_SPHERICAL = 21
     * }
     */
    public static int AV_PKT_DATA_SPHERICAL() {
        return AV_PKT_DATA_SPHERICAL;
    }
    private static final int AV_PKT_DATA_CONTENT_LIGHT_LEVEL = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22
     * }
     */
    public static int AV_PKT_DATA_CONTENT_LIGHT_LEVEL() {
        return AV_PKT_DATA_CONTENT_LIGHT_LEVEL;
    }
    private static final int AV_PKT_DATA_A53_CC = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_A53_CC = 23
     * }
     */
    public static int AV_PKT_DATA_A53_CC() {
        return AV_PKT_DATA_A53_CC;
    }
    private static final int AV_PKT_DATA_ENCRYPTION_INIT_INFO = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24
     * }
     */
    public static int AV_PKT_DATA_ENCRYPTION_INIT_INFO() {
        return AV_PKT_DATA_ENCRYPTION_INIT_INFO;
    }
    private static final int AV_PKT_DATA_ENCRYPTION_INFO = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_ENCRYPTION_INFO = 25
     * }
     */
    public static int AV_PKT_DATA_ENCRYPTION_INFO() {
        return AV_PKT_DATA_ENCRYPTION_INFO;
    }
    private static final int AV_PKT_DATA_AFD = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_AFD = 26
     * }
     */
    public static int AV_PKT_DATA_AFD() {
        return AV_PKT_DATA_AFD;
    }
    private static final int AV_PKT_DATA_PRFT = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_PRFT = 27
     * }
     */
    public static int AV_PKT_DATA_PRFT() {
        return AV_PKT_DATA_PRFT;
    }
    private static final int AV_PKT_DATA_ICC_PROFILE = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_ICC_PROFILE = 28
     * }
     */
    public static int AV_PKT_DATA_ICC_PROFILE() {
        return AV_PKT_DATA_ICC_PROFILE;
    }
    private static final int AV_PKT_DATA_DOVI_CONF = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_DOVI_CONF = 29
     * }
     */
    public static int AV_PKT_DATA_DOVI_CONF() {
        return AV_PKT_DATA_DOVI_CONF;
    }
    private static final int AV_PKT_DATA_S12M_TIMECODE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_S12M_TIMECODE = 30
     * }
     */
    public static int AV_PKT_DATA_S12M_TIMECODE() {
        return AV_PKT_DATA_S12M_TIMECODE;
    }
    private static final int AV_PKT_DATA_DYNAMIC_HDR10_PLUS = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_DYNAMIC_HDR10_PLUS = 31
     * }
     */
    public static int AV_PKT_DATA_DYNAMIC_HDR10_PLUS() {
        return AV_PKT_DATA_DYNAMIC_HDR10_PLUS;
    }
    private static final int AV_PKT_DATA_NB = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVPacketSideDataType.AV_PKT_DATA_NB = 32
     * }
     */
    public static int AV_PKT_DATA_NB() {
        return AV_PKT_DATA_NB;
    }
    private static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataParamChangeFlags.AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1
     * }
     */
    public static int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT() {
        return AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT;
    }
    private static final int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataParamChangeFlags.AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2
     * }
     */
    public static int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT() {
        return AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT;
    }
    private static final int AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataParamChangeFlags.AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4
     * }
     */
    public static int AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE() {
        return AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE;
    }
    private static final int AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataParamChangeFlags.AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8
     * }
     */
    public static int AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS() {
        return AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS;
    }

    private static class av_packet_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static FunctionDescriptor av_packet_alloc$descriptor() {
        return av_packet_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static MethodHandle av_packet_alloc$handle() {
        return av_packet_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static MemorySegment av_packet_alloc$address() {
        return av_packet_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVPacket *av_packet_alloc()
     * }
     */
    public static MemorySegment av_packet_alloc() {
        var mh$ = av_packet_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_clone$descriptor() {
        return av_packet_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_clone$handle() {
        return av_packet_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_clone$address() {
        return av_packet_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVPacket *av_packet_clone(const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_clone(MemorySegment src) {
        var mh$ = av_packet_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_clone", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static FunctionDescriptor av_packet_free$descriptor() {
        return av_packet_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static MethodHandle av_packet_free$handle() {
        return av_packet_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static MemorySegment av_packet_free$address() {
        return av_packet_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_free(AVPacket **pkt)
     * }
     */
    public static void av_packet_free(MemorySegment pkt) {
        var mh$ = av_packet_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_free", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_init_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_init_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_init_packet$descriptor() {
        return av_init_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_init_packet$handle() {
        return av_init_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_init_packet$address() {
        return av_init_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_init_packet(AVPacket *pkt)
     * }
     */
    public static void av_init_packet(MemorySegment pkt) {
        var mh$ = av_init_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_init_packet", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_new_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_new_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_new_packet$descriptor() {
        return av_new_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_new_packet$handle() {
        return av_new_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_new_packet$address() {
        return av_new_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_new_packet(AVPacket *pkt, int size)
     * }
     */
    public static int av_new_packet(MemorySegment pkt, int size) {
        var mh$ = av_new_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_new_packet", pkt, size);
            }
            return (int)mh$.invokeExact(pkt, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_shrink_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_shrink_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_shrink_packet$descriptor() {
        return av_shrink_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_shrink_packet$handle() {
        return av_shrink_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_shrink_packet$address() {
        return av_shrink_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_shrink_packet(AVPacket *pkt, int size)
     * }
     */
    public static void av_shrink_packet(MemorySegment pkt, int size) {
        var mh$ = av_shrink_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_shrink_packet", pkt, size);
            }
            mh$.invokeExact(pkt, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_grow_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_grow_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static FunctionDescriptor av_grow_packet$descriptor() {
        return av_grow_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static MethodHandle av_grow_packet$handle() {
        return av_grow_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static MemorySegment av_grow_packet$address() {
        return av_grow_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_grow_packet(AVPacket *pkt, int grow_by)
     * }
     */
    public static int av_grow_packet(MemorySegment pkt, int grow_by) {
        var mh$ = av_grow_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_grow_packet", pkt, grow_by);
            }
            return (int)mh$.invokeExact(pkt, grow_by);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_from_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_from_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static FunctionDescriptor av_packet_from_data$descriptor() {
        return av_packet_from_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static MethodHandle av_packet_from_data$handle() {
        return av_packet_from_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static MemorySegment av_packet_from_data$address() {
        return av_packet_from_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size)
     * }
     */
    public static int av_packet_from_data(MemorySegment pkt, MemorySegment data, int size) {
        var mh$ = av_packet_from_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_from_data", pkt, data, size);
            }
            return (int)mh$.invokeExact(pkt, data, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_new_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_new_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_packet_new_side_data$descriptor() {
        return av_packet_new_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_packet_new_side_data$handle() {
        return av_packet_new_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_packet_new_side_data$address() {
        return av_packet_new_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_packet_new_side_data(MemorySegment pkt, int type, long size) {
        var mh$ = av_packet_new_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_new_side_data", pkt, type, size);
            }
            return (MemorySegment)mh$.invokeExact(pkt, type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_add_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_add_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static FunctionDescriptor av_packet_add_side_data$descriptor() {
        return av_packet_add_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static MethodHandle av_packet_add_side_data$handle() {
        return av_packet_add_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static MemorySegment av_packet_add_side_data$address() {
        return av_packet_add_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static int av_packet_add_side_data(MemorySegment pkt, int type, MemorySegment data, long size) {
        var mh$ = av_packet_add_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_add_side_data", pkt, type, data, size);
            }
            return (int)mh$.invokeExact(pkt, type, data, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_shrink_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_shrink_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_packet_shrink_side_data$descriptor() {
        return av_packet_shrink_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_packet_shrink_side_data$handle() {
        return av_packet_shrink_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_packet_shrink_side_data$address() {
        return av_packet_shrink_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static int av_packet_shrink_side_data(MemorySegment pkt, int type, long size) {
        var mh$ = av_packet_shrink_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_shrink_side_data", pkt, type, size);
            }
            return (int)mh$.invokeExact(pkt, type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_get_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static FunctionDescriptor av_packet_get_side_data$descriptor() {
        return av_packet_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MethodHandle av_packet_get_side_data$handle() {
        return av_packet_get_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MemorySegment av_packet_get_side_data$address() {
        return av_packet_get_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MemorySegment av_packet_get_side_data(MemorySegment pkt, int type, MemorySegment size) {
        var mh$ = av_packet_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_get_side_data", pkt, type, size);
            }
            return (MemorySegment)mh$.invokeExact(pkt, type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_side_data_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_side_data_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static FunctionDescriptor av_packet_side_data_name$descriptor() {
        return av_packet_side_data_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static MethodHandle av_packet_side_data_name$handle() {
        return av_packet_side_data_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static MemorySegment av_packet_side_data_name$address() {
        return av_packet_side_data_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     * }
     */
    public static MemorySegment av_packet_side_data_name(int type) {
        var mh$ = av_packet_side_data_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_side_data_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_pack_dictionary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_pack_dictionary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static FunctionDescriptor av_packet_pack_dictionary$descriptor() {
        return av_packet_pack_dictionary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static MethodHandle av_packet_pack_dictionary$handle() {
        return av_packet_pack_dictionary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static MemorySegment av_packet_pack_dictionary$address() {
        return av_packet_pack_dictionary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
     * }
     */
    public static MemorySegment av_packet_pack_dictionary(MemorySegment dict, MemorySegment size) {
        var mh$ = av_packet_pack_dictionary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_pack_dictionary", dict, size);
            }
            return (MemorySegment)mh$.invokeExact(dict, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_unpack_dictionary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_unpack_dictionary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static FunctionDescriptor av_packet_unpack_dictionary$descriptor() {
        return av_packet_unpack_dictionary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static MethodHandle av_packet_unpack_dictionary$handle() {
        return av_packet_unpack_dictionary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static MemorySegment av_packet_unpack_dictionary$address() {
        return av_packet_unpack_dictionary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_unpack_dictionary(const uint8_t *data, size_t size, AVDictionary **dict)
     * }
     */
    public static int av_packet_unpack_dictionary(MemorySegment data, long size, MemorySegment dict) {
        var mh$ = av_packet_unpack_dictionary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_unpack_dictionary", data, size, dict);
            }
            return (int)mh$.invokeExact(data, size, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_free_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_free_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_free_side_data$descriptor() {
        return av_packet_free_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_free_side_data$handle() {
        return av_packet_free_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_free_side_data$address() {
        return av_packet_free_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_free_side_data(AVPacket *pkt)
     * }
     */
    public static void av_packet_free_side_data(MemorySegment pkt) {
        var mh$ = av_packet_free_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_free_side_data", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_ref$descriptor() {
        return av_packet_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_ref$handle() {
        return av_packet_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_ref$address() {
        return av_packet_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_ref(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static int av_packet_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_packet_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_ref", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_unref$descriptor() {
        return av_packet_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_unref$handle() {
        return av_packet_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_unref$address() {
        return av_packet_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_unref(AVPacket *pkt)
     * }
     */
    public static void av_packet_unref(MemorySegment pkt) {
        var mh$ = av_packet_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_unref", pkt);
            }
            mh$.invokeExact(pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_move_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_move_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_move_ref$descriptor() {
        return av_packet_move_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_move_ref$handle() {
        return av_packet_move_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_move_ref$address() {
        return av_packet_move_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_move_ref(AVPacket *dst, AVPacket *src)
     * }
     */
    public static void av_packet_move_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_packet_move_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_move_ref", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_copy_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_copy_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static FunctionDescriptor av_packet_copy_props$descriptor() {
        return av_packet_copy_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MethodHandle av_packet_copy_props$handle() {
        return av_packet_copy_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static MemorySegment av_packet_copy_props$address() {
        return av_packet_copy_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     * }
     */
    public static int av_packet_copy_props(MemorySegment dst, MemorySegment src) {
        var mh$ = av_packet_copy_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_copy_props", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_make_refcounted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_make_refcounted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_make_refcounted$descriptor() {
        return av_packet_make_refcounted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_make_refcounted$handle() {
        return av_packet_make_refcounted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_make_refcounted$address() {
        return av_packet_make_refcounted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_make_refcounted(AVPacket *pkt)
     * }
     */
    public static int av_packet_make_refcounted(MemorySegment pkt) {
        var mh$ = av_packet_make_refcounted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_make_refcounted", pkt);
            }
            return (int)mh$.invokeExact(pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_make_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_packet_make_writable$descriptor() {
        return av_packet_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static MethodHandle av_packet_make_writable$handle() {
        return av_packet_make_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static MemorySegment av_packet_make_writable$address() {
        return av_packet_make_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_packet_make_writable(AVPacket *pkt)
     * }
     */
    public static int av_packet_make_writable(MemorySegment pkt) {
        var mh$ = av_packet_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_make_writable", pkt);
            }
            return (int)mh$.invokeExact(pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_packet_rescale_ts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_packet_rescale_ts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static FunctionDescriptor av_packet_rescale_ts$descriptor() {
        return av_packet_rescale_ts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static MethodHandle av_packet_rescale_ts$handle() {
        return av_packet_rescale_ts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static MemorySegment av_packet_rescale_ts$address() {
        return av_packet_rescale_ts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst)
     * }
     */
    public static void av_packet_rescale_ts(MemorySegment pkt, MemorySegment tb_src, MemorySegment tb_dst) {
        var mh$ = av_packet_rescale_ts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_packet_rescale_ts", pkt, tb_src, tb_dst);
            }
            mh$.invokeExact(pkt, tb_src, tb_dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SUBTITLE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_NONE = 0
     * }
     */
    public static int SUBTITLE_NONE() {
        return SUBTITLE_NONE;
    }
    private static final int SUBTITLE_BITMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_BITMAP = 1
     * }
     */
    public static int SUBTITLE_BITMAP() {
        return SUBTITLE_BITMAP;
    }
    private static final int SUBTITLE_TEXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_TEXT = 2
     * }
     */
    public static int SUBTITLE_TEXT() {
        return SUBTITLE_TEXT;
    }
    private static final int SUBTITLE_ASS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_ASS = 3
     * }
     */
    public static int SUBTITLE_ASS() {
        return SUBTITLE_ASS;
    }

    private static class avcodec_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static FunctionDescriptor avcodec_version$descriptor() {
        return avcodec_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static MethodHandle avcodec_version$handle() {
        return avcodec_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static MemorySegment avcodec_version$address() {
        return avcodec_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static int avcodec_version() {
        var mh$ = avcodec_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static FunctionDescriptor avcodec_configuration$descriptor() {
        return avcodec_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MethodHandle avcodec_configuration$handle() {
        return avcodec_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MemorySegment avcodec_configuration$address() {
        return avcodec_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MemorySegment avcodec_configuration() {
        var mh$ = avcodec_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static FunctionDescriptor avcodec_license$descriptor() {
        return avcodec_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MethodHandle avcodec_license$handle() {
        return avcodec_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MemorySegment avcodec_license$address() {
        return avcodec_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MemorySegment avcodec_license() {
        var mh$ = avcodec_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_alloc_context3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_alloc_context3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor avcodec_alloc_context3$descriptor() {
        return avcodec_alloc_context3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MethodHandle avcodec_alloc_context3$handle() {
        return avcodec_alloc_context3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MemorySegment avcodec_alloc_context3$address() {
        return avcodec_alloc_context3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MemorySegment avcodec_alloc_context3(MemorySegment codec) {
        var mh$ = avcodec_alloc_context3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_alloc_context3", codec);
            }
            return (MemorySegment)mh$.invokeExact(codec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_free_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_free_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static FunctionDescriptor avcodec_free_context$descriptor() {
        return avcodec_free_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static MethodHandle avcodec_free_context$handle() {
        return avcodec_free_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static MemorySegment avcodec_free_context$address() {
        return avcodec_free_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static void avcodec_free_context(MemorySegment avctx) {
        var mh$ = avcodec_free_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_free_context", avctx);
            }
            mh$.invokeExact(avctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static FunctionDescriptor avcodec_get_class$descriptor() {
        return avcodec_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MethodHandle avcodec_get_class$handle() {
        return avcodec_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MemorySegment avcodec_get_class$address() {
        return avcodec_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MemorySegment avcodec_get_class() {
        var mh$ = avcodec_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_frame_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_get_frame_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_frame_class()
     * }
     */
    public static FunctionDescriptor avcodec_get_frame_class$descriptor() {
        return avcodec_get_frame_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_frame_class()
     * }
     */
    public static MethodHandle avcodec_get_frame_class$handle() {
        return avcodec_get_frame_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_frame_class()
     * }
     */
    public static MemorySegment avcodec_get_frame_class$address() {
        return avcodec_get_frame_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avcodec_get_frame_class()
     * }
     */
    public static MemorySegment avcodec_get_frame_class() {
        var mh$ = avcodec_get_frame_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_frame_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_subtitle_rect_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_get_subtitle_rect_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static FunctionDescriptor avcodec_get_subtitle_rect_class$descriptor() {
        return avcodec_get_subtitle_rect_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MethodHandle avcodec_get_subtitle_rect_class$handle() {
        return avcodec_get_subtitle_rect_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MemorySegment avcodec_get_subtitle_rect_class$address() {
        return avcodec_get_subtitle_rect_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MemorySegment avcodec_get_subtitle_rect_class() {
        var mh$ = avcodec_get_subtitle_rect_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_subtitle_rect_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_from_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_parameters_from_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_from_context$descriptor() {
        return avcodec_parameters_from_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static MethodHandle avcodec_parameters_from_context$handle() {
        return avcodec_parameters_from_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static MemorySegment avcodec_parameters_from_context$address() {
        return avcodec_parameters_from_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static int avcodec_parameters_from_context(MemorySegment par, MemorySegment codec) {
        var mh$ = avcodec_parameters_from_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_from_context", par, codec);
            }
            return (int)mh$.invokeExact(par, codec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_to_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_parameters_to_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const AVCodecParameters *par)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_to_context$descriptor() {
        return avcodec_parameters_to_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const AVCodecParameters *par)
     * }
     */
    public static MethodHandle avcodec_parameters_to_context$handle() {
        return avcodec_parameters_to_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const AVCodecParameters *par)
     * }
     */
    public static MemorySegment avcodec_parameters_to_context$address() {
        return avcodec_parameters_to_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const AVCodecParameters *par)
     * }
     */
    public static int avcodec_parameters_to_context(MemorySegment codec, MemorySegment par) {
        var mh$ = avcodec_parameters_to_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_to_context", codec, par);
            }
            return (int)mh$.invokeExact(codec, par);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_open2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_open2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avcodec_open2$descriptor() {
        return avcodec_open2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static MethodHandle avcodec_open2$handle() {
        return avcodec_open2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static MemorySegment avcodec_open2$address() {
        return avcodec_open2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static int avcodec_open2(MemorySegment avctx, MemorySegment codec, MemorySegment options) {
        var mh$ = avcodec_open2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_open2", avctx, codec, options);
            }
            return (int)mh$.invokeExact(avctx, codec, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_close(AVCodecContext *avctx)
     * }
     */
    public static FunctionDescriptor avcodec_close$descriptor() {
        return avcodec_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_close(AVCodecContext *avctx)
     * }
     */
    public static MethodHandle avcodec_close$handle() {
        return avcodec_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_close(AVCodecContext *avctx)
     * }
     */
    public static MemorySegment avcodec_close$address() {
        return avcodec_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_close(AVCodecContext *avctx)
     * }
     */
    public static int avcodec_close(MemorySegment avctx) {
        var mh$ = avcodec_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_close", avctx);
            }
            return (int)mh$.invokeExact(avctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avsubtitle_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avsubtitle_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static FunctionDescriptor avsubtitle_free$descriptor() {
        return avsubtitle_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static MethodHandle avsubtitle_free$handle() {
        return avsubtitle_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static MemorySegment avsubtitle_free$address() {
        return avsubtitle_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static void avsubtitle_free(MemorySegment sub) {
        var mh$ = avsubtitle_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avsubtitle_free", sub);
            }
            mh$.invokeExact(sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_buffer2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_default_get_buffer2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_buffer2$descriptor() {
        return avcodec_default_get_buffer2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle avcodec_default_get_buffer2$handle() {
        return avcodec_default_get_buffer2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment avcodec_default_get_buffer2$address() {
        return avcodec_default_get_buffer2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static int avcodec_default_get_buffer2(MemorySegment s, MemorySegment frame, int flags) {
        var mh$ = avcodec_default_get_buffer2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_buffer2", s, frame, flags);
            }
            return (int)mh$.invokeExact(s, frame, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_encode_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_default_get_encode_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_encode_buffer$descriptor() {
        return avcodec_default_get_encode_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static MethodHandle avcodec_default_get_encode_buffer$handle() {
        return avcodec_default_get_encode_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static MemorySegment avcodec_default_get_encode_buffer$address() {
        return avcodec_default_get_encode_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static int avcodec_default_get_encode_buffer(MemorySegment s, MemorySegment pkt, int flags) {
        var mh$ = avcodec_default_get_encode_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_encode_buffer", s, pkt, flags);
            }
            return (int)mh$.invokeExact(s, pkt, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_align_dimensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_align_dimensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static FunctionDescriptor avcodec_align_dimensions$descriptor() {
        return avcodec_align_dimensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static MethodHandle avcodec_align_dimensions$handle() {
        return avcodec_align_dimensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static MemorySegment avcodec_align_dimensions$address() {
        return avcodec_align_dimensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static void avcodec_align_dimensions(MemorySegment s, MemorySegment width, MemorySegment height) {
        var mh$ = avcodec_align_dimensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_align_dimensions", s, width, height);
            }
            mh$.invokeExact(s, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_align_dimensions2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_align_dimensions2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static FunctionDescriptor avcodec_align_dimensions2$descriptor() {
        return avcodec_align_dimensions2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static MethodHandle avcodec_align_dimensions2$handle() {
        return avcodec_align_dimensions2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static MemorySegment avcodec_align_dimensions2$address() {
        return avcodec_align_dimensions2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static void avcodec_align_dimensions2(MemorySegment s, MemorySegment width, MemorySegment height, MemorySegment linesize_align) {
        var mh$ = avcodec_align_dimensions2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_align_dimensions2", s, width, height, linesize_align);
            }
            mh$.invokeExact(s, width, height, linesize_align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_enum_to_chroma_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_enum_to_chroma_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static FunctionDescriptor avcodec_enum_to_chroma_pos$descriptor() {
        return avcodec_enum_to_chroma_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static MethodHandle avcodec_enum_to_chroma_pos$handle() {
        return avcodec_enum_to_chroma_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static MemorySegment avcodec_enum_to_chroma_pos$address() {
        return avcodec_enum_to_chroma_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static int avcodec_enum_to_chroma_pos(MemorySegment xpos, MemorySegment ypos, int pos) {
        var mh$ = avcodec_enum_to_chroma_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_enum_to_chroma_pos", xpos, ypos, pos);
            }
            return (int)mh$.invokeExact(xpos, ypos, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_chroma_pos_to_enum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_chroma_pos_to_enum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static FunctionDescriptor avcodec_chroma_pos_to_enum$descriptor() {
        return avcodec_chroma_pos_to_enum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static MethodHandle avcodec_chroma_pos_to_enum$handle() {
        return avcodec_chroma_pos_to_enum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static MemorySegment avcodec_chroma_pos_to_enum$address() {
        return avcodec_chroma_pos_to_enum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static int avcodec_chroma_pos_to_enum(int xpos, int ypos) {
        var mh$ = avcodec_chroma_pos_to_enum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_chroma_pos_to_enum", xpos, ypos);
            }
            return (int)mh$.invokeExact(xpos, ypos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_decode_subtitle2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_decode_subtitle2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_decode_subtitle2$descriptor() {
        return avcodec_decode_subtitle2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_decode_subtitle2$handle() {
        return avcodec_decode_subtitle2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_decode_subtitle2$address() {
        return avcodec_decode_subtitle2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt)
     * }
     */
    public static int avcodec_decode_subtitle2(MemorySegment avctx, MemorySegment sub, MemorySegment got_sub_ptr, MemorySegment avpkt) {
        var mh$ = avcodec_decode_subtitle2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_decode_subtitle2", avctx, sub, got_sub_ptr, avpkt);
            }
            return (int)mh$.invokeExact(avctx, sub, got_sub_ptr, avpkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_send_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_send_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_send_packet$descriptor() {
        return avcodec_send_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_send_packet$handle() {
        return avcodec_send_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_send_packet$address() {
        return avcodec_send_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static int avcodec_send_packet(MemorySegment avctx, MemorySegment avpkt) {
        var mh$ = avcodec_send_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_send_packet", avctx, avpkt);
            }
            return (int)mh$.invokeExact(avctx, avpkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_receive_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_receive_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor avcodec_receive_frame$descriptor() {
        return avcodec_receive_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static MethodHandle avcodec_receive_frame$handle() {
        return avcodec_receive_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static MemorySegment avcodec_receive_frame$address() {
        return avcodec_receive_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static int avcodec_receive_frame(MemorySegment avctx, MemorySegment frame) {
        var mh$ = avcodec_receive_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_receive_frame", avctx, frame);
            }
            return (int)mh$.invokeExact(avctx, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_send_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_send_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static FunctionDescriptor avcodec_send_frame$descriptor() {
        return avcodec_send_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static MethodHandle avcodec_send_frame$handle() {
        return avcodec_send_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static MemorySegment avcodec_send_frame$address() {
        return avcodec_send_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static int avcodec_send_frame(MemorySegment avctx, MemorySegment frame) {
        var mh$ = avcodec_send_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_send_frame", avctx, frame);
            }
            return (int)mh$.invokeExact(avctx, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_receive_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_receive_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_receive_packet$descriptor() {
        return avcodec_receive_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_receive_packet$handle() {
        return avcodec_receive_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_receive_packet$address() {
        return avcodec_receive_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static int avcodec_receive_packet(MemorySegment avctx, MemorySegment avpkt) {
        var mh$ = avcodec_receive_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_receive_packet", avctx, avpkt);
            }
            return (int)mh$.invokeExact(avctx, avpkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_hw_frames_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_get_hw_frames_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static FunctionDescriptor avcodec_get_hw_frames_parameters$descriptor() {
        return avcodec_get_hw_frames_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static MethodHandle avcodec_get_hw_frames_parameters$handle() {
        return avcodec_get_hw_frames_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static MemorySegment avcodec_get_hw_frames_parameters$address() {
        return avcodec_get_hw_frames_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static int avcodec_get_hw_frames_parameters(MemorySegment avctx, MemorySegment device_ref, int hw_pix_fmt, MemorySegment out_frames_ref) {
        var mh$ = avcodec_get_hw_frames_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_hw_frames_parameters", avctx, device_ref, hw_pix_fmt, out_frames_ref);
            }
            return (int)mh$.invokeExact(avctx, device_ref, hw_pix_fmt, out_frames_ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PICTURE_STRUCTURE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_UNKNOWN = 0
     * }
     */
    public static int AV_PICTURE_STRUCTURE_UNKNOWN() {
        return AV_PICTURE_STRUCTURE_UNKNOWN;
    }
    private static final int AV_PICTURE_STRUCTURE_TOP_FIELD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_TOP_FIELD = 1
     * }
     */
    public static int AV_PICTURE_STRUCTURE_TOP_FIELD() {
        return AV_PICTURE_STRUCTURE_TOP_FIELD;
    }
    private static final int AV_PICTURE_STRUCTURE_BOTTOM_FIELD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2
     * }
     */
    public static int AV_PICTURE_STRUCTURE_BOTTOM_FIELD() {
        return AV_PICTURE_STRUCTURE_BOTTOM_FIELD;
    }
    private static final int AV_PICTURE_STRUCTURE_FRAME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_FRAME = 3
     * }
     */
    public static int AV_PICTURE_STRUCTURE_FRAME() {
        return AV_PICTURE_STRUCTURE_FRAME;
    }

    private static class av_parser_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_parser_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_parser_iterate$descriptor() {
        return av_parser_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_parser_iterate$handle() {
        return av_parser_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_parser_iterate$address() {
        return av_parser_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_parser_iterate(MemorySegment opaque) {
        var mh$ = av_parser_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_parser_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static FunctionDescriptor av_parser_init$descriptor() {
        return av_parser_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MethodHandle av_parser_init$handle() {
        return av_parser_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MemorySegment av_parser_init$address() {
        return av_parser_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MemorySegment av_parser_init(int codec_id) {
        var mh$ = av_parser_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_init", codec_id);
            }
            return (MemorySegment)mh$.invokeExact(codec_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_parse2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_parser_parse2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static FunctionDescriptor av_parser_parse2$descriptor() {
        return av_parser_parse2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static MethodHandle av_parser_parse2$handle() {
        return av_parser_parse2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static MemorySegment av_parser_parse2$address() {
        return av_parser_parse2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static int av_parser_parse2(MemorySegment s, MemorySegment avctx, MemorySegment poutbuf, MemorySegment poutbuf_size, MemorySegment buf, int buf_size, long pts, long dts, long pos) {
        var mh$ = av_parser_parse2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_parse2", s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
            }
            return (int)mh$.invokeExact(s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_parser_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static FunctionDescriptor av_parser_close$descriptor() {
        return av_parser_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static MethodHandle av_parser_close$handle() {
        return av_parser_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static MemorySegment av_parser_close$address() {
        return av_parser_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static void av_parser_close(MemorySegment s) {
        var mh$ = av_parser_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_close", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_encode_subtitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_encode_subtitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static FunctionDescriptor avcodec_encode_subtitle$descriptor() {
        return avcodec_encode_subtitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static MethodHandle avcodec_encode_subtitle$handle() {
        return avcodec_encode_subtitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static MemorySegment avcodec_encode_subtitle$address() {
        return avcodec_encode_subtitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static int avcodec_encode_subtitle(MemorySegment avctx, MemorySegment buf, int buf_size, MemorySegment sub) {
        var mh$ = avcodec_encode_subtitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_encode_subtitle", avctx, buf, buf_size, sub);
            }
            return (int)mh$.invokeExact(avctx, buf, buf_size, sub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_pix_fmt_to_codec_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_pix_fmt_to_codec_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor avcodec_pix_fmt_to_codec_tag$descriptor() {
        return avcodec_pix_fmt_to_codec_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle avcodec_pix_fmt_to_codec_tag$handle() {
        return avcodec_pix_fmt_to_codec_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment avcodec_pix_fmt_to_codec_tag$address() {
        return avcodec_pix_fmt_to_codec_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int avcodec_pix_fmt_to_codec_tag(int pix_fmt) {
        var mh$ = avcodec_pix_fmt_to_codec_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_pix_fmt_to_codec_tag", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_best_pix_fmt_of_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_find_best_pix_fmt_of_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static FunctionDescriptor avcodec_find_best_pix_fmt_of_list$descriptor() {
        return avcodec_find_best_pix_fmt_of_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MethodHandle avcodec_find_best_pix_fmt_of_list$handle() {
        return avcodec_find_best_pix_fmt_of_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MemorySegment avcodec_find_best_pix_fmt_of_list$address() {
        return avcodec_find_best_pix_fmt_of_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static int avcodec_find_best_pix_fmt_of_list(MemorySegment pix_fmt_list, int src_pix_fmt, int has_alpha, MemorySegment loss_ptr) {
        var mh$ = avcodec_find_best_pix_fmt_of_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_best_pix_fmt_of_list", pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr);
            }
            return (int)mh$.invokeExact(pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_default_get_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_format$descriptor() {
        return avcodec_default_get_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static MethodHandle avcodec_default_get_format$handle() {
        return avcodec_default_get_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static MemorySegment avcodec_default_get_format$address() {
        return avcodec_default_get_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static int avcodec_default_get_format(MemorySegment s, MemorySegment fmt) {
        var mh$ = avcodec_default_get_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_format", s, fmt);
            }
            return (int)mh$.invokeExact(s, fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static FunctionDescriptor avcodec_string$descriptor() {
        return avcodec_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static MethodHandle avcodec_string$handle() {
        return avcodec_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static MemorySegment avcodec_string$address() {
        return avcodec_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static void avcodec_string(MemorySegment buf, int buf_size, MemorySegment enc, int encode) {
        var mh$ = avcodec_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_string", buf, buf_size, enc, encode);
            }
            mh$.invokeExact(buf, buf_size, enc, encode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_execute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_default_execute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static FunctionDescriptor avcodec_default_execute$descriptor() {
        return avcodec_default_execute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static MethodHandle avcodec_default_execute$handle() {
        return avcodec_default_execute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static MemorySegment avcodec_default_execute$address() {
        return avcodec_default_execute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static int avcodec_default_execute(MemorySegment c, MemorySegment func, MemorySegment arg, MemorySegment ret, int count, int size) {
        var mh$ = avcodec_default_execute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_execute", c, func, arg, ret, count, size);
            }
            return (int)mh$.invokeExact(c, func, arg, ret, count, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_execute2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_default_execute2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static FunctionDescriptor avcodec_default_execute2$descriptor() {
        return avcodec_default_execute2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static MethodHandle avcodec_default_execute2$handle() {
        return avcodec_default_execute2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static MemorySegment avcodec_default_execute2$address() {
        return avcodec_default_execute2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static int avcodec_default_execute2(MemorySegment c, MemorySegment func, MemorySegment arg, MemorySegment ret, int count) {
        var mh$ = avcodec_default_execute2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_execute2", c, func, arg, ret, count);
            }
            return (int)mh$.invokeExact(c, func, arg, ret, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_fill_audio_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_fill_audio_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static FunctionDescriptor avcodec_fill_audio_frame$descriptor() {
        return avcodec_fill_audio_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static MethodHandle avcodec_fill_audio_frame$handle() {
        return avcodec_fill_audio_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static MemorySegment avcodec_fill_audio_frame$address() {
        return avcodec_fill_audio_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static int avcodec_fill_audio_frame(MemorySegment frame, int nb_channels, int sample_fmt, MemorySegment buf, int buf_size, int align) {
        var mh$ = avcodec_fill_audio_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_fill_audio_frame", frame, nb_channels, sample_fmt, buf, buf_size, align);
            }
            return (int)mh$.invokeExact(frame, nb_channels, sample_fmt, buf, buf_size, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_flush_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_flush_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static FunctionDescriptor avcodec_flush_buffers$descriptor() {
        return avcodec_flush_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static MethodHandle avcodec_flush_buffers$handle() {
        return avcodec_flush_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static MemorySegment avcodec_flush_buffers$address() {
        return avcodec_flush_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static void avcodec_flush_buffers(MemorySegment avctx) {
        var mh$ = avcodec_flush_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_flush_buffers", avctx);
            }
            mh$.invokeExact(avctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_audio_frame_duration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_audio_frame_duration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static FunctionDescriptor av_get_audio_frame_duration$descriptor() {
        return av_get_audio_frame_duration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static MethodHandle av_get_audio_frame_duration$handle() {
        return av_get_audio_frame_duration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static MemorySegment av_get_audio_frame_duration$address() {
        return av_get_audio_frame_duration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static int av_get_audio_frame_duration(MemorySegment avctx, int frame_bytes) {
        var mh$ = av_get_audio_frame_duration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_audio_frame_duration", avctx, frame_bytes);
            }
            return (int)mh$.invokeExact(avctx, frame_bytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_padded_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_fast_padded_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_padded_malloc$descriptor() {
        return av_fast_padded_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_padded_malloc$handle() {
        return av_fast_padded_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_padded_malloc$address() {
        return av_fast_padded_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_padded_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_padded_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_padded_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_padded_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_fast_padded_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_padded_mallocz$descriptor() {
        return av_fast_padded_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_padded_mallocz$handle() {
        return av_fast_padded_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_padded_mallocz$address() {
        return av_fast_padded_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_padded_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_padded_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_padded_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_is_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avcodec_is_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static FunctionDescriptor avcodec_is_open$descriptor() {
        return avcodec_is_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static MethodHandle avcodec_is_open$handle() {
        return avcodec_is_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static MemorySegment avcodec_is_open$address() {
        return avcodec_is_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static int avcodec_is_open(MemorySegment s) {
        var mh$ = avcodec_is_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_is_open", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t time(time_t *__timer)
     * }
     */
    public static long time(MemorySegment __timer) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", __timer);
            }
            return (long)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double difftime(time_t __time1, time_t __time0)
     * }
     */
    public static double difftime(long __time1, long __time0) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", __time1, __time0);
            }
            return (double)mh$.invokeExact(__time1, __time0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t mktime(struct tm *__tp)
     * }
     */
    public static long mktime(MemorySegment __tp) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp)
     * }
     */
    public static long strftime(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", __s, __maxsize, __format, __tp);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strftime_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strftime_l$descriptor() {
        return strftime_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MethodHandle strftime_l$handle() {
        return strftime_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static MemorySegment strftime_l$address() {
        return strftime_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strftime_l(char *restrict __s, size_t __maxsize, const char *restrict __format, const struct tm *restrict __tp, locale_t __loc)
     * }
     */
    public static long strftime_l(MemorySegment __s, long __maxsize, MemorySegment __format, MemorySegment __tp, MemorySegment __loc) {
        var mh$ = strftime_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime_l", __s, __maxsize, __format, __tp, __loc);
            }
            return (long)mh$.invokeExact(__s, __maxsize, __format, __tp, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime(const time_t *__timer)
     * }
     */
    public static MemorySegment gmtime(MemorySegment __timer) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime(const time_t *__timer)
     * }
     */
    public static MemorySegment localtime(MemorySegment __timer) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *gmtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct tm *localtime_r(const time_t *restrict __timer, struct tm *restrict __tp)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment __timer, MemorySegment __tp) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", __timer, __tp);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime(const struct tm *__tp)
     * }
     */
    public static MemorySegment asctime(MemorySegment __tp) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", __tp);
            }
            return (MemorySegment)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime(const time_t *__timer)
     * }
     */
    public static MemorySegment ctime(MemorySegment __timer) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", __timer);
            }
            return (MemorySegment)mh$.invokeExact(__timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *asctime_r(const struct tm *restrict __tp, char *restrict __buf)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment __tp, MemorySegment __buf) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", __tp, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__tp, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctime_r(const time_t *restrict __timer, char *restrict __buf)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment __timer, MemorySegment __buf) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", __timer, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__timer, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, FFmpeg.C_POINTER);
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("__tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static SequenceLayout __tzname$layout() {
        return __tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static long[] __tzname$dimensions() {
        return __tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname() {
        return __tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, __tzname$constants.SEGMENT, 0L, __tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static MemorySegment __tzname(long index0) {
        return (MemorySegment)__tzname$constants.HANDLE.get(__tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *__tzname[2]
     * }
     */
    public static void __tzname(long index0, MemorySegment varValue) {
        __tzname$constants.HANDLE.set(__tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class __daylight$constants {
        public static final OfInt LAYOUT = FFmpeg.C_INT;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("__daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static OfInt __daylight$layout() {
        return __daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static MemorySegment __daylight$segment() {
        return __daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static int __daylight() {
        return __daylight$constants.SEGMENT.get(__daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __daylight
     * }
     */
    public static void __daylight(int varValue) {
        __daylight$constants.SEGMENT.set(__daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class __timezone$constants {
        public static final OfLong LAYOUT = FFmpeg.C_LONG;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("__timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static OfLong __timezone$layout() {
        return __timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static MemorySegment __timezone$segment() {
        return __timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static long __timezone() {
        return __timezone$constants.SEGMENT.get(__timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long __timezone
     * }
     */
    public static void __timezone(long varValue) {
        __timezone$constants.SEGMENT.set(__timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, FFmpeg.C_POINTER);
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle(sequenceElement());

        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static MemorySegment tzname(long index0) {
        return (MemorySegment)tzname$constants.HANDLE.get(tzname$constants.SEGMENT, 0L, index0);
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[2]
     * }
     */
    public static void tzname(long index0, MemorySegment varValue) {
        tzname$constants.HANDLE.set(tzname$constants.SEGMENT, 0L, index0, varValue);
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = FFmpeg.C_INT;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = FFmpeg.C_LONG;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timegm(struct tm *__tp)
     * }
     */
    public static long timegm(MemorySegment __tp) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern time_t timelocal(struct tm *__tp)
     * }
     */
    public static long timelocal(MemorySegment __tp) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", __tp);
            }
            return (long)mh$.invokeExact(__tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dysize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("dysize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static FunctionDescriptor dysize$descriptor() {
        return dysize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MethodHandle dysize$handle() {
        return dysize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static MemorySegment dysize$address() {
        return dysize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int dysize(int __year)
     * }
     */
    public static int dysize(int __year) {
        var mh$ = dysize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dysize", __year);
            }
            return (int)mh$.invokeExact(__year);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining)
     * }
     */
    public static int nanosleep(MemorySegment __requested_time, MemorySegment __remaining) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __requested_time, __remaining);
            }
            return (int)mh$.invokeExact(__requested_time, __remaining);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clock_nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static FunctionDescriptor clock_nanosleep$descriptor() {
        return clock_nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MethodHandle clock_nanosleep$handle() {
        return clock_nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static MemorySegment clock_nanosleep$address() {
        return clock_nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem)
     * }
     */
    public static int clock_nanosleep(int __clock_id, int __flags, MemorySegment __req, MemorySegment __rem) {
        var mh$ = clock_nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_nanosleep", __clock_id, __flags, __req, __rem);
            }
            return (int)mh$.invokeExact(__clock_id, __flags, __req, __rem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_getcpuclockid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clock_getcpuclockid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static FunctionDescriptor clock_getcpuclockid$descriptor() {
        return clock_getcpuclockid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MethodHandle clock_getcpuclockid$handle() {
        return clock_getcpuclockid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static MemorySegment clock_getcpuclockid$address() {
        return clock_getcpuclockid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id)
     * }
     */
    public static int clock_getcpuclockid(int __pid, MemorySegment __clock_id) {
        var mh$ = clock_getcpuclockid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getcpuclockid", __pid, __clock_id);
            }
            return (int)mh$.invokeExact(__pid, __clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static FunctionDescriptor timer_create$descriptor() {
        return timer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MethodHandle timer_create$handle() {
        return timer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static MemorySegment timer_create$address() {
        return timer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_create(clockid_t __clock_id, struct sigevent *restrict __evp, timer_t *restrict __timerid)
     * }
     */
    public static int timer_create(int __clock_id, MemorySegment __evp, MemorySegment __timerid) {
        var mh$ = timer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_create", __clock_id, __evp, __timerid);
            }
            return (int)mh$.invokeExact(__clock_id, __evp, __timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timer_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_delete$descriptor() {
        return timer_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_delete$handle() {
        return timer_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_delete$address() {
        return timer_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_delete(timer_t __timerid)
     * }
     */
    public static int timer_delete(MemorySegment __timerid) {
        var mh$ = timer_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_delete", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timer_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static FunctionDescriptor timer_settime$descriptor() {
        return timer_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MethodHandle timer_settime$handle() {
        return timer_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static MemorySegment timer_settime$address() {
        return timer_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *restrict __value, struct itimerspec *restrict __ovalue)
     * }
     */
    public static int timer_settime(MemorySegment __timerid, int __flags, MemorySegment __value, MemorySegment __ovalue) {
        var mh$ = timer_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_settime", __timerid, __flags, __value, __ovalue);
            }
            return (int)mh$.invokeExact(__timerid, __flags, __value, __ovalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timer_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static FunctionDescriptor timer_gettime$descriptor() {
        return timer_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MethodHandle timer_gettime$handle() {
        return timer_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static MemorySegment timer_gettime$address() {
        return timer_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_gettime(timer_t __timerid, struct itimerspec *__value)
     * }
     */
    public static int timer_gettime(MemorySegment __timerid, MemorySegment __value) {
        var mh$ = timer_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_gettime", __timerid, __value);
            }
            return (int)mh$.invokeExact(__timerid, __value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timer_getoverrun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timer_getoverrun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static FunctionDescriptor timer_getoverrun$descriptor() {
        return timer_getoverrun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MethodHandle timer_getoverrun$handle() {
        return timer_getoverrun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static MemorySegment timer_getoverrun$address() {
        return timer_getoverrun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timer_getoverrun(timer_t __timerid)
     * }
     */
    public static int timer_getoverrun(MemorySegment __timerid) {
        var mh$ = timer_getoverrun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timer_getoverrun", __timerid);
            }
            return (int)mh$.invokeExact(__timerid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int timespec_get(struct timespec *__ts, int __base)
     * }
     */
    public static int timespec_get(MemorySegment __ts, int __base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", __ts, __base);
            }
            return (int)mh$.invokeExact(__ts, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVIO_ENTRY_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_UNKNOWN = 0
     * }
     */
    public static int AVIO_ENTRY_UNKNOWN() {
        return AVIO_ENTRY_UNKNOWN;
    }
    private static final int AVIO_ENTRY_BLOCK_DEVICE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_BLOCK_DEVICE = 1
     * }
     */
    public static int AVIO_ENTRY_BLOCK_DEVICE() {
        return AVIO_ENTRY_BLOCK_DEVICE;
    }
    private static final int AVIO_ENTRY_CHARACTER_DEVICE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_CHARACTER_DEVICE = 2
     * }
     */
    public static int AVIO_ENTRY_CHARACTER_DEVICE() {
        return AVIO_ENTRY_CHARACTER_DEVICE;
    }
    private static final int AVIO_ENTRY_DIRECTORY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_DIRECTORY = 3
     * }
     */
    public static int AVIO_ENTRY_DIRECTORY() {
        return AVIO_ENTRY_DIRECTORY;
    }
    private static final int AVIO_ENTRY_NAMED_PIPE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_NAMED_PIPE = 4
     * }
     */
    public static int AVIO_ENTRY_NAMED_PIPE() {
        return AVIO_ENTRY_NAMED_PIPE;
    }
    private static final int AVIO_ENTRY_SYMBOLIC_LINK = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_SYMBOLIC_LINK = 5
     * }
     */
    public static int AVIO_ENTRY_SYMBOLIC_LINK() {
        return AVIO_ENTRY_SYMBOLIC_LINK;
    }
    private static final int AVIO_ENTRY_SOCKET = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_SOCKET = 6
     * }
     */
    public static int AVIO_ENTRY_SOCKET() {
        return AVIO_ENTRY_SOCKET;
    }
    private static final int AVIO_ENTRY_FILE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_FILE = 7
     * }
     */
    public static int AVIO_ENTRY_FILE() {
        return AVIO_ENTRY_FILE;
    }
    private static final int AVIO_ENTRY_SERVER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_SERVER = 8
     * }
     */
    public static int AVIO_ENTRY_SERVER() {
        return AVIO_ENTRY_SERVER;
    }
    private static final int AVIO_ENTRY_SHARE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_SHARE = 9
     * }
     */
    public static int AVIO_ENTRY_SHARE() {
        return AVIO_ENTRY_SHARE;
    }
    private static final int AVIO_ENTRY_WORKGROUP = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVIODirEntryType.AVIO_ENTRY_WORKGROUP = 10
     * }
     */
    public static int AVIO_ENTRY_WORKGROUP() {
        return AVIO_ENTRY_WORKGROUP;
    }
    private static final int AVIO_DATA_MARKER_HEADER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVIODataMarkerType.AVIO_DATA_MARKER_HEADER = 0
     * }
     */
    public static int AVIO_DATA_MARKER_HEADER() {
        return AVIO_DATA_MARKER_HEADER;
    }
    private static final int AVIO_DATA_MARKER_SYNC_POINT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVIODataMarkerType.AVIO_DATA_MARKER_SYNC_POINT = 1
     * }
     */
    public static int AVIO_DATA_MARKER_SYNC_POINT() {
        return AVIO_DATA_MARKER_SYNC_POINT;
    }
    private static final int AVIO_DATA_MARKER_BOUNDARY_POINT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVIODataMarkerType.AVIO_DATA_MARKER_BOUNDARY_POINT = 2
     * }
     */
    public static int AVIO_DATA_MARKER_BOUNDARY_POINT() {
        return AVIO_DATA_MARKER_BOUNDARY_POINT;
    }
    private static final int AVIO_DATA_MARKER_UNKNOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVIODataMarkerType.AVIO_DATA_MARKER_UNKNOWN = 3
     * }
     */
    public static int AVIO_DATA_MARKER_UNKNOWN() {
        return AVIO_DATA_MARKER_UNKNOWN;
    }
    private static final int AVIO_DATA_MARKER_TRAILER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVIODataMarkerType.AVIO_DATA_MARKER_TRAILER = 4
     * }
     */
    public static int AVIO_DATA_MARKER_TRAILER() {
        return AVIO_DATA_MARKER_TRAILER;
    }
    private static final int AVIO_DATA_MARKER_FLUSH_POINT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVIODataMarkerType.AVIO_DATA_MARKER_FLUSH_POINT = 5
     * }
     */
    public static int AVIO_DATA_MARKER_FLUSH_POINT() {
        return AVIO_DATA_MARKER_FLUSH_POINT;
    }

    private static class avio_find_protocol_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_find_protocol_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static FunctionDescriptor avio_find_protocol_name$descriptor() {
        return avio_find_protocol_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static MethodHandle avio_find_protocol_name$handle() {
        return avio_find_protocol_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static MemorySegment avio_find_protocol_name$address() {
        return avio_find_protocol_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static MemorySegment avio_find_protocol_name(MemorySegment url) {
        var mh$ = avio_find_protocol_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_find_protocol_name", url);
            }
            return (MemorySegment)mh$.invokeExact(url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static FunctionDescriptor avio_check$descriptor() {
        return avio_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static MethodHandle avio_check$handle() {
        return avio_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static MemorySegment avio_check$address() {
        return avio_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static int avio_check(MemorySegment url, int flags) {
        var mh$ = avio_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_check", url, flags);
            }
            return (int)mh$.invokeExact(url, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_open_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avio_open_dir$descriptor() {
        return avio_open_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static MethodHandle avio_open_dir$handle() {
        return avio_open_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static MemorySegment avio_open_dir$address() {
        return avio_open_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static int avio_open_dir(MemorySegment s, MemorySegment url, MemorySegment options) {
        var mh$ = avio_open_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open_dir", s, url, options);
            }
            return (int)mh$.invokeExact(s, url, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_read_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static FunctionDescriptor avio_read_dir$descriptor() {
        return avio_read_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static MethodHandle avio_read_dir$handle() {
        return avio_read_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static MemorySegment avio_read_dir$address() {
        return avio_read_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static int avio_read_dir(MemorySegment s, MemorySegment next) {
        var mh$ = avio_read_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read_dir", s, next);
            }
            return (int)mh$.invokeExact(s, next);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_close_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_close_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static FunctionDescriptor avio_close_dir$descriptor() {
        return avio_close_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static MethodHandle avio_close_dir$handle() {
        return avio_close_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static MemorySegment avio_close_dir$address() {
        return avio_close_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static int avio_close_dir(MemorySegment s) {
        var mh$ = avio_close_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_close_dir", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_free_directory_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_free_directory_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static FunctionDescriptor avio_free_directory_entry$descriptor() {
        return avio_free_directory_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static MethodHandle avio_free_directory_entry$handle() {
        return avio_free_directory_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static MemorySegment avio_free_directory_entry$address() {
        return avio_free_directory_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static void avio_free_directory_entry(MemorySegment entry) {
        var mh$ = avio_free_directory_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_free_directory_entry", entry);
            }
            mh$.invokeExact(entry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static FunctionDescriptor avio_alloc_context$descriptor() {
        return avio_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static MethodHandle avio_alloc_context$handle() {
        return avio_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static MemorySegment avio_alloc_context$address() {
        return avio_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static MemorySegment avio_alloc_context(MemorySegment buffer, int buffer_size, int write_flag, MemorySegment opaque, MemorySegment read_packet, MemorySegment write_packet, MemorySegment seek) {
        var mh$ = avio_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_alloc_context", buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek);
            }
            return (MemorySegment)mh$.invokeExact(buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_context_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_context_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static FunctionDescriptor avio_context_free$descriptor() {
        return avio_context_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static MethodHandle avio_context_free$handle() {
        return avio_context_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static MemorySegment avio_context_free$address() {
        return avio_context_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static void avio_context_free(MemorySegment s) {
        var mh$ = avio_context_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_context_free", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_w8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_w8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static FunctionDescriptor avio_w8$descriptor() {
        return avio_w8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static MethodHandle avio_w8$handle() {
        return avio_w8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static MemorySegment avio_w8$address() {
        return avio_w8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static void avio_w8(MemorySegment s, int b) {
        var mh$ = avio_w8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_w8", s, b);
            }
            mh$.invokeExact(s, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static FunctionDescriptor avio_write$descriptor() {
        return avio_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static MethodHandle avio_write$handle() {
        return avio_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static MemorySegment avio_write$address() {
        return avio_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static void avio_write(MemorySegment s, MemorySegment buf, int size) {
        var mh$ = avio_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_write", s, buf, size);
            }
            mh$.invokeExact(s, buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static FunctionDescriptor avio_wl64$descriptor() {
        return avio_wl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MethodHandle avio_wl64$handle() {
        return avio_wl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MemorySegment avio_wl64$address() {
        return avio_wl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static void avio_wl64(MemorySegment s, long val) {
        var mh$ = avio_wl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl64", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wb64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static FunctionDescriptor avio_wb64$descriptor() {
        return avio_wb64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MethodHandle avio_wb64$handle() {
        return avio_wb64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MemorySegment avio_wb64$address() {
        return avio_wb64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static void avio_wb64(MemorySegment s, long val) {
        var mh$ = avio_wb64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb64", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wl32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wl32$descriptor() {
        return avio_wl32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wl32$handle() {
        return avio_wl32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wl32$address() {
        return avio_wl32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wl32(MemorySegment s, int val) {
        var mh$ = avio_wl32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl32", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wb32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wb32$descriptor() {
        return avio_wb32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wb32$handle() {
        return avio_wb32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wb32$address() {
        return avio_wb32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wb32(MemorySegment s, int val) {
        var mh$ = avio_wb32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb32", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wl24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wl24$descriptor() {
        return avio_wl24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wl24$handle() {
        return avio_wl24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wl24$address() {
        return avio_wl24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wl24(MemorySegment s, int val) {
        var mh$ = avio_wl24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl24", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wb24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wb24$descriptor() {
        return avio_wb24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wb24$handle() {
        return avio_wb24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wb24$address() {
        return avio_wb24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wb24(MemorySegment s, int val) {
        var mh$ = avio_wb24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb24", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wl16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wl16$descriptor() {
        return avio_wl16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wl16$handle() {
        return avio_wl16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wl16$address() {
        return avio_wl16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wl16(MemorySegment s, int val) {
        var mh$ = avio_wl16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl16", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_wb16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wb16$descriptor() {
        return avio_wb16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wb16$handle() {
        return avio_wb16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wb16$address() {
        return avio_wb16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wb16(MemorySegment s, int val) {
        var mh$ = avio_wb16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb16", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_put_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_put_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static FunctionDescriptor avio_put_str$descriptor() {
        return avio_put_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static MethodHandle avio_put_str$handle() {
        return avio_put_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static MemorySegment avio_put_str$address() {
        return avio_put_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static int avio_put_str(MemorySegment s, MemorySegment str) {
        var mh$ = avio_put_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_put_str", s, str);
            }
            return (int)mh$.invokeExact(s, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_put_str16le {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_put_str16le");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static FunctionDescriptor avio_put_str16le$descriptor() {
        return avio_put_str16le.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static MethodHandle avio_put_str16le$handle() {
        return avio_put_str16le.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static MemorySegment avio_put_str16le$address() {
        return avio_put_str16le.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static int avio_put_str16le(MemorySegment s, MemorySegment str) {
        var mh$ = avio_put_str16le.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_put_str16le", s, str);
            }
            return (int)mh$.invokeExact(s, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_put_str16be {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_put_str16be");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static FunctionDescriptor avio_put_str16be$descriptor() {
        return avio_put_str16be.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static MethodHandle avio_put_str16be$handle() {
        return avio_put_str16be.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static MemorySegment avio_put_str16be$address() {
        return avio_put_str16be.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static int avio_put_str16be(MemorySegment s, MemorySegment str) {
        var mh$ = avio_put_str16be.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_put_str16be", s, str);
            }
            return (int)mh$.invokeExact(s, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_write_marker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_write_marker");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static FunctionDescriptor avio_write_marker$descriptor() {
        return avio_write_marker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static MethodHandle avio_write_marker$handle() {
        return avio_write_marker.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static MemorySegment avio_write_marker$address() {
        return avio_write_marker.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static void avio_write_marker(MemorySegment s, long time, int type) {
        var mh$ = avio_write_marker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_write_marker", s, time, type);
            }
            mh$.invokeExact(s, time, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_seek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_seek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static FunctionDescriptor avio_seek$descriptor() {
        return avio_seek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static MethodHandle avio_seek$handle() {
        return avio_seek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static MemorySegment avio_seek$address() {
        return avio_seek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static long avio_seek(MemorySegment s, long offset, int whence) {
        var mh$ = avio_seek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_seek", s, offset, whence);
            }
            return (long)mh$.invokeExact(s, offset, whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_skip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_skip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static FunctionDescriptor avio_skip$descriptor() {
        return avio_skip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static MethodHandle avio_skip$handle() {
        return avio_skip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static MemorySegment avio_skip$address() {
        return avio_skip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static long avio_skip(MemorySegment s, long offset) {
        var mh$ = avio_skip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_skip", s, offset);
            }
            return (long)mh$.invokeExact(s, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_size$descriptor() {
        return avio_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_size$handle() {
        return avio_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_size$address() {
        return avio_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static long avio_size(MemorySegment s) {
        var mh$ = avio_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_size", s);
            }
            return (long)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_feof$descriptor() {
        return avio_feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_feof$handle() {
        return avio_feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_feof$address() {
        return avio_feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static int avio_feof(MemorySegment s) {
        var mh$ = avio_feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_feof", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static FunctionDescriptor avio_vprintf$descriptor() {
        return avio_vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static MethodHandle avio_vprintf$handle() {
        return avio_vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static MemorySegment avio_vprintf$address() {
        return avio_vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static int avio_vprintf(MemorySegment s, MemorySegment fmt, MemorySegment ap) {
        var mh$ = avio_vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_vprintf", s, fmt, ap);
            }
            return (int)mh$.invokeExact(s, fmt, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int avio_printf(AVIOContext *s, const char *fmt, ...)
     * }
     */
    public static class avio_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private avio_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int avio_printf(AVIOContext *s, const char *fmt, ...)
         * }
         */
        public static avio_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new avio_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment s, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("avio_printf", s, fmt, x2);
                }
                return (int)spreader.invokeExact(s, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class avio_print_string_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_print_string_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *strings[])
     * }
     */
    public static FunctionDescriptor avio_print_string_array$descriptor() {
        return avio_print_string_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *strings[])
     * }
     */
    public static MethodHandle avio_print_string_array$handle() {
        return avio_print_string_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *strings[])
     * }
     */
    public static MemorySegment avio_print_string_array$address() {
        return avio_print_string_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *strings[])
     * }
     */
    public static void avio_print_string_array(MemorySegment s, MemorySegment strings) {
        var mh$ = avio_print_string_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_print_string_array", s, strings);
            }
            mh$.invokeExact(s, strings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_flush$descriptor() {
        return avio_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_flush$handle() {
        return avio_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_flush$address() {
        return avio_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static void avio_flush(MemorySegment s) {
        var mh$ = avio_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_flush", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static FunctionDescriptor avio_read$descriptor() {
        return avio_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MethodHandle avio_read$handle() {
        return avio_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MemorySegment avio_read$address() {
        return avio_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static int avio_read(MemorySegment s, MemorySegment buf, int size) {
        var mh$ = avio_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read", s, buf, size);
            }
            return (int)mh$.invokeExact(s, buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read_partial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_read_partial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static FunctionDescriptor avio_read_partial$descriptor() {
        return avio_read_partial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MethodHandle avio_read_partial$handle() {
        return avio_read_partial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MemorySegment avio_read_partial$address() {
        return avio_read_partial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static int avio_read_partial(MemorySegment s, MemorySegment buf, int size) {
        var mh$ = avio_read_partial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read_partial", s, buf, size);
            }
            return (int)mh$.invokeExact(s, buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_r8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_r8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_r8$descriptor() {
        return avio_r8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_r8$handle() {
        return avio_r8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_r8$address() {
        return avio_r8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static int avio_r8(MemorySegment s) {
        var mh$ = avio_r8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_r8", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rl16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl16$descriptor() {
        return avio_rl16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl16$handle() {
        return avio_rl16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl16$address() {
        return avio_rl16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static int avio_rl16(MemorySegment s) {
        var mh$ = avio_rl16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl16", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rl24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl24$descriptor() {
        return avio_rl24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl24$handle() {
        return avio_rl24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl24$address() {
        return avio_rl24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static int avio_rl24(MemorySegment s) {
        var mh$ = avio_rl24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl24", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rl32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl32$descriptor() {
        return avio_rl32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl32$handle() {
        return avio_rl32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl32$address() {
        return avio_rl32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static int avio_rl32(MemorySegment s) {
        var mh$ = avio_rl32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl32", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl64$descriptor() {
        return avio_rl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl64$handle() {
        return avio_rl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl64$address() {
        return avio_rl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static long avio_rl64(MemorySegment s) {
        var mh$ = avio_rl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl64", s);
            }
            return (long)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rb16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb16$descriptor() {
        return avio_rb16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb16$handle() {
        return avio_rb16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb16$address() {
        return avio_rb16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static int avio_rb16(MemorySegment s) {
        var mh$ = avio_rb16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb16", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rb24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb24$descriptor() {
        return avio_rb24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb24$handle() {
        return avio_rb24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb24$address() {
        return avio_rb24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static int avio_rb24(MemorySegment s) {
        var mh$ = avio_rb24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb24", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rb32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb32$descriptor() {
        return avio_rb32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb32$handle() {
        return avio_rb32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb32$address() {
        return avio_rb32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static int avio_rb32(MemorySegment s) {
        var mh$ = avio_rb32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb32", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_rb64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb64$descriptor() {
        return avio_rb64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb64$handle() {
        return avio_rb64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb64$address() {
        return avio_rb64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static long avio_rb64(MemorySegment s) {
        var mh$ = avio_rb64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb64", s);
            }
            return (long)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_get_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor avio_get_str$descriptor() {
        return avio_get_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MethodHandle avio_get_str$handle() {
        return avio_get_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MemorySegment avio_get_str$address() {
        return avio_get_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static int avio_get_str(MemorySegment pb, int maxlen, MemorySegment buf, int buflen) {
        var mh$ = avio_get_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_str", pb, maxlen, buf, buflen);
            }
            return (int)mh$.invokeExact(pb, maxlen, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_str16le {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_get_str16le");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor avio_get_str16le$descriptor() {
        return avio_get_str16le.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MethodHandle avio_get_str16le$handle() {
        return avio_get_str16le.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MemorySegment avio_get_str16le$address() {
        return avio_get_str16le.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static int avio_get_str16le(MemorySegment pb, int maxlen, MemorySegment buf, int buflen) {
        var mh$ = avio_get_str16le.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_str16le", pb, maxlen, buf, buflen);
            }
            return (int)mh$.invokeExact(pb, maxlen, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_str16be {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_get_str16be");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor avio_get_str16be$descriptor() {
        return avio_get_str16be.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MethodHandle avio_get_str16be$handle() {
        return avio_get_str16be.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MemorySegment avio_get_str16be$address() {
        return avio_get_str16be.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static int avio_get_str16be(MemorySegment pb, int maxlen, MemorySegment buf, int buflen) {
        var mh$ = avio_get_str16be.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_str16be", pb, maxlen, buf, buflen);
            }
            return (int)mh$.invokeExact(pb, maxlen, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static FunctionDescriptor avio_open$descriptor() {
        return avio_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static MethodHandle avio_open$handle() {
        return avio_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static MemorySegment avio_open$address() {
        return avio_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static int avio_open(MemorySegment s, MemorySegment url, int flags) {
        var mh$ = avio_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open", s, url, flags);
            }
            return (int)mh$.invokeExact(s, url, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_open2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avio_open2$descriptor() {
        return avio_open2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static MethodHandle avio_open2$handle() {
        return avio_open2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static MemorySegment avio_open2$address() {
        return avio_open2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static int avio_open2(MemorySegment s, MemorySegment url, int flags, MemorySegment int_cb, MemorySegment options) {
        var mh$ = avio_open2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open2", s, url, flags, int_cb, options);
            }
            return (int)mh$.invokeExact(s, url, flags, int_cb, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_close$descriptor() {
        return avio_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_close$handle() {
        return avio_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_close$address() {
        return avio_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static int avio_close(MemorySegment s) {
        var mh$ = avio_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_close", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_closep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_closep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static FunctionDescriptor avio_closep$descriptor() {
        return avio_closep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static MethodHandle avio_closep$handle() {
        return avio_closep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static MemorySegment avio_closep$address() {
        return avio_closep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static int avio_closep(MemorySegment s) {
        var mh$ = avio_closep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_closep", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open_dyn_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_open_dyn_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static FunctionDescriptor avio_open_dyn_buf$descriptor() {
        return avio_open_dyn_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static MethodHandle avio_open_dyn_buf$handle() {
        return avio_open_dyn_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static MemorySegment avio_open_dyn_buf$address() {
        return avio_open_dyn_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static int avio_open_dyn_buf(MemorySegment s) {
        var mh$ = avio_open_dyn_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open_dyn_buf", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_dyn_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_get_dyn_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static FunctionDescriptor avio_get_dyn_buf$descriptor() {
        return avio_get_dyn_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MethodHandle avio_get_dyn_buf$handle() {
        return avio_get_dyn_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MemorySegment avio_get_dyn_buf$address() {
        return avio_get_dyn_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static int avio_get_dyn_buf(MemorySegment s, MemorySegment pbuffer) {
        var mh$ = avio_get_dyn_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_dyn_buf", s, pbuffer);
            }
            return (int)mh$.invokeExact(s, pbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_close_dyn_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_close_dyn_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static FunctionDescriptor avio_close_dyn_buf$descriptor() {
        return avio_close_dyn_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MethodHandle avio_close_dyn_buf$handle() {
        return avio_close_dyn_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MemorySegment avio_close_dyn_buf$address() {
        return avio_close_dyn_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static int avio_close_dyn_buf(MemorySegment s, MemorySegment pbuffer) {
        var mh$ = avio_close_dyn_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_close_dyn_buf", s, pbuffer);
            }
            return (int)mh$.invokeExact(s, pbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_enum_protocols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_enum_protocols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static FunctionDescriptor avio_enum_protocols$descriptor() {
        return avio_enum_protocols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static MethodHandle avio_enum_protocols$handle() {
        return avio_enum_protocols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static MemorySegment avio_enum_protocols$address() {
        return avio_enum_protocols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static MemorySegment avio_enum_protocols(MemorySegment opaque, int output) {
        var mh$ = avio_enum_protocols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_enum_protocols", opaque, output);
            }
            return (MemorySegment)mh$.invokeExact(opaque, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_protocol_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_protocol_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static FunctionDescriptor avio_protocol_get_class$descriptor() {
        return avio_protocol_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static MethodHandle avio_protocol_get_class$handle() {
        return avio_protocol_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static MemorySegment avio_protocol_get_class$address() {
        return avio_protocol_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static MemorySegment avio_protocol_get_class(MemorySegment name) {
        var mh$ = avio_protocol_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_protocol_get_class", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static FunctionDescriptor avio_pause$descriptor() {
        return avio_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static MethodHandle avio_pause$handle() {
        return avio_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static MemorySegment avio_pause$address() {
        return avio_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static int avio_pause(MemorySegment h, int pause) {
        var mh$ = avio_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_pause", h, pause);
            }
            return (int)mh$.invokeExact(h, pause);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_seek_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_seek_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor avio_seek_time$descriptor() {
        return avio_seek_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle avio_seek_time$handle() {
        return avio_seek_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment avio_seek_time$address() {
        return avio_seek_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static long avio_seek_time(MemorySegment h, int stream_index, long timestamp, int flags) {
        var mh$ = avio_seek_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_seek_time", h, stream_index, timestamp, flags);
            }
            return (long)mh$.invokeExact(h, stream_index, timestamp, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read_to_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_read_to_bprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static FunctionDescriptor avio_read_to_bprint$descriptor() {
        return avio_read_to_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static MethodHandle avio_read_to_bprint$handle() {
        return avio_read_to_bprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static MemorySegment avio_read_to_bprint$address() {
        return avio_read_to_bprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static int avio_read_to_bprint(MemorySegment h, MemorySegment pb, long max_size) {
        var mh$ = avio_read_to_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read_to_bprint", h, pb, max_size);
            }
            return (int)mh$.invokeExact(h, pb, max_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static FunctionDescriptor avio_accept$descriptor() {
        return avio_accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static MethodHandle avio_accept$handle() {
        return avio_accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static MemorySegment avio_accept$address() {
        return avio_accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static int avio_accept(MemorySegment s, MemorySegment c) {
        var mh$ = avio_accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_accept", s, c);
            }
            return (int)mh$.invokeExact(s, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_handshake {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avio_handshake");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static FunctionDescriptor avio_handshake$descriptor() {
        return avio_handshake.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static MethodHandle avio_handshake$handle() {
        return avio_handshake.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static MemorySegment avio_handshake$address() {
        return avio_handshake.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static int avio_handshake(MemorySegment c) {
        var mh$ = avio_handshake.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_handshake", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_get_packet$descriptor() {
        return av_get_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_get_packet$handle() {
        return av_get_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_get_packet$address() {
        return av_get_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static int av_get_packet(MemorySegment s, MemorySegment pkt, int size) {
        var mh$ = av_get_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_packet", s, pkt, size);
            }
            return (int)mh$.invokeExact(s, pkt, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_append_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_append_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_append_packet$descriptor() {
        return av_append_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_append_packet$handle() {
        return av_append_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_append_packet$address() {
        return av_append_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static int av_append_packet(MemorySegment s, MemorySegment pkt, int size) {
        var mh$ = av_append_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_append_packet", s, pkt, size);
            }
            return (int)mh$.invokeExact(s, pkt, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVSTREAM_PARSE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_NONE = 0
     * }
     */
    public static int AVSTREAM_PARSE_NONE() {
        return AVSTREAM_PARSE_NONE;
    }
    private static final int AVSTREAM_PARSE_FULL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_FULL = 1
     * }
     */
    public static int AVSTREAM_PARSE_FULL() {
        return AVSTREAM_PARSE_FULL;
    }
    private static final int AVSTREAM_PARSE_HEADERS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_HEADERS = 2
     * }
     */
    public static int AVSTREAM_PARSE_HEADERS() {
        return AVSTREAM_PARSE_HEADERS;
    }
    private static final int AVSTREAM_PARSE_TIMESTAMPS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_TIMESTAMPS = 3
     * }
     */
    public static int AVSTREAM_PARSE_TIMESTAMPS() {
        return AVSTREAM_PARSE_TIMESTAMPS;
    }
    private static final int AVSTREAM_PARSE_FULL_ONCE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_FULL_ONCE = 4
     * }
     */
    public static int AVSTREAM_PARSE_FULL_ONCE() {
        return AVSTREAM_PARSE_FULL_ONCE;
    }
    private static final int AVSTREAM_PARSE_FULL_RAW = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_FULL_RAW = 5
     * }
     */
    public static int AVSTREAM_PARSE_FULL_RAW() {
        return AVSTREAM_PARSE_FULL_RAW;
    }

    private static class av_disposition_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_disposition_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static FunctionDescriptor av_disposition_from_string$descriptor() {
        return av_disposition_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static MethodHandle av_disposition_from_string$handle() {
        return av_disposition_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static MemorySegment av_disposition_from_string$address() {
        return av_disposition_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static int av_disposition_from_string(MemorySegment disp) {
        var mh$ = av_disposition_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_disposition_from_string", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_disposition_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_disposition_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static FunctionDescriptor av_disposition_to_string$descriptor() {
        return av_disposition_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MethodHandle av_disposition_to_string$handle() {
        return av_disposition_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MemorySegment av_disposition_to_string$address() {
        return av_disposition_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MemorySegment av_disposition_to_string(int disposition) {
        var mh$ = av_disposition_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_disposition_to_string", disposition);
            }
            return (MemorySegment)mh$.invokeExact(disposition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_parser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_stream_get_parser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static FunctionDescriptor av_stream_get_parser$descriptor() {
        return av_stream_get_parser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MethodHandle av_stream_get_parser$handle() {
        return av_stream_get_parser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MemorySegment av_stream_get_parser$address() {
        return av_stream_get_parser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MemorySegment av_stream_get_parser(MemorySegment s) {
        var mh$ = av_stream_get_parser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_parser", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_end_pts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_stream_get_end_pts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_stream_get_end_pts(const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_stream_get_end_pts$descriptor() {
        return av_stream_get_end_pts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_stream_get_end_pts(const AVStream *st)
     * }
     */
    public static MethodHandle av_stream_get_end_pts$handle() {
        return av_stream_get_end_pts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_stream_get_end_pts(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_end_pts$address() {
        return av_stream_get_end_pts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_stream_get_end_pts(const AVStream *st)
     * }
     */
    public static long av_stream_get_end_pts(MemorySegment st) {
        var mh$ = av_stream_get_end_pts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_end_pts", st);
            }
            return (long)mh$.invokeExact(st);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVFMT_DURATION_FROM_PTS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod.AVFMT_DURATION_FROM_PTS = 0
     * }
     */
    public static int AVFMT_DURATION_FROM_PTS() {
        return AVFMT_DURATION_FROM_PTS;
    }
    private static final int AVFMT_DURATION_FROM_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod.AVFMT_DURATION_FROM_STREAM = 1
     * }
     */
    public static int AVFMT_DURATION_FROM_STREAM() {
        return AVFMT_DURATION_FROM_STREAM;
    }
    private static final int AVFMT_DURATION_FROM_BITRATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod.AVFMT_DURATION_FROM_BITRATE = 2
     * }
     */
    public static int AVFMT_DURATION_FROM_BITRATE() {
        return AVFMT_DURATION_FROM_BITRATE;
    }

    private static class av_format_inject_global_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_format_inject_global_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_format_inject_global_side_data(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_format_inject_global_side_data$descriptor() {
        return av_format_inject_global_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_format_inject_global_side_data(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_format_inject_global_side_data$handle() {
        return av_format_inject_global_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_format_inject_global_side_data(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_format_inject_global_side_data$address() {
        return av_format_inject_global_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_format_inject_global_side_data(AVFormatContext *s)
     * }
     */
    public static void av_format_inject_global_side_data(MemorySegment s) {
        var mh$ = av_format_inject_global_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_format_inject_global_side_data", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fmt_ctx_get_duration_estimation_method {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_fmt_ctx_get_duration_estimation_method");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext *ctx)
     * }
     */
    public static FunctionDescriptor av_fmt_ctx_get_duration_estimation_method$descriptor() {
        return av_fmt_ctx_get_duration_estimation_method.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext *ctx)
     * }
     */
    public static MethodHandle av_fmt_ctx_get_duration_estimation_method$handle() {
        return av_fmt_ctx_get_duration_estimation_method.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext *ctx)
     * }
     */
    public static MemorySegment av_fmt_ctx_get_duration_estimation_method$address() {
        return av_fmt_ctx_get_duration_estimation_method.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext *ctx)
     * }
     */
    public static int av_fmt_ctx_get_duration_estimation_method(MemorySegment ctx) {
        var mh$ = av_fmt_ctx_get_duration_estimation_method.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fmt_ctx_get_duration_estimation_method", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static FunctionDescriptor avformat_version$descriptor() {
        return avformat_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static MethodHandle avformat_version$handle() {
        return avformat_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static MemorySegment avformat_version$address() {
        return avformat_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static int avformat_version() {
        var mh$ = avformat_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static FunctionDescriptor avformat_configuration$descriptor() {
        return avformat_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MethodHandle avformat_configuration$handle() {
        return avformat_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MemorySegment avformat_configuration$address() {
        return avformat_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MemorySegment avformat_configuration() {
        var mh$ = avformat_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static FunctionDescriptor avformat_license$descriptor() {
        return avformat_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MethodHandle avformat_license$handle() {
        return avformat_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MemorySegment avformat_license$address() {
        return avformat_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MemorySegment avformat_license() {
        var mh$ = avformat_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_network_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_network_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static FunctionDescriptor avformat_network_init$descriptor() {
        return avformat_network_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static MethodHandle avformat_network_init$handle() {
        return avformat_network_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static MemorySegment avformat_network_init$address() {
        return avformat_network_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static int avformat_network_init() {
        var mh$ = avformat_network_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_network_init");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_network_deinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_network_deinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static FunctionDescriptor avformat_network_deinit$descriptor() {
        return avformat_network_deinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static MethodHandle avformat_network_deinit$handle() {
        return avformat_network_deinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static MemorySegment avformat_network_deinit$address() {
        return avformat_network_deinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static int avformat_network_deinit() {
        var mh$ = avformat_network_deinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_network_deinit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_muxer_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_muxer_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_muxer_iterate$descriptor() {
        return av_muxer_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_muxer_iterate$handle() {
        return av_muxer_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_muxer_iterate$address() {
        return av_muxer_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_muxer_iterate(MemorySegment opaque) {
        var mh$ = av_muxer_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_muxer_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_demuxer_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_demuxer_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_demuxer_iterate$descriptor() {
        return av_demuxer_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_demuxer_iterate$handle() {
        return av_demuxer_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_demuxer_iterate$address() {
        return av_demuxer_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_demuxer_iterate(MemorySegment opaque) {
        var mh$ = av_demuxer_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_demuxer_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static FunctionDescriptor avformat_alloc_context$descriptor() {
        return avformat_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MethodHandle avformat_alloc_context$handle() {
        return avformat_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MemorySegment avformat_alloc_context$address() {
        return avformat_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MemorySegment avformat_alloc_context() {
        var mh$ = avformat_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_alloc_context");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_free_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_free_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_free_context$descriptor() {
        return avformat_free_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_free_context$handle() {
        return avformat_free_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_free_context$address() {
        return avformat_free_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static void avformat_free_context(MemorySegment s) {
        var mh$ = avformat_free_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_free_context", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static FunctionDescriptor avformat_get_class$descriptor() {
        return avformat_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MethodHandle avformat_get_class$handle() {
        return avformat_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MemorySegment avformat_get_class$address() {
        return avformat_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MemorySegment avformat_get_class() {
        var mh$ = avformat_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_stream_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static FunctionDescriptor av_stream_get_class$descriptor() {
        return av_stream_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MethodHandle av_stream_get_class$handle() {
        return av_stream_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MemorySegment av_stream_get_class$address() {
        return av_stream_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MemorySegment av_stream_get_class() {
        var mh$ = av_stream_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_new_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_new_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c)
     * }
     */
    public static FunctionDescriptor avformat_new_stream$descriptor() {
        return avformat_new_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c)
     * }
     */
    public static MethodHandle avformat_new_stream$handle() {
        return avformat_new_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c)
     * }
     */
    public static MemorySegment avformat_new_stream$address() {
        return avformat_new_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c)
     * }
     */
    public static MemorySegment avformat_new_stream(MemorySegment s, MemorySegment c) {
        var mh$ = avformat_new_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_new_stream", s, c);
            }
            return (MemorySegment)mh$.invokeExact(s, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_add_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_stream_add_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static FunctionDescriptor av_stream_add_side_data$descriptor() {
        return av_stream_add_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static MethodHandle av_stream_add_side_data$handle() {
        return av_stream_add_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static MemorySegment av_stream_add_side_data$address() {
        return av_stream_add_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type, uint8_t *data, size_t size)
     * }
     */
    public static int av_stream_add_side_data(MemorySegment st, int type, MemorySegment data, long size) {
        var mh$ = av_stream_add_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_add_side_data", st, type, data, size);
            }
            return (int)mh$.invokeExact(st, type, data, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_new_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_stream_new_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_stream_new_side_data(AVStream *stream, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_stream_new_side_data$descriptor() {
        return av_stream_new_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_stream_new_side_data(AVStream *stream, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_stream_new_side_data$handle() {
        return av_stream_new_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_stream_new_side_data(AVStream *stream, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_stream_new_side_data$address() {
        return av_stream_new_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_stream_new_side_data(AVStream *stream, enum AVPacketSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_stream_new_side_data(MemorySegment stream, int type, long size) {
        var mh$ = av_stream_new_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_new_side_data", stream, type, size);
            }
            return (MemorySegment)mh$.invokeExact(stream, type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_stream_get_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint8_t *av_stream_get_side_data(const AVStream *stream, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static FunctionDescriptor av_stream_get_side_data$descriptor() {
        return av_stream_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint8_t *av_stream_get_side_data(const AVStream *stream, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MethodHandle av_stream_get_side_data$handle() {
        return av_stream_get_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint8_t *av_stream_get_side_data(const AVStream *stream, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MemorySegment av_stream_get_side_data$address() {
        return av_stream_get_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint8_t *av_stream_get_side_data(const AVStream *stream, enum AVPacketSideDataType type, size_t *size)
     * }
     */
    public static MemorySegment av_stream_get_side_data(MemorySegment stream, int type, MemorySegment size) {
        var mh$ = av_stream_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_side_data", stream, type, size);
            }
            return (MemorySegment)mh$.invokeExact(stream, type, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_new_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_new_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static FunctionDescriptor av_new_program$descriptor() {
        return av_new_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MethodHandle av_new_program$handle() {
        return av_new_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MemorySegment av_new_program$address() {
        return av_new_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MemorySegment av_new_program(MemorySegment s, int id) {
        var mh$ = av_new_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_new_program", s, id);
            }
            return (MemorySegment)mh$.invokeExact(s, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_alloc_output_context2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_alloc_output_context2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static FunctionDescriptor avformat_alloc_output_context2$descriptor() {
        return avformat_alloc_output_context2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static MethodHandle avformat_alloc_output_context2$handle() {
        return avformat_alloc_output_context2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static MemorySegment avformat_alloc_output_context2$address() {
        return avformat_alloc_output_context2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static int avformat_alloc_output_context2(MemorySegment ctx, MemorySegment oformat, MemorySegment format_name, MemorySegment filename) {
        var mh$ = avformat_alloc_output_context2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_alloc_output_context2", ctx, oformat, format_name, filename);
            }
            return (int)mh$.invokeExact(ctx, oformat, format_name, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_input_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_find_input_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static FunctionDescriptor av_find_input_format$descriptor() {
        return av_find_input_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MethodHandle av_find_input_format$handle() {
        return av_find_input_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MemorySegment av_find_input_format$address() {
        return av_find_input_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MemorySegment av_find_input_format(MemorySegment short_name) {
        var mh$ = av_find_input_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_input_format", short_name);
            }
            return (MemorySegment)mh$.invokeExact(short_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_probe_input_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static FunctionDescriptor av_probe_input_format$descriptor() {
        return av_probe_input_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MethodHandle av_probe_input_format$handle() {
        return av_probe_input_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MemorySegment av_probe_input_format$address() {
        return av_probe_input_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MemorySegment av_probe_input_format(MemorySegment pd, int is_opened) {
        var mh$ = av_probe_input_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format", pd, is_opened);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_probe_input_format2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static FunctionDescriptor av_probe_input_format2$descriptor() {
        return av_probe_input_format2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MethodHandle av_probe_input_format2$handle() {
        return av_probe_input_format2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MemorySegment av_probe_input_format2$address() {
        return av_probe_input_format2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MemorySegment av_probe_input_format2(MemorySegment pd, int is_opened, MemorySegment score_max) {
        var mh$ = av_probe_input_format2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format2", pd, is_opened, score_max);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened, score_max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_probe_input_format3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static FunctionDescriptor av_probe_input_format3$descriptor() {
        return av_probe_input_format3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MethodHandle av_probe_input_format3$handle() {
        return av_probe_input_format3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MemorySegment av_probe_input_format3$address() {
        return av_probe_input_format3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MemorySegment av_probe_input_format3(MemorySegment pd, int is_opened, MemorySegment score_ret) {
        var mh$ = av_probe_input_format3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format3", pd, is_opened, score_ret);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened, score_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_buffer2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_probe_input_buffer2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static FunctionDescriptor av_probe_input_buffer2$descriptor() {
        return av_probe_input_buffer2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MethodHandle av_probe_input_buffer2$handle() {
        return av_probe_input_buffer2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MemorySegment av_probe_input_buffer2$address() {
        return av_probe_input_buffer2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static int av_probe_input_buffer2(MemorySegment pb, MemorySegment fmt, MemorySegment url, MemorySegment logctx, int offset, int max_probe_size) {
        var mh$ = av_probe_input_buffer2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_buffer2", pb, fmt, url, logctx, offset, max_probe_size);
            }
            return (int)mh$.invokeExact(pb, fmt, url, logctx, offset, max_probe_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_probe_input_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static FunctionDescriptor av_probe_input_buffer$descriptor() {
        return av_probe_input_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MethodHandle av_probe_input_buffer$handle() {
        return av_probe_input_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MemorySegment av_probe_input_buffer$address() {
        return av_probe_input_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static int av_probe_input_buffer(MemorySegment pb, MemorySegment fmt, MemorySegment url, MemorySegment logctx, int offset, int max_probe_size) {
        var mh$ = av_probe_input_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_buffer", pb, fmt, url, logctx, offset, max_probe_size);
            }
            return (int)mh$.invokeExact(pb, fmt, url, logctx, offset, max_probe_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_open_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_open_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_open_input$descriptor() {
        return avformat_open_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_open_input$handle() {
        return avformat_open_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_open_input$address() {
        return avformat_open_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static int avformat_open_input(MemorySegment ps, MemorySegment url, MemorySegment fmt, MemorySegment options) {
        var mh$ = avformat_open_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_open_input", ps, url, fmt, options);
            }
            return (int)mh$.invokeExact(ps, url, fmt, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_find_stream_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_find_stream_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_find_stream_info$descriptor() {
        return avformat_find_stream_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_find_stream_info$handle() {
        return avformat_find_stream_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_find_stream_info$address() {
        return avformat_find_stream_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static int avformat_find_stream_info(MemorySegment ic, MemorySegment options) {
        var mh$ = avformat_find_stream_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_find_stream_info", ic, options);
            }
            return (int)mh$.invokeExact(ic, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_program_from_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_find_program_from_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static FunctionDescriptor av_find_program_from_stream$descriptor() {
        return av_find_program_from_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MethodHandle av_find_program_from_stream$handle() {
        return av_find_program_from_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MemorySegment av_find_program_from_stream$address() {
        return av_find_program_from_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MemorySegment av_find_program_from_stream(MemorySegment ic, MemorySegment last, int s) {
        var mh$ = av_find_program_from_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_program_from_stream", ic, last, s);
            }
            return (MemorySegment)mh$.invokeExact(ic, last, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_program_add_stream_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_program_add_stream_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static FunctionDescriptor av_program_add_stream_index$descriptor() {
        return av_program_add_stream_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static MethodHandle av_program_add_stream_index$handle() {
        return av_program_add_stream_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static MemorySegment av_program_add_stream_index$address() {
        return av_program_add_stream_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static void av_program_add_stream_index(MemorySegment ac, int progid, int idx) {
        var mh$ = av_program_add_stream_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_program_add_stream_index", ac, progid, idx);
            }
            mh$.invokeExact(ac, progid, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_best_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_find_best_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const AVCodec **decoder_ret, int flags)
     * }
     */
    public static FunctionDescriptor av_find_best_stream$descriptor() {
        return av_find_best_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const AVCodec **decoder_ret, int flags)
     * }
     */
    public static MethodHandle av_find_best_stream$handle() {
        return av_find_best_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const AVCodec **decoder_ret, int flags)
     * }
     */
    public static MemorySegment av_find_best_stream$address() {
        return av_find_best_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const AVCodec **decoder_ret, int flags)
     * }
     */
    public static int av_find_best_stream(MemorySegment ic, int type, int wanted_stream_nb, int related_stream, MemorySegment decoder_ret, int flags) {
        var mh$ = av_find_best_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_best_stream", ic, type, wanted_stream_nb, related_stream, decoder_ret, flags);
            }
            return (int)mh$.invokeExact(ic, type, wanted_stream_nb, related_stream, decoder_ret, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_read_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_read_frame$descriptor() {
        return av_read_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_read_frame$handle() {
        return av_read_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_read_frame$address() {
        return av_read_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_read_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_read_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_seek_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_seek_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor av_seek_frame$descriptor() {
        return av_seek_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle av_seek_frame$handle() {
        return av_seek_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment av_seek_frame$address() {
        return av_seek_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static int av_seek_frame(MemorySegment s, int stream_index, long timestamp, int flags) {
        var mh$ = av_seek_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_seek_frame", s, stream_index, timestamp, flags);
            }
            return (int)mh$.invokeExact(s, stream_index, timestamp, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_seek_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_seek_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static FunctionDescriptor avformat_seek_file$descriptor() {
        return avformat_seek_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static MethodHandle avformat_seek_file$handle() {
        return avformat_seek_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static MemorySegment avformat_seek_file$address() {
        return avformat_seek_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static int avformat_seek_file(MemorySegment s, int stream_index, long min_ts, long ts, long max_ts, int flags) {
        var mh$ = avformat_seek_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_seek_file", s, stream_index, min_ts, ts, max_ts, flags);
            }
            return (int)mh$.invokeExact(s, stream_index, min_ts, ts, max_ts, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_flush$descriptor() {
        return avformat_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_flush$handle() {
        return avformat_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_flush$address() {
        return avformat_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static int avformat_flush(MemorySegment s) {
        var mh$ = avformat_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_flush", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_play {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_read_play");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_read_play$descriptor() {
        return av_read_play.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_read_play$handle() {
        return av_read_play.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_read_play$address() {
        return av_read_play.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static int av_read_play(MemorySegment s) {
        var mh$ = av_read_play.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_play", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_read_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_read_pause$descriptor() {
        return av_read_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_read_pause$handle() {
        return av_read_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_read_pause$address() {
        return av_read_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static int av_read_pause(MemorySegment s) {
        var mh$ = av_read_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_pause", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_close_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_close_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static FunctionDescriptor avformat_close_input$descriptor() {
        return avformat_close_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static MethodHandle avformat_close_input$handle() {
        return avformat_close_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static MemorySegment avformat_close_input$address() {
        return avformat_close_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static void avformat_close_input(MemorySegment s) {
        var mh$ = avformat_close_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_close_input", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_write_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_write_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_write_header$descriptor() {
        return avformat_write_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_write_header$handle() {
        return avformat_write_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_write_header$address() {
        return avformat_write_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static int avformat_write_header(MemorySegment s, MemorySegment options) {
        var mh$ = avformat_write_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_write_header", s, options);
            }
            return (int)mh$.invokeExact(s, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_init_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_init_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_init_output$descriptor() {
        return avformat_init_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_init_output$handle() {
        return avformat_init_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_init_output$address() {
        return avformat_init_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static int avformat_init_output(MemorySegment s, MemorySegment options) {
        var mh$ = avformat_init_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_init_output", s, options);
            }
            return (int)mh$.invokeExact(s, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_write_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_write_frame$descriptor() {
        return av_write_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_write_frame$handle() {
        return av_write_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_write_frame$address() {
        return av_write_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_write_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_write_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_interleaved_write_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_interleaved_write_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_interleaved_write_frame$descriptor() {
        return av_interleaved_write_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_interleaved_write_frame$handle() {
        return av_interleaved_write_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_interleaved_write_frame$address() {
        return av_interleaved_write_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_interleaved_write_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_interleaved_write_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_interleaved_write_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_uncoded_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_write_uncoded_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_write_uncoded_frame$descriptor() {
        return av_write_uncoded_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static MethodHandle av_write_uncoded_frame$handle() {
        return av_write_uncoded_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static MemorySegment av_write_uncoded_frame$address() {
        return av_write_uncoded_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static int av_write_uncoded_frame(MemorySegment s, int stream_index, MemorySegment frame) {
        var mh$ = av_write_uncoded_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_uncoded_frame", s, stream_index, frame);
            }
            return (int)mh$.invokeExact(s, stream_index, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_interleaved_write_uncoded_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_interleaved_write_uncoded_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_interleaved_write_uncoded_frame$descriptor() {
        return av_interleaved_write_uncoded_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static MethodHandle av_interleaved_write_uncoded_frame$handle() {
        return av_interleaved_write_uncoded_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static MemorySegment av_interleaved_write_uncoded_frame$address() {
        return av_interleaved_write_uncoded_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)
     * }
     */
    public static int av_interleaved_write_uncoded_frame(MemorySegment s, int stream_index, MemorySegment frame) {
        var mh$ = av_interleaved_write_uncoded_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_interleaved_write_uncoded_frame", s, stream_index, frame);
            }
            return (int)mh$.invokeExact(s, stream_index, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_uncoded_frame_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_write_uncoded_frame_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static FunctionDescriptor av_write_uncoded_frame_query$descriptor() {
        return av_write_uncoded_frame_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static MethodHandle av_write_uncoded_frame_query$handle() {
        return av_write_uncoded_frame_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static MemorySegment av_write_uncoded_frame_query$address() {
        return av_write_uncoded_frame_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static int av_write_uncoded_frame_query(MemorySegment s, int stream_index) {
        var mh$ = av_write_uncoded_frame_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_uncoded_frame_query", s, stream_index);
            }
            return (int)mh$.invokeExact(s, stream_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_trailer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_write_trailer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_write_trailer$descriptor() {
        return av_write_trailer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_write_trailer$handle() {
        return av_write_trailer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_write_trailer$address() {
        return av_write_trailer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static int av_write_trailer(MemorySegment s) {
        var mh$ = av_write_trailer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_trailer", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_guess_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static FunctionDescriptor av_guess_format$descriptor() {
        return av_guess_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MethodHandle av_guess_format$handle() {
        return av_guess_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MemorySegment av_guess_format$address() {
        return av_guess_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MemorySegment av_guess_format(MemorySegment short_name, MemorySegment filename, MemorySegment mime_type) {
        var mh$ = av_guess_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_format", short_name, filename, mime_type);
            }
            return (MemorySegment)mh$.invokeExact(short_name, filename, mime_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_codec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_guess_codec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static FunctionDescriptor av_guess_codec$descriptor() {
        return av_guess_codec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static MethodHandle av_guess_codec$handle() {
        return av_guess_codec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static MemorySegment av_guess_codec$address() {
        return av_guess_codec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static int av_guess_codec(MemorySegment fmt, MemorySegment short_name, MemorySegment filename, MemorySegment mime_type, int type) {
        var mh$ = av_guess_codec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_codec", fmt, short_name, filename, mime_type, type);
            }
            return (int)mh$.invokeExact(fmt, short_name, filename, mime_type, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_output_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_output_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static FunctionDescriptor av_get_output_timestamp$descriptor() {
        return av_get_output_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static MethodHandle av_get_output_timestamp$handle() {
        return av_get_output_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static MemorySegment av_get_output_timestamp$address() {
        return av_get_output_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static int av_get_output_timestamp(MemorySegment s, int stream, MemorySegment dts, MemorySegment wall) {
        var mh$ = av_get_output_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_output_timestamp", s, stream, dts, wall);
            }
            return (int)mh$.invokeExact(s, stream, dts, wall);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hex_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hex_dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static FunctionDescriptor av_hex_dump$descriptor() {
        return av_hex_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static MethodHandle av_hex_dump$handle() {
        return av_hex_dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static MemorySegment av_hex_dump$address() {
        return av_hex_dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static void av_hex_dump(MemorySegment f, MemorySegment buf, int size) {
        var mh$ = av_hex_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hex_dump", f, buf, size);
            }
            mh$.invokeExact(f, buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hex_dump_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_hex_dump_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static FunctionDescriptor av_hex_dump_log$descriptor() {
        return av_hex_dump_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static MethodHandle av_hex_dump_log$handle() {
        return av_hex_dump_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static MemorySegment av_hex_dump_log$address() {
        return av_hex_dump_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static void av_hex_dump_log(MemorySegment avcl, int level, MemorySegment buf, int size) {
        var mh$ = av_hex_dump_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hex_dump_log", avcl, level, buf, size);
            }
            mh$.invokeExact(avcl, level, buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pkt_dump2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pkt_dump2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_pkt_dump2$descriptor() {
        return av_pkt_dump2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MethodHandle av_pkt_dump2$handle() {
        return av_pkt_dump2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MemorySegment av_pkt_dump2$address() {
        return av_pkt_dump2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static void av_pkt_dump2(MemorySegment f, MemorySegment pkt, int dump_payload, MemorySegment st) {
        var mh$ = av_pkt_dump2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pkt_dump2", f, pkt, dump_payload, st);
            }
            mh$.invokeExact(f, pkt, dump_payload, st);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pkt_dump_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pkt_dump_log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_pkt_dump_log2$descriptor() {
        return av_pkt_dump_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MethodHandle av_pkt_dump_log2$handle() {
        return av_pkt_dump_log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MemorySegment av_pkt_dump_log2$address() {
        return av_pkt_dump_log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static void av_pkt_dump_log2(MemorySegment avcl, int level, MemorySegment pkt, int dump_payload, MemorySegment st) {
        var mh$ = av_pkt_dump_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pkt_dump_log2", avcl, level, pkt, dump_payload, st);
            }
            mh$.invokeExact(avcl, level, pkt, dump_payload, st);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_codec_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static FunctionDescriptor av_codec_get_id$descriptor() {
        return av_codec_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static MethodHandle av_codec_get_id$handle() {
        return av_codec_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static MemorySegment av_codec_get_id$address() {
        return av_codec_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static int av_codec_get_id(MemorySegment tags, int tag) {
        var mh$ = av_codec_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_id", tags, tag);
            }
            return (int)mh$.invokeExact(tags, tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_codec_get_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor av_codec_get_tag$descriptor() {
        return av_codec_get_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static MethodHandle av_codec_get_tag$handle() {
        return av_codec_get_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static MemorySegment av_codec_get_tag$address() {
        return av_codec_get_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static int av_codec_get_tag(MemorySegment tags, int id) {
        var mh$ = av_codec_get_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_tag", tags, id);
            }
            return (int)mh$.invokeExact(tags, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_tag2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_codec_get_tag2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static FunctionDescriptor av_codec_get_tag2$descriptor() {
        return av_codec_get_tag2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static MethodHandle av_codec_get_tag2$handle() {
        return av_codec_get_tag2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static MemorySegment av_codec_get_tag2$address() {
        return av_codec_get_tag2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static int av_codec_get_tag2(MemorySegment tags, int id, MemorySegment tag) {
        var mh$ = av_codec_get_tag2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_tag2", tags, id, tag);
            }
            return (int)mh$.invokeExact(tags, id, tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_default_stream_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_find_default_stream_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_find_default_stream_index$descriptor() {
        return av_find_default_stream_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_find_default_stream_index$handle() {
        return av_find_default_stream_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_find_default_stream_index$address() {
        return av_find_default_stream_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static int av_find_default_stream_index(MemorySegment s) {
        var mh$ = av_find_default_stream_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_default_stream_index", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_index_search_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_index_search_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor av_index_search_timestamp$descriptor() {
        return av_index_search_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle av_index_search_timestamp$handle() {
        return av_index_search_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment av_index_search_timestamp$address() {
        return av_index_search_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static int av_index_search_timestamp(MemorySegment st, long timestamp, int flags) {
        var mh$ = av_index_search_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_index_search_timestamp", st, timestamp, flags);
            }
            return (int)mh$.invokeExact(st, timestamp, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entries_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_index_get_entries_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entries_count$descriptor() {
        return avformat_index_get_entries_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static MethodHandle avformat_index_get_entries_count$handle() {
        return avformat_index_get_entries_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static MemorySegment avformat_index_get_entries_count$address() {
        return avformat_index_get_entries_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static int avformat_index_get_entries_count(MemorySegment st) {
        var mh$ = avformat_index_get_entries_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entries_count", st);
            }
            return (int)mh$.invokeExact(st);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_index_get_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entry$descriptor() {
        return avformat_index_get_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MethodHandle avformat_index_get_entry$handle() {
        return avformat_index_get_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MemorySegment avformat_index_get_entry$address() {
        return avformat_index_get_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MemorySegment avformat_index_get_entry(MemorySegment st, int idx) {
        var mh$ = avformat_index_get_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entry", st, idx);
            }
            return (MemorySegment)mh$.invokeExact(st, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entry_from_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_index_get_entry_from_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entry_from_timestamp$descriptor() {
        return avformat_index_get_entry_from_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MethodHandle avformat_index_get_entry_from_timestamp$handle() {
        return avformat_index_get_entry_from_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MemorySegment avformat_index_get_entry_from_timestamp$address() {
        return avformat_index_get_entry_from_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MemorySegment avformat_index_get_entry_from_timestamp(MemorySegment st, long wanted_timestamp, int flags) {
        var mh$ = avformat_index_get_entry_from_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entry_from_timestamp", st, wanted_timestamp, flags);
            }
            return (MemorySegment)mh$.invokeExact(st, wanted_timestamp, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_index_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_add_index_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static FunctionDescriptor av_add_index_entry$descriptor() {
        return av_add_index_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static MethodHandle av_add_index_entry$handle() {
        return av_add_index_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static MemorySegment av_add_index_entry$address() {
        return av_add_index_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static int av_add_index_entry(MemorySegment st, long pos, long timestamp, int size, int distance, int flags) {
        var mh$ = av_add_index_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_index_entry", st, pos, timestamp, size, distance, flags);
            }
            return (int)mh$.invokeExact(st, pos, timestamp, size, distance, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_url_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_url_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static FunctionDescriptor av_url_split$descriptor() {
        return av_url_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static MethodHandle av_url_split$handle() {
        return av_url_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static MemorySegment av_url_split$address() {
        return av_url_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static void av_url_split(MemorySegment proto, int proto_size, MemorySegment authorization, int authorization_size, MemorySegment hostname, int hostname_size, MemorySegment port_ptr, MemorySegment path, int path_size, MemorySegment url) {
        var mh$ = av_url_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_url_split", proto, proto_size, authorization, authorization_size, hostname, hostname_size, port_ptr, path, path_size, url);
            }
            mh$.invokeExact(proto, proto_size, authorization, authorization_size, hostname, hostname_size, port_ptr, path, path_size, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dump_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_dump_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static FunctionDescriptor av_dump_format$descriptor() {
        return av_dump_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static MethodHandle av_dump_format$handle() {
        return av_dump_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static MemorySegment av_dump_format$address() {
        return av_dump_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static void av_dump_format(MemorySegment ic, int index, MemorySegment url, int is_output) {
        var mh$ = av_dump_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dump_format", ic, index, url, is_output);
            }
            mh$.invokeExact(ic, index, url, is_output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_frame_filename2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_frame_filename2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static FunctionDescriptor av_get_frame_filename2$descriptor() {
        return av_get_frame_filename2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static MethodHandle av_get_frame_filename2$handle() {
        return av_get_frame_filename2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static MemorySegment av_get_frame_filename2$address() {
        return av_get_frame_filename2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static int av_get_frame_filename2(MemorySegment buf, int buf_size, MemorySegment path, int number, int flags) {
        var mh$ = av_get_frame_filename2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_frame_filename2", buf, buf_size, path, number, flags);
            }
            return (int)mh$.invokeExact(buf, buf_size, path, number, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_frame_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_frame_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static FunctionDescriptor av_get_frame_filename$descriptor() {
        return av_get_frame_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static MethodHandle av_get_frame_filename$handle() {
        return av_get_frame_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static MemorySegment av_get_frame_filename$address() {
        return av_get_frame_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static int av_get_frame_filename(MemorySegment buf, int buf_size, MemorySegment path, int number) {
        var mh$ = av_get_frame_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_frame_filename", buf, buf_size, path, number);
            }
            return (int)mh$.invokeExact(buf, buf_size, path, number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_filename_number_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_filename_number_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static FunctionDescriptor av_filename_number_test$descriptor() {
        return av_filename_number_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static MethodHandle av_filename_number_test$handle() {
        return av_filename_number_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static MemorySegment av_filename_number_test$address() {
        return av_filename_number_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static int av_filename_number_test(MemorySegment filename) {
        var mh$ = av_filename_number_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_filename_number_test", filename);
            }
            return (int)mh$.invokeExact(filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sdp_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_sdp_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static FunctionDescriptor av_sdp_create$descriptor() {
        return av_sdp_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static MethodHandle av_sdp_create$handle() {
        return av_sdp_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static MemorySegment av_sdp_create$address() {
        return av_sdp_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static int av_sdp_create(MemorySegment ac, int n_files, MemorySegment buf, int size) {
        var mh$ = av_sdp_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sdp_create", ac, n_files, buf, size);
            }
            return (int)mh$.invokeExact(ac, n_files, buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_match_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_match_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static FunctionDescriptor av_match_ext$descriptor() {
        return av_match_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static MethodHandle av_match_ext$handle() {
        return av_match_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static MemorySegment av_match_ext$address() {
        return av_match_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static int av_match_ext(MemorySegment filename, MemorySegment extensions) {
        var mh$ = av_match_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_match_ext", filename, extensions);
            }
            return (int)mh$.invokeExact(filename, extensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_query_codec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_query_codec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static FunctionDescriptor avformat_query_codec$descriptor() {
        return avformat_query_codec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static MethodHandle avformat_query_codec$handle() {
        return avformat_query_codec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static MemorySegment avformat_query_codec$address() {
        return avformat_query_codec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static int avformat_query_codec(MemorySegment ofmt, int codec_id, int std_compliance) {
        var mh$ = avformat_query_codec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_query_codec", ofmt, codec_id, std_compliance);
            }
            return (int)mh$.invokeExact(ofmt, codec_id, std_compliance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_riff_video_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_get_riff_video_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_riff_video_tags$descriptor() {
        return avformat_get_riff_video_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MethodHandle avformat_get_riff_video_tags$handle() {
        return avformat_get_riff_video_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_video_tags$address() {
        return avformat_get_riff_video_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_video_tags() {
        var mh$ = avformat_get_riff_video_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_riff_video_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_riff_audio_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_get_riff_audio_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_riff_audio_tags$descriptor() {
        return avformat_get_riff_audio_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MethodHandle avformat_get_riff_audio_tags$handle() {
        return avformat_get_riff_audio_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_audio_tags$address() {
        return avformat_get_riff_audio_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_audio_tags() {
        var mh$ = avformat_get_riff_audio_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_riff_audio_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_mov_video_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_get_mov_video_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_mov_video_tags$descriptor() {
        return avformat_get_mov_video_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MethodHandle avformat_get_mov_video_tags$handle() {
        return avformat_get_mov_video_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_video_tags$address() {
        return avformat_get_mov_video_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_video_tags() {
        var mh$ = avformat_get_mov_video_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_mov_video_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_mov_audio_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_get_mov_audio_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_mov_audio_tags$descriptor() {
        return avformat_get_mov_audio_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MethodHandle avformat_get_mov_audio_tags$handle() {
        return avformat_get_mov_audio_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_audio_tags$address() {
        return avformat_get_mov_audio_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_audio_tags() {
        var mh$ = avformat_get_mov_audio_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_mov_audio_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_sample_aspect_ratio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_guess_sample_aspect_ratio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_guess_sample_aspect_ratio$descriptor() {
        return av_guess_sample_aspect_ratio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, AVFrame *frame)
     * }
     */
    public static MethodHandle av_guess_sample_aspect_ratio$handle() {
        return av_guess_sample_aspect_ratio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_sample_aspect_ratio$address() {
        return av_guess_sample_aspect_ratio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_sample_aspect_ratio(SegmentAllocator allocator, MemorySegment format, MemorySegment stream, MemorySegment frame) {
        var mh$ = av_guess_sample_aspect_ratio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_sample_aspect_ratio", allocator, format, stream, frame);
            }
            return (MemorySegment)mh$.invokeExact(allocator, format, stream, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_frame_rate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_guess_frame_rate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_guess_frame_rate$descriptor() {
        return av_guess_frame_rate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, AVFrame *frame)
     * }
     */
    public static MethodHandle av_guess_frame_rate$handle() {
        return av_guess_frame_rate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_frame_rate$address() {
        return av_guess_frame_rate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_frame_rate(SegmentAllocator allocator, MemorySegment ctx, MemorySegment stream, MemorySegment frame) {
        var mh$ = av_guess_frame_rate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_frame_rate", allocator, ctx, stream, frame);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx, stream, frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_match_stream_specifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_match_stream_specifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static FunctionDescriptor avformat_match_stream_specifier$descriptor() {
        return avformat_match_stream_specifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static MethodHandle avformat_match_stream_specifier$handle() {
        return avformat_match_stream_specifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static MemorySegment avformat_match_stream_specifier$address() {
        return avformat_match_stream_specifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static int avformat_match_stream_specifier(MemorySegment s, MemorySegment st, MemorySegment spec) {
        var mh$ = avformat_match_stream_specifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_match_stream_specifier", s, st, spec);
            }
            return (int)mh$.invokeExact(s, st, spec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_queue_attached_pictures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_queue_attached_pictures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_queue_attached_pictures$descriptor() {
        return avformat_queue_attached_pictures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_queue_attached_pictures$handle() {
        return avformat_queue_attached_pictures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_queue_attached_pictures$address() {
        return avformat_queue_attached_pictures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static int avformat_queue_attached_pictures(MemorySegment s) {
        var mh$ = avformat_queue_attached_pictures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_queue_attached_pictures", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVFMT_TBCF_AUTO = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_AUTO = -1
     * }
     */
    public static int AVFMT_TBCF_AUTO() {
        return AVFMT_TBCF_AUTO;
    }
    private static final int AVFMT_TBCF_DECODER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_DECODER = 0
     * }
     */
    public static int AVFMT_TBCF_DECODER() {
        return AVFMT_TBCF_DECODER;
    }
    private static final int AVFMT_TBCF_DEMUXER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_DEMUXER = 1
     * }
     */
    public static int AVFMT_TBCF_DEMUXER() {
        return AVFMT_TBCF_DEMUXER;
    }
    private static final int AVFMT_TBCF_R_FRAMERATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_R_FRAMERATE = 2
     * }
     */
    public static int AVFMT_TBCF_R_FRAMERATE() {
        return AVFMT_TBCF_R_FRAMERATE;
    }

    private static class avformat_transfer_internal_stream_timing_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("avformat_transfer_internal_stream_timing_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static FunctionDescriptor avformat_transfer_internal_stream_timing_info$descriptor() {
        return avformat_transfer_internal_stream_timing_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static MethodHandle avformat_transfer_internal_stream_timing_info$handle() {
        return avformat_transfer_internal_stream_timing_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static MemorySegment avformat_transfer_internal_stream_timing_info$address() {
        return avformat_transfer_internal_stream_timing_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static int avformat_transfer_internal_stream_timing_info(MemorySegment ofmt, MemorySegment ost, MemorySegment ist, int copy_tb) {
        var mh$ = avformat_transfer_internal_stream_timing_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_transfer_internal_stream_timing_info", ofmt, ost, ist, copy_tb);
            }
            return (int)mh$.invokeExact(ofmt, ost, ist, copy_tb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_codec_timebase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_stream_get_codec_timebase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_stream_get_codec_timebase$descriptor() {
        return av_stream_get_codec_timebase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MethodHandle av_stream_get_codec_timebase$handle() {
        return av_stream_get_codec_timebase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_codec_timebase$address() {
        return av_stream_get_codec_timebase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_codec_timebase(SegmentAllocator allocator, MemorySegment st) {
        var mh$ = av_stream_get_codec_timebase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_codec_timebase", allocator, st);
            }
            return (MemorySegment)mh$.invokeExact(allocator, st);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_bits_per_pixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_bits_per_pixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static FunctionDescriptor av_get_bits_per_pixel$descriptor() {
        return av_get_bits_per_pixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MethodHandle av_get_bits_per_pixel$handle() {
        return av_get_bits_per_pixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MemorySegment av_get_bits_per_pixel$address() {
        return av_get_bits_per_pixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static int av_get_bits_per_pixel(MemorySegment pixdesc) {
        var mh$ = av_get_bits_per_pixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_bits_per_pixel", pixdesc);
            }
            return (int)mh$.invokeExact(pixdesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_padded_bits_per_pixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_padded_bits_per_pixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static FunctionDescriptor av_get_padded_bits_per_pixel$descriptor() {
        return av_get_padded_bits_per_pixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MethodHandle av_get_padded_bits_per_pixel$handle() {
        return av_get_padded_bits_per_pixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MemorySegment av_get_padded_bits_per_pixel$address() {
        return av_get_padded_bits_per_pixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static int av_get_padded_bits_per_pixel(MemorySegment pixdesc) {
        var mh$ = av_get_padded_bits_per_pixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_padded_bits_per_pixel", pixdesc);
            }
            return (int)mh$.invokeExact(pixdesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_desc_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pix_fmt_desc_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_desc_get$descriptor() {
        return av_pix_fmt_desc_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_pix_fmt_desc_get$handle() {
        return av_pix_fmt_desc_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_get$address() {
        return av_pix_fmt_desc_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_get(int pix_fmt) {
        var mh$ = av_pix_fmt_desc_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_desc_get", pix_fmt);
            }
            return (MemorySegment)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_desc_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pix_fmt_desc_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_desc_next$descriptor() {
        return av_pix_fmt_desc_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static MethodHandle av_pix_fmt_desc_next$handle() {
        return av_pix_fmt_desc_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_next$address() {
        return av_pix_fmt_desc_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_next(MemorySegment prev) {
        var mh$ = av_pix_fmt_desc_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_desc_next", prev);
            }
            return (MemorySegment)mh$.invokeExact(prev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_desc_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pix_fmt_desc_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_desc_get_id$descriptor() {
        return av_pix_fmt_desc_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static MethodHandle av_pix_fmt_desc_get_id$handle() {
        return av_pix_fmt_desc_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_get_id$address() {
        return av_pix_fmt_desc_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static int av_pix_fmt_desc_get_id(MemorySegment desc) {
        var mh$ = av_pix_fmt_desc_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_desc_get_id", desc);
            }
            return (int)mh$.invokeExact(desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_get_chroma_sub_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pix_fmt_get_chroma_sub_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_get_chroma_sub_sample$descriptor() {
        return av_pix_fmt_get_chroma_sub_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static MethodHandle av_pix_fmt_get_chroma_sub_sample$handle() {
        return av_pix_fmt_get_chroma_sub_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static MemorySegment av_pix_fmt_get_chroma_sub_sample$address() {
        return av_pix_fmt_get_chroma_sub_sample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static int av_pix_fmt_get_chroma_sub_sample(int pix_fmt, MemorySegment h_shift, MemorySegment v_shift) {
        var mh$ = av_pix_fmt_get_chroma_sub_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_get_chroma_sub_sample", pix_fmt, h_shift, v_shift);
            }
            return (int)mh$.invokeExact(pix_fmt, h_shift, v_shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_count_planes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pix_fmt_count_planes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_count_planes$descriptor() {
        return av_pix_fmt_count_planes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_pix_fmt_count_planes$handle() {
        return av_pix_fmt_count_planes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_count_planes$address() {
        return av_pix_fmt_count_planes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int av_pix_fmt_count_planes(int pix_fmt) {
        var mh$ = av_pix_fmt_count_planes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_count_planes", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_range_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_range_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static FunctionDescriptor av_color_range_name$descriptor() {
        return av_color_range_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static MethodHandle av_color_range_name$handle() {
        return av_color_range_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static MemorySegment av_color_range_name$address() {
        return av_color_range_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static MemorySegment av_color_range_name(int range) {
        var mh$ = av_color_range_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_range_name", range);
            }
            return (MemorySegment)mh$.invokeExact(range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_range_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_range_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_range_from_name$descriptor() {
        return av_color_range_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_range_from_name$handle() {
        return av_color_range_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_range_from_name$address() {
        return av_color_range_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static int av_color_range_from_name(MemorySegment name) {
        var mh$ = av_color_range_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_range_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_primaries_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_primaries_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static FunctionDescriptor av_color_primaries_name$descriptor() {
        return av_color_primaries_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static MethodHandle av_color_primaries_name$handle() {
        return av_color_primaries_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static MemorySegment av_color_primaries_name$address() {
        return av_color_primaries_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static MemorySegment av_color_primaries_name(int primaries) {
        var mh$ = av_color_primaries_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_primaries_name", primaries);
            }
            return (MemorySegment)mh$.invokeExact(primaries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_primaries_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_primaries_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_primaries_from_name$descriptor() {
        return av_color_primaries_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_primaries_from_name$handle() {
        return av_color_primaries_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_primaries_from_name$address() {
        return av_color_primaries_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static int av_color_primaries_from_name(MemorySegment name) {
        var mh$ = av_color_primaries_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_primaries_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_transfer_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_transfer_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static FunctionDescriptor av_color_transfer_name$descriptor() {
        return av_color_transfer_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static MethodHandle av_color_transfer_name$handle() {
        return av_color_transfer_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static MemorySegment av_color_transfer_name$address() {
        return av_color_transfer_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static MemorySegment av_color_transfer_name(int transfer) {
        var mh$ = av_color_transfer_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_transfer_name", transfer);
            }
            return (MemorySegment)mh$.invokeExact(transfer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_transfer_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_transfer_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_transfer_from_name$descriptor() {
        return av_color_transfer_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_transfer_from_name$handle() {
        return av_color_transfer_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_transfer_from_name$address() {
        return av_color_transfer_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static int av_color_transfer_from_name(MemorySegment name) {
        var mh$ = av_color_transfer_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_transfer_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_space_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_space_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static FunctionDescriptor av_color_space_name$descriptor() {
        return av_color_space_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static MethodHandle av_color_space_name$handle() {
        return av_color_space_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static MemorySegment av_color_space_name$address() {
        return av_color_space_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static MemorySegment av_color_space_name(int space) {
        var mh$ = av_color_space_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_space_name", space);
            }
            return (MemorySegment)mh$.invokeExact(space);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_space_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_color_space_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_space_from_name$descriptor() {
        return av_color_space_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_space_from_name$handle() {
        return av_color_space_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_space_from_name$address() {
        return av_color_space_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static int av_color_space_from_name(MemorySegment name) {
        var mh$ = av_color_space_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_space_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_chroma_location_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_chroma_location_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static FunctionDescriptor av_chroma_location_name$descriptor() {
        return av_chroma_location_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static MethodHandle av_chroma_location_name$handle() {
        return av_chroma_location_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static MemorySegment av_chroma_location_name$address() {
        return av_chroma_location_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static MemorySegment av_chroma_location_name(int location) {
        var mh$ = av_chroma_location_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_chroma_location_name", location);
            }
            return (MemorySegment)mh$.invokeExact(location);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_chroma_location_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_chroma_location_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_chroma_location_from_name$descriptor() {
        return av_chroma_location_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static MethodHandle av_chroma_location_from_name$handle() {
        return av_chroma_location_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static MemorySegment av_chroma_location_from_name$address() {
        return av_chroma_location_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static int av_chroma_location_from_name(MemorySegment name) {
        var mh$ = av_chroma_location_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_chroma_location_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_pix_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt$descriptor() {
        return av_get_pix_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static MethodHandle av_get_pix_fmt$handle() {
        return av_get_pix_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static MemorySegment av_get_pix_fmt$address() {
        return av_get_pix_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static int av_get_pix_fmt(MemorySegment name) {
        var mh$ = av_get_pix_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_pix_fmt_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt_name$descriptor() {
        return av_get_pix_fmt_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_get_pix_fmt_name$handle() {
        return av_get_pix_fmt_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_name$address() {
        return av_get_pix_fmt_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_name(int pix_fmt) {
        var mh$ = av_get_pix_fmt_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt_name", pix_fmt);
            }
            return (MemorySegment)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_pix_fmt_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt_string$descriptor() {
        return av_get_pix_fmt_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_get_pix_fmt_string$handle() {
        return av_get_pix_fmt_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_string$address() {
        return av_get_pix_fmt_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_string(MemorySegment buf, int buf_size, int pix_fmt) {
        var mh$ = av_get_pix_fmt_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt_string", buf, buf_size, pix_fmt);
            }
            return (MemorySegment)mh$.invokeExact(buf, buf_size, pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_image_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_read_image_line2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static FunctionDescriptor av_read_image_line2$descriptor() {
        return av_read_image_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static MethodHandle av_read_image_line2$handle() {
        return av_read_image_line2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static MemorySegment av_read_image_line2$address() {
        return av_read_image_line2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static void av_read_image_line2(MemorySegment dst, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size) {
        var mh$ = av_read_image_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_image_line2", dst, data, linesize, desc, x, y, c, w, read_pal_component, dst_element_size);
            }
            mh$.invokeExact(dst, data, linesize, desc, x, y, c, w, read_pal_component, dst_element_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_image_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_read_image_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static FunctionDescriptor av_read_image_line$descriptor() {
        return av_read_image_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static MethodHandle av_read_image_line$handle() {
        return av_read_image_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static MemorySegment av_read_image_line$address() {
        return av_read_image_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static void av_read_image_line(MemorySegment dst, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w, int read_pal_component) {
        var mh$ = av_read_image_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_image_line", dst, data, linesize, desc, x, y, c, w, read_pal_component);
            }
            mh$.invokeExact(dst, data, linesize, desc, x, y, c, w, read_pal_component);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_image_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_write_image_line2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static FunctionDescriptor av_write_image_line2$descriptor() {
        return av_write_image_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static MethodHandle av_write_image_line2$handle() {
        return av_write_image_line2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static MemorySegment av_write_image_line2$address() {
        return av_write_image_line2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static void av_write_image_line2(MemorySegment src, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w, int src_element_size) {
        var mh$ = av_write_image_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_image_line2", src, data, linesize, desc, x, y, c, w, src_element_size);
            }
            mh$.invokeExact(src, data, linesize, desc, x, y, c, w, src_element_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_image_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_write_image_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static FunctionDescriptor av_write_image_line$descriptor() {
        return av_write_image_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static MethodHandle av_write_image_line$handle() {
        return av_write_image_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static MemorySegment av_write_image_line$address() {
        return av_write_image_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static void av_write_image_line(MemorySegment src, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w) {
        var mh$ = av_write_image_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_image_line", src, data, linesize, desc, x, y, c, w);
            }
            mh$.invokeExact(src, data, linesize, desc, x, y, c, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_swap_endianness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_pix_fmt_swap_endianness");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_swap_endianness$descriptor() {
        return av_pix_fmt_swap_endianness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_pix_fmt_swap_endianness$handle() {
        return av_pix_fmt_swap_endianness.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_swap_endianness$address() {
        return av_pix_fmt_swap_endianness.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int av_pix_fmt_swap_endianness(int pix_fmt) {
        var mh$ = av_pix_fmt_swap_endianness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_swap_endianness", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_pix_fmt_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt_loss$descriptor() {
        return av_get_pix_fmt_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static MethodHandle av_get_pix_fmt_loss$handle() {
        return av_get_pix_fmt_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static MemorySegment av_get_pix_fmt_loss$address() {
        return av_get_pix_fmt_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static int av_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha) {
        var mh$ = av_get_pix_fmt_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt_loss", dst_pix_fmt, src_pix_fmt, has_alpha);
            }
            return (int)mh$.invokeExact(dst_pix_fmt, src_pix_fmt, has_alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_best_pix_fmt_of_2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_find_best_pix_fmt_of_2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static FunctionDescriptor av_find_best_pix_fmt_of_2$descriptor() {
        return av_find_best_pix_fmt_of_2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MethodHandle av_find_best_pix_fmt_of_2$handle() {
        return av_find_best_pix_fmt_of_2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MemorySegment av_find_best_pix_fmt_of_2$address() {
        return av_find_best_pix_fmt_of_2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static int av_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, MemorySegment loss_ptr) {
        var mh$ = av_find_best_pix_fmt_of_2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_best_pix_fmt_of_2", dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr);
            }
            return (int)mh$.invokeExact(dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_max_pixsteps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_fill_max_pixsteps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static FunctionDescriptor av_image_fill_max_pixsteps$descriptor() {
        return av_image_fill_max_pixsteps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MethodHandle av_image_fill_max_pixsteps$handle() {
        return av_image_fill_max_pixsteps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MemorySegment av_image_fill_max_pixsteps$address() {
        return av_image_fill_max_pixsteps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static void av_image_fill_max_pixsteps(MemorySegment max_pixsteps, MemorySegment max_pixstep_comps, MemorySegment pixdesc) {
        var mh$ = av_image_fill_max_pixsteps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_max_pixsteps", max_pixsteps, max_pixstep_comps, pixdesc);
            }
            mh$.invokeExact(max_pixsteps, max_pixstep_comps, pixdesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_get_linesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_get_linesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static FunctionDescriptor av_image_get_linesize$descriptor() {
        return av_image_get_linesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static MethodHandle av_image_get_linesize$handle() {
        return av_image_get_linesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static MemorySegment av_image_get_linesize$address() {
        return av_image_get_linesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static int av_image_get_linesize(int pix_fmt, int width, int plane) {
        var mh$ = av_image_get_linesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_get_linesize", pix_fmt, width, plane);
            }
            return (int)mh$.invokeExact(pix_fmt, width, plane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_linesizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_fill_linesizes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static FunctionDescriptor av_image_fill_linesizes$descriptor() {
        return av_image_fill_linesizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static MethodHandle av_image_fill_linesizes$handle() {
        return av_image_fill_linesizes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static MemorySegment av_image_fill_linesizes$address() {
        return av_image_fill_linesizes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static int av_image_fill_linesizes(MemorySegment linesizes, int pix_fmt, int width) {
        var mh$ = av_image_fill_linesizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_linesizes", linesizes, pix_fmt, width);
            }
            return (int)mh$.invokeExact(linesizes, pix_fmt, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_plane_sizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_fill_plane_sizes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static FunctionDescriptor av_image_fill_plane_sizes$descriptor() {
        return av_image_fill_plane_sizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static MethodHandle av_image_fill_plane_sizes$handle() {
        return av_image_fill_plane_sizes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static MemorySegment av_image_fill_plane_sizes$address() {
        return av_image_fill_plane_sizes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static int av_image_fill_plane_sizes(MemorySegment size, int pix_fmt, int height, MemorySegment linesizes) {
        var mh$ = av_image_fill_plane_sizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_plane_sizes", size, pix_fmt, height, linesizes);
            }
            return (int)mh$.invokeExact(size, pix_fmt, height, linesizes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_fill_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static FunctionDescriptor av_image_fill_pointers$descriptor() {
        return av_image_fill_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static MethodHandle av_image_fill_pointers$handle() {
        return av_image_fill_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static MemorySegment av_image_fill_pointers$address() {
        return av_image_fill_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static int av_image_fill_pointers(MemorySegment data, int pix_fmt, int height, MemorySegment ptr, MemorySegment linesizes) {
        var mh$ = av_image_fill_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_pointers", data, pix_fmt, height, ptr, linesizes);
            }
            return (int)mh$.invokeExact(data, pix_fmt, height, ptr, linesizes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_image_alloc$descriptor() {
        return av_image_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static MethodHandle av_image_alloc$handle() {
        return av_image_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static MemorySegment av_image_alloc$address() {
        return av_image_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static int av_image_alloc(MemorySegment pointers, MemorySegment linesizes, int w, int h, int pix_fmt, int align) {
        var mh$ = av_image_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_alloc", pointers, linesizes, w, h, pix_fmt, align);
            }
            return (int)mh$.invokeExact(pointers, linesizes, w, h, pix_fmt, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_plane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_copy_plane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_plane$descriptor() {
        return av_image_copy_plane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static MethodHandle av_image_copy_plane$handle() {
        return av_image_copy_plane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static MemorySegment av_image_copy_plane$address() {
        return av_image_copy_plane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static void av_image_copy_plane(MemorySegment dst, int dst_linesize, MemorySegment src, int src_linesize, int bytewidth, int height) {
        var mh$ = av_image_copy_plane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_plane", dst, dst_linesize, src, src_linesize, bytewidth, height);
            }
            mh$.invokeExact(dst, dst_linesize, src, src_linesize, bytewidth, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_plane_uc_from {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_copy_plane_uc_from");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_plane_uc_from$descriptor() {
        return av_image_copy_plane_uc_from.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static MethodHandle av_image_copy_plane_uc_from$handle() {
        return av_image_copy_plane_uc_from.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static MemorySegment av_image_copy_plane_uc_from$address() {
        return av_image_copy_plane_uc_from.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static void av_image_copy_plane_uc_from(MemorySegment dst, long dst_linesize, MemorySegment src, long src_linesize, long bytewidth, int height) {
        var mh$ = av_image_copy_plane_uc_from.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_plane_uc_from", dst, dst_linesize, src, src_linesize, bytewidth, height);
            }
            mh$.invokeExact(dst, dst_linesize, src, src_linesize, bytewidth, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4], const uint8_t *src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy$descriptor() {
        return av_image_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4], const uint8_t *src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MethodHandle av_image_copy$handle() {
        return av_image_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4], const uint8_t *src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MemorySegment av_image_copy$address() {
        return av_image_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4], const uint8_t *src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static void av_image_copy(MemorySegment dst_data, MemorySegment dst_linesizes, MemorySegment src_data, MemorySegment src_linesizes, int pix_fmt, int width, int height) {
        var mh$ = av_image_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy", dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
            }
            mh$.invokeExact(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_uc_from {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_copy_uc_from");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_uc_from$descriptor() {
        return av_image_copy_uc_from.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MethodHandle av_image_copy_uc_from$handle() {
        return av_image_copy_uc_from.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MemorySegment av_image_copy_uc_from$address() {
        return av_image_copy_uc_from.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static void av_image_copy_uc_from(MemorySegment dst_data, MemorySegment dst_linesizes, MemorySegment src_data, MemorySegment src_linesizes, int pix_fmt, int width, int height) {
        var mh$ = av_image_copy_uc_from.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_uc_from", dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
            }
            mh$.invokeExact(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_arrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_fill_arrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_fill_arrays$descriptor() {
        return av_image_fill_arrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_fill_arrays$handle() {
        return av_image_fill_arrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_fill_arrays$address() {
        return av_image_fill_arrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_fill_arrays(MemorySegment dst_data, MemorySegment dst_linesize, MemorySegment src, int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_fill_arrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_arrays", dst_data, dst_linesize, src, pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, src, pix_fmt, width, height, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_get_buffer_size$descriptor() {
        return av_image_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_get_buffer_size$handle() {
        return av_image_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_get_buffer_size$address() {
        return av_image_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_get_buffer_size(int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_get_buffer_size", pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(pix_fmt, width, height, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_copy_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_copy_to_buffer$descriptor() {
        return av_image_copy_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_copy_to_buffer$handle() {
        return av_image_copy_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_copy_to_buffer$address() {
        return av_image_copy_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_copy_to_buffer(MemorySegment dst, int dst_size, MemorySegment src_data, MemorySegment src_linesize, int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_copy_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_to_buffer", dst, dst_size, src_data, src_linesize, pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(dst, dst_size, src_data, src_linesize, pix_fmt, width, height, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_check_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static FunctionDescriptor av_image_check_size$descriptor() {
        return av_image_check_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static MethodHandle av_image_check_size$handle() {
        return av_image_check_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static MemorySegment av_image_check_size$address() {
        return av_image_check_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static int av_image_check_size(int w, int h, int log_offset, MemorySegment log_ctx) {
        var mh$ = av_image_check_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_size", w, h, log_offset, log_ctx);
            }
            return (int)mh$.invokeExact(w, h, log_offset, log_ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_size2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_check_size2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static FunctionDescriptor av_image_check_size2$descriptor() {
        return av_image_check_size2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static MethodHandle av_image_check_size2$handle() {
        return av_image_check_size2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static MemorySegment av_image_check_size2$address() {
        return av_image_check_size2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static int av_image_check_size2(int w, int h, long max_pixels, int pix_fmt, int log_offset, MemorySegment log_ctx) {
        var mh$ = av_image_check_size2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_size2", w, h, max_pixels, pix_fmt, log_offset, log_ctx);
            }
            return (int)mh$.invokeExact(w, h, max_pixels, pix_fmt, log_offset, log_ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_sar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_check_sar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static FunctionDescriptor av_image_check_sar$descriptor() {
        return av_image_check_sar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static MethodHandle av_image_check_sar$handle() {
        return av_image_check_sar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static MemorySegment av_image_check_sar$address() {
        return av_image_check_sar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static int av_image_check_sar(int w, int h, MemorySegment sar) {
        var mh$ = av_image_check_sar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_sar", w, h, sar);
            }
            return (int)mh$.invokeExact(w, h, sar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_black {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_image_fill_black");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_fill_black$descriptor() {
        return av_image_fill_black.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static MethodHandle av_image_fill_black$handle() {
        return av_image_fill_black.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static MemorySegment av_image_fill_black$address() {
        return av_image_fill_black.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static int av_image_fill_black(MemorySegment dst_data, MemorySegment dst_linesize, int pix_fmt, int range, int width, int height) {
        var mh$ = av_image_fill_black.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_black", dst_data, dst_linesize, pix_fmt, range, width, height);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, pix_fmt, range, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("swscale_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static FunctionDescriptor swscale_version$descriptor() {
        return swscale_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static MethodHandle swscale_version$handle() {
        return swscale_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static MemorySegment swscale_version$address() {
        return swscale_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static int swscale_version() {
        var mh$ = swscale_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("swscale_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static FunctionDescriptor swscale_configuration$descriptor() {
        return swscale_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MethodHandle swscale_configuration$handle() {
        return swscale_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MemorySegment swscale_configuration$address() {
        return swscale_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MemorySegment swscale_configuration() {
        var mh$ = swscale_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("swscale_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static FunctionDescriptor swscale_license$descriptor() {
        return swscale_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MethodHandle swscale_license$handle() {
        return swscale_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MemorySegment swscale_license$address() {
        return swscale_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MemorySegment swscale_license() {
        var mh$ = swscale_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getCoefficients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_getCoefficients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static FunctionDescriptor sws_getCoefficients$descriptor() {
        return sws_getCoefficients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MethodHandle sws_getCoefficients$handle() {
        return sws_getCoefficients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MemorySegment sws_getCoefficients$address() {
        return sws_getCoefficients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MemorySegment sws_getCoefficients(int colorspace) {
        var mh$ = sws_getCoefficients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getCoefficients", colorspace);
            }
            return (MemorySegment)mh$.invokeExact(colorspace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_isSupportedInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedInput$descriptor() {
        return sws_isSupportedInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedInput$handle() {
        return sws_isSupportedInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedInput$address() {
        return sws_isSupportedInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedInput(int pix_fmt) {
        var mh$ = sws_isSupportedInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedInput", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedOutput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_isSupportedOutput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedOutput$descriptor() {
        return sws_isSupportedOutput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedOutput$handle() {
        return sws_isSupportedOutput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedOutput$address() {
        return sws_isSupportedOutput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedOutput(int pix_fmt) {
        var mh$ = sws_isSupportedOutput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedOutput", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedEndiannessConversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_isSupportedEndiannessConversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedEndiannessConversion$descriptor() {
        return sws_isSupportedEndiannessConversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedEndiannessConversion$handle() {
        return sws_isSupportedEndiannessConversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedEndiannessConversion$address() {
        return sws_isSupportedEndiannessConversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedEndiannessConversion(int pix_fmt) {
        var mh$ = sws_isSupportedEndiannessConversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedEndiannessConversion", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct SwsContext *sws_alloc_context()
     * }
     */
    public static FunctionDescriptor sws_alloc_context$descriptor() {
        return sws_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct SwsContext *sws_alloc_context()
     * }
     */
    public static MethodHandle sws_alloc_context$handle() {
        return sws_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct SwsContext *sws_alloc_context()
     * }
     */
    public static MemorySegment sws_alloc_context$address() {
        return sws_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct SwsContext *sws_alloc_context()
     * }
     */
    public static MemorySegment sws_alloc_context() {
        var mh$ = sws_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_alloc_context");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_init_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_init_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_init_context(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static FunctionDescriptor sws_init_context$descriptor() {
        return sws_init_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_init_context(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static MethodHandle sws_init_context$handle() {
        return sws_init_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_init_context(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static MemorySegment sws_init_context$address() {
        return sws_init_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_init_context(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static int sws_init_context(MemorySegment sws_context, MemorySegment srcFilter, MemorySegment dstFilter) {
        var mh$ = sws_init_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_init_context", sws_context, srcFilter, dstFilter);
            }
            return (int)mh$.invokeExact(sws_context, srcFilter, dstFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_freeContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeContext(struct SwsContext *swsContext)
     * }
     */
    public static FunctionDescriptor sws_freeContext$descriptor() {
        return sws_freeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeContext(struct SwsContext *swsContext)
     * }
     */
    public static MethodHandle sws_freeContext$handle() {
        return sws_freeContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeContext(struct SwsContext *swsContext)
     * }
     */
    public static MemorySegment sws_freeContext$address() {
        return sws_freeContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeContext(struct SwsContext *swsContext)
     * }
     */
    public static void sws_freeContext(MemorySegment swsContext) {
        var mh$ = sws_freeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeContext", swsContext);
            }
            mh$.invokeExact(swsContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_getContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static FunctionDescriptor sws_getContext$descriptor() {
        return sws_getContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MethodHandle sws_getContext$handle() {
        return sws_getContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getContext$address() {
        return sws_getContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, MemorySegment srcFilter, MemorySegment dstFilter, MemorySegment param) {
        var mh$ = sws_getContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getContext", srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
            }
            return (MemorySegment)mh$.invokeExact(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static FunctionDescriptor sws_scale$descriptor() {
        return sws_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static MethodHandle sws_scale$handle() {
        return sws_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static MemorySegment sws_scale$address() {
        return sws_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static int sws_scale(MemorySegment c, MemorySegment srcSlice, MemorySegment srcStride, int srcSliceY, int srcSliceH, MemorySegment dst, MemorySegment dstStride) {
        var mh$ = sws_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scale", c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride);
            }
            return (int)mh$.invokeExact(c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scale_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_scale_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_scale_frame(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_scale_frame$descriptor() {
        return sws_scale_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_scale_frame(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_scale_frame$handle() {
        return sws_scale_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_scale_frame(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_scale_frame$address() {
        return sws_scale_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_scale_frame(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_scale_frame(MemorySegment c, MemorySegment dst, MemorySegment src) {
        var mh$ = sws_scale_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scale_frame", c, dst, src);
            }
            return (int)mh$.invokeExact(c, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_frame_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_frame_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_frame_start(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_frame_start$descriptor() {
        return sws_frame_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_frame_start(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_frame_start$handle() {
        return sws_frame_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_frame_start(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_frame_start$address() {
        return sws_frame_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_frame_start(struct SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_frame_start(MemorySegment c, MemorySegment dst, MemorySegment src) {
        var mh$ = sws_frame_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_frame_start", c, dst, src);
            }
            return (int)mh$.invokeExact(c, dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_frame_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_frame_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_frame_end(struct SwsContext *c)
     * }
     */
    public static FunctionDescriptor sws_frame_end$descriptor() {
        return sws_frame_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_frame_end(struct SwsContext *c)
     * }
     */
    public static MethodHandle sws_frame_end$handle() {
        return sws_frame_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_frame_end(struct SwsContext *c)
     * }
     */
    public static MemorySegment sws_frame_end$address() {
        return sws_frame_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_frame_end(struct SwsContext *c)
     * }
     */
    public static void sws_frame_end(MemorySegment c) {
        var mh$ = sws_frame_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_frame_end", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_send_slice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_send_slice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_send_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static FunctionDescriptor sws_send_slice$descriptor() {
        return sws_send_slice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_send_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MethodHandle sws_send_slice$handle() {
        return sws_send_slice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_send_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MemorySegment sws_send_slice$address() {
        return sws_send_slice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_send_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static int sws_send_slice(MemorySegment c, int slice_start, int slice_height) {
        var mh$ = sws_send_slice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_send_slice", c, slice_start, slice_height);
            }
            return (int)mh$.invokeExact(c, slice_start, slice_height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_receive_slice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_receive_slice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_receive_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static FunctionDescriptor sws_receive_slice$descriptor() {
        return sws_receive_slice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_receive_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MethodHandle sws_receive_slice$handle() {
        return sws_receive_slice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_receive_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MemorySegment sws_receive_slice$address() {
        return sws_receive_slice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_receive_slice(struct SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static int sws_receive_slice(MemorySegment c, int slice_start, int slice_height) {
        var mh$ = sws_receive_slice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_receive_slice", c, slice_start, slice_height);
            }
            return (int)mh$.invokeExact(c, slice_start, slice_height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_receive_slice_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_receive_slice_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const struct SwsContext *c)
     * }
     */
    public static FunctionDescriptor sws_receive_slice_alignment$descriptor() {
        return sws_receive_slice_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const struct SwsContext *c)
     * }
     */
    public static MethodHandle sws_receive_slice_alignment$handle() {
        return sws_receive_slice_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const struct SwsContext *c)
     * }
     */
    public static MemorySegment sws_receive_slice_alignment$address() {
        return sws_receive_slice_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const struct SwsContext *c)
     * }
     */
    public static int sws_receive_slice_alignment(MemorySegment c) {
        var mh$ = sws_receive_slice_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_receive_slice_alignment", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_setColorspaceDetails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_setColorspaceDetails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static FunctionDescriptor sws_setColorspaceDetails$descriptor() {
        return sws_setColorspaceDetails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static MethodHandle sws_setColorspaceDetails$handle() {
        return sws_setColorspaceDetails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static MemorySegment sws_setColorspaceDetails$address() {
        return sws_setColorspaceDetails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static int sws_setColorspaceDetails(MemorySegment c, MemorySegment inv_table, int srcRange, MemorySegment table, int dstRange, int brightness, int contrast, int saturation) {
        var mh$ = sws_setColorspaceDetails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_setColorspaceDetails", c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
            }
            return (int)mh$.invokeExact(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getColorspaceDetails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_getColorspaceDetails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static FunctionDescriptor sws_getColorspaceDetails$descriptor() {
        return sws_getColorspaceDetails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static MethodHandle sws_getColorspaceDetails$handle() {
        return sws_getColorspaceDetails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static MemorySegment sws_getColorspaceDetails$address() {
        return sws_getColorspaceDetails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static int sws_getColorspaceDetails(MemorySegment c, MemorySegment inv_table, MemorySegment srcRange, MemorySegment table, MemorySegment dstRange, MemorySegment brightness, MemorySegment contrast, MemorySegment saturation) {
        var mh$ = sws_getColorspaceDetails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getColorspaceDetails", c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
            }
            return (int)mh$.invokeExact(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_allocVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_allocVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static FunctionDescriptor sws_allocVec$descriptor() {
        return sws_allocVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MethodHandle sws_allocVec$handle() {
        return sws_allocVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MemorySegment sws_allocVec$address() {
        return sws_allocVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MemorySegment sws_allocVec(int length) {
        var mh$ = sws_allocVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_allocVec", length);
            }
            return (MemorySegment)mh$.invokeExact(length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getGaussianVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_getGaussianVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static FunctionDescriptor sws_getGaussianVec$descriptor() {
        return sws_getGaussianVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MethodHandle sws_getGaussianVec$handle() {
        return sws_getGaussianVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MemorySegment sws_getGaussianVec$address() {
        return sws_getGaussianVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MemorySegment sws_getGaussianVec(double variance, double quality) {
        var mh$ = sws_getGaussianVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getGaussianVec", variance, quality);
            }
            return (MemorySegment)mh$.invokeExact(variance, quality);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scaleVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_scaleVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static FunctionDescriptor sws_scaleVec$descriptor() {
        return sws_scaleVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static MethodHandle sws_scaleVec$handle() {
        return sws_scaleVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static MemorySegment sws_scaleVec$address() {
        return sws_scaleVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static void sws_scaleVec(MemorySegment a, double scalar) {
        var mh$ = sws_scaleVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scaleVec", a, scalar);
            }
            mh$.invokeExact(a, scalar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_normalizeVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_normalizeVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static FunctionDescriptor sws_normalizeVec$descriptor() {
        return sws_normalizeVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static MethodHandle sws_normalizeVec$handle() {
        return sws_normalizeVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static MemorySegment sws_normalizeVec$address() {
        return sws_normalizeVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static void sws_normalizeVec(MemorySegment a, double height) {
        var mh$ = sws_normalizeVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_normalizeVec", a, height);
            }
            mh$.invokeExact(a, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_freeVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static FunctionDescriptor sws_freeVec$descriptor() {
        return sws_freeVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static MethodHandle sws_freeVec$handle() {
        return sws_freeVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static MemorySegment sws_freeVec$address() {
        return sws_freeVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static void sws_freeVec(MemorySegment a) {
        var mh$ = sws_freeVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeVec", a);
            }
            mh$.invokeExact(a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getDefaultFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_getDefaultFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static FunctionDescriptor sws_getDefaultFilter$descriptor() {
        return sws_getDefaultFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MethodHandle sws_getDefaultFilter$handle() {
        return sws_getDefaultFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MemorySegment sws_getDefaultFilter$address() {
        return sws_getDefaultFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MemorySegment sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose) {
        var mh$ = sws_getDefaultFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getDefaultFilter", lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose);
            }
            return (MemorySegment)mh$.invokeExact(lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_freeFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static FunctionDescriptor sws_freeFilter$descriptor() {
        return sws_freeFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static MethodHandle sws_freeFilter$handle() {
        return sws_freeFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static MemorySegment sws_freeFilter$address() {
        return sws_freeFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static void sws_freeFilter(MemorySegment filter) {
        var mh$ = sws_freeFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeFilter", filter);
            }
            mh$.invokeExact(filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getCachedContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_getCachedContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct SwsContext *sws_getCachedContext(struct SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static FunctionDescriptor sws_getCachedContext$descriptor() {
        return sws_getCachedContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct SwsContext *sws_getCachedContext(struct SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MethodHandle sws_getCachedContext$handle() {
        return sws_getCachedContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct SwsContext *sws_getCachedContext(struct SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getCachedContext$address() {
        return sws_getCachedContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct SwsContext *sws_getCachedContext(struct SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getCachedContext(MemorySegment context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, MemorySegment srcFilter, MemorySegment dstFilter, MemorySegment param) {
        var mh$ = sws_getCachedContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getCachedContext", context, srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
            }
            return (MemorySegment)mh$.invokeExact(context, srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_convertPalette8ToPacked32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_convertPalette8ToPacked32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static FunctionDescriptor sws_convertPalette8ToPacked32$descriptor() {
        return sws_convertPalette8ToPacked32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MethodHandle sws_convertPalette8ToPacked32$handle() {
        return sws_convertPalette8ToPacked32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MemorySegment sws_convertPalette8ToPacked32$address() {
        return sws_convertPalette8ToPacked32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static void sws_convertPalette8ToPacked32(MemorySegment src, MemorySegment dst, int num_pixels, MemorySegment palette) {
        var mh$ = sws_convertPalette8ToPacked32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_convertPalette8ToPacked32", src, dst, num_pixels, palette);
            }
            mh$.invokeExact(src, dst, num_pixels, palette);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_convertPalette8ToPacked24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_convertPalette8ToPacked24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static FunctionDescriptor sws_convertPalette8ToPacked24$descriptor() {
        return sws_convertPalette8ToPacked24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MethodHandle sws_convertPalette8ToPacked24$handle() {
        return sws_convertPalette8ToPacked24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MemorySegment sws_convertPalette8ToPacked24$address() {
        return sws_convertPalette8ToPacked24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static void sws_convertPalette8ToPacked24(MemorySegment src, MemorySegment dst, int num_pixels, MemorySegment palette) {
        var mh$ = sws_convertPalette8ToPacked24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_convertPalette8ToPacked24", src, dst, num_pixels, palette);
            }
            mh$.invokeExact(src, dst, num_pixels, palette);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sws_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static FunctionDescriptor sws_get_class$descriptor() {
        return sws_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MethodHandle sws_get_class$handle() {
        return sws_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MemorySegment sws_get_class$address() {
        return sws_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MemorySegment sws_get_class() {
        var mh$ = sws_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
}

