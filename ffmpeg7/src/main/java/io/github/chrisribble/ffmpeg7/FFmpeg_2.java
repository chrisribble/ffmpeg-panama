// Generated by jextract

package io.github.chrisribble.ffmpeg7;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class FFmpeg_2 extends FFmpeg_3 {

    FFmpeg_2() {
        // Should not be called directly
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double __x)
     * }
     */
    public static double exp(double __x) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static FunctionDescriptor __exp$descriptor() {
        return __exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static MethodHandle __exp$handle() {
        return __exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static MemorySegment __exp$address() {
        return __exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp(double __x)
     * }
     */
    public static double __exp(double __x) {
        var mh$ = __exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double __x, int *__exponent)
     * }
     */
    public static double frexp(double __x, MemorySegment __exponent) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor __frexp$descriptor() {
        return __frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static MethodHandle __frexp$handle() {
        return __frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static MemorySegment __frexp$address() {
        return __frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __frexp(double __x, int *__exponent)
     * }
     */
    public static double __frexp(double __x, MemorySegment __exponent) {
        var mh$ = __frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__frexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double __x, int __exponent)
     * }
     */
    public static double ldexp(double __x, int __exponent) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static FunctionDescriptor __ldexp$descriptor() {
        return __ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static MethodHandle __ldexp$handle() {
        return __ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static MemorySegment __ldexp$address() {
        return __ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __ldexp(double __x, int __exponent)
     * }
     */
    public static double __ldexp(double __x, int __exponent) {
        var mh$ = __ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ldexp", __x, __exponent);
            }
            return (double)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double __x)
     * }
     */
    public static double log(double __x) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static FunctionDescriptor __log$descriptor() {
        return __log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static MethodHandle __log$handle() {
        return __log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static MemorySegment __log$address() {
        return __log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log(double __x)
     * }
     */
    public static double __log(double __x) {
        var mh$ = __log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double __x)
     * }
     */
    public static double log10(double __x) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static FunctionDescriptor __log10$descriptor() {
        return __log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static MethodHandle __log10$handle() {
        return __log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static MemorySegment __log10$address() {
        return __log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log10(double __x)
     * }
     */
    public static double __log10(double __x) {
        var mh$ = __log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log10", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double __x, double *__iptr)
     * }
     */
    public static double modf(double __x, MemorySegment __iptr) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", __x, __iptr);
            }
            return (double)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static FunctionDescriptor __modf$descriptor() {
        return __modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static MethodHandle __modf$handle() {
        return __modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static MemorySegment __modf$address() {
        return __modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __modf(double __x, double *__iptr)
     * }
     */
    public static double __modf(double __x, MemorySegment __iptr) {
        var mh$ = __modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__modf", __x, __iptr);
            }
            return (double)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double __x)
     * }
     */
    public static double expm1(double __x) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static FunctionDescriptor __expm1$descriptor() {
        return __expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static MethodHandle __expm1$handle() {
        return __expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static MemorySegment __expm1$address() {
        return __expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __expm1(double __x)
     * }
     */
    public static double __expm1(double __x) {
        var mh$ = __expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expm1", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double __x)
     * }
     */
    public static double log1p(double __x) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static FunctionDescriptor __log1p$descriptor() {
        return __log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static MethodHandle __log1p$handle() {
        return __log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static MemorySegment __log1p$address() {
        return __log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log1p(double __x)
     * }
     */
    public static double __log1p(double __x) {
        var mh$ = __log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log1p", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double __x)
     * }
     */
    public static double logb(double __x) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static FunctionDescriptor __logb$descriptor() {
        return __logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static MethodHandle __logb$handle() {
        return __logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static MemorySegment __logb$address() {
        return __logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __logb(double __x)
     * }
     */
    public static double __logb(double __x) {
        var mh$ = __logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logb", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double __x)
     * }
     */
    public static double exp2(double __x) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static FunctionDescriptor __exp2$descriptor() {
        return __exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static MethodHandle __exp2$handle() {
        return __exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static MemorySegment __exp2$address() {
        return __exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp2(double __x)
     * }
     */
    public static double __exp2(double __x) {
        var mh$ = __exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double __x)
     * }
     */
    public static double log2(double __x) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static FunctionDescriptor __log2$descriptor() {
        return __log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static MethodHandle __log2$handle() {
        return __log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static MemorySegment __log2$address() {
        return __log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __log2(double __x)
     * }
     */
    public static double __log2(double __x) {
        var mh$ = __log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log2", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double __x, double __y)
     * }
     */
    public static double pow(double __x, double __y) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __pow$descriptor() {
        return __pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static MethodHandle __pow$handle() {
        return __pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static MemorySegment __pow$address() {
        return __pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __pow(double __x, double __y)
     * }
     */
    public static double __pow(double __x, double __y) {
        var mh$ = __pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__pow", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double __x)
     * }
     */
    public static double sqrt(double __x) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static FunctionDescriptor __sqrt$descriptor() {
        return __sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static MethodHandle __sqrt$handle() {
        return __sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static MemorySegment __sqrt$address() {
        return __sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sqrt(double __x)
     * }
     */
    public static double __sqrt(double __x) {
        var mh$ = __sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sqrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double __x, double __y)
     * }
     */
    public static double hypot(double __x, double __y) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __hypot$descriptor() {
        return __hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static MethodHandle __hypot$handle() {
        return __hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static MemorySegment __hypot$address() {
        return __hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __hypot(double __x, double __y)
     * }
     */
    public static double __hypot(double __x, double __y) {
        var mh$ = __hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__hypot", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double __x)
     * }
     */
    public static double cbrt(double __x) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static FunctionDescriptor __cbrt$descriptor() {
        return __cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static MethodHandle __cbrt$handle() {
        return __cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static MemorySegment __cbrt$address() {
        return __cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cbrt(double __x)
     * }
     */
    public static double __cbrt(double __x) {
        var mh$ = __cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cbrt", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double __x)
     * }
     */
    public static double ceil(double __x) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static FunctionDescriptor __ceil$descriptor() {
        return __ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static MethodHandle __ceil$handle() {
        return __ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static MemorySegment __ceil$address() {
        return __ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __ceil(double __x)
     * }
     */
    public static double __ceil(double __x) {
        var mh$ = __ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ceil", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double __x)
     * }
     */
    public static double fabs(double __x) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static FunctionDescriptor __fabs$descriptor() {
        return __fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static MethodHandle __fabs$handle() {
        return __fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static MemorySegment __fabs$address() {
        return __fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fabs(double __x)
     * }
     */
    public static double __fabs(double __x) {
        var mh$ = __fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fabs", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double __x)
     * }
     */
    public static double floor(double __x) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static FunctionDescriptor __floor$descriptor() {
        return __floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static MethodHandle __floor$handle() {
        return __floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static MemorySegment __floor$address() {
        return __floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __floor(double __x)
     * }
     */
    public static double __floor(double __x) {
        var mh$ = __floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__floor", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double __x, double __y)
     * }
     */
    public static double fmod(double __x, double __y) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmod$descriptor() {
        return __fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static MethodHandle __fmod$handle() {
        return __fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static MemorySegment __fmod$address() {
        return __fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fmod(double __x, double __y)
     * }
     */
    public static double __fmod(double __x, double __y) {
        var mh$ = __fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmod", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("isinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static FunctionDescriptor isinf$descriptor() {
        return isinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static MethodHandle isinf$handle() {
        return isinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static MemorySegment isinf$address() {
        return isinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isinf(double __value)
     * }
     */
    public static int isinf(double __value) {
        var mh$ = isinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isinf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class finite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("finite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static FunctionDescriptor finite$descriptor() {
        return finite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static MethodHandle finite$handle() {
        return finite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static MemorySegment finite$address() {
        return finite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int finite(double __value)
     * }
     */
    public static int finite(double __value) {
        var mh$ = finite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("finite", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("drem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static FunctionDescriptor drem$descriptor() {
        return drem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static MethodHandle drem$handle() {
        return drem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static MemorySegment drem$address() {
        return drem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drem(double __x, double __y)
     * }
     */
    public static double drem(double __x, double __y) {
        var mh$ = drem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drem", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __drem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__drem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __drem$descriptor() {
        return __drem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static MethodHandle __drem$handle() {
        return __drem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static MemorySegment __drem$address() {
        return __drem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __drem(double __x, double __y)
     * }
     */
    public static double __drem(double __x, double __y) {
        var mh$ = __drem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__drem", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class significand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("significand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static FunctionDescriptor significand$descriptor() {
        return significand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static MethodHandle significand$handle() {
        return significand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static MemorySegment significand$address() {
        return significand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double significand(double __x)
     * }
     */
    public static double significand(double __x) {
        var mh$ = significand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("significand", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __significand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__significand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static FunctionDescriptor __significand$descriptor() {
        return __significand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static MethodHandle __significand$handle() {
        return __significand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static MemorySegment __significand$address() {
        return __significand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __significand(double __x)
     * }
     */
    public static double __significand(double __x) {
        var mh$ = __significand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__significand", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double __x, double __y)
     * }
     */
    public static double copysign(double __x, double __y) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __copysign$descriptor() {
        return __copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static MethodHandle __copysign$handle() {
        return __copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static MemorySegment __copysign$address() {
        return __copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __copysign(double __x, double __y)
     * }
     */
    public static double __copysign(double __x, double __y) {
        var mh$ = __copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__copysign", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *__tagb)
     * }
     */
    public static double nan(MemorySegment __tagb) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", __tagb);
            }
            return (double)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static FunctionDescriptor __nan$descriptor() {
        return __nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static MethodHandle __nan$handle() {
        return __nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static MemorySegment __nan$address() {
        return __nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nan(const char *__tagb)
     * }
     */
    public static double __nan(MemorySegment __tagb) {
        var mh$ = __nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nan", __tagb);
            }
            return (double)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isnan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("isnan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static FunctionDescriptor isnan$descriptor() {
        return isnan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static MethodHandle isnan$handle() {
        return isnan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static MemorySegment isnan$address() {
        return isnan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isnan(double __value)
     * }
     */
    public static int isnan(double __value) {
        var mh$ = isnan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isnan", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static FunctionDescriptor __j0$descriptor() {
        return __j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static MethodHandle __j0$handle() {
        return __j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static MemorySegment __j0$address() {
        return __j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __j0(double)
     * }
     */
    public static double __j0(double x0) {
        var mh$ = __j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static FunctionDescriptor __j1$descriptor() {
        return __j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static MethodHandle __j1$handle() {
        return __j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static MemorySegment __j1$address() {
        return __j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __j1(double)
     * }
     */
    public static double __j1(double x0) {
        var mh$ = __j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static FunctionDescriptor __jn$descriptor() {
        return __jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static MethodHandle __jn$handle() {
        return __jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static MemorySegment __jn$address() {
        return __jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __jn(int, double)
     * }
     */
    public static double __jn(int x0, double x1) {
        var mh$ = __jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static FunctionDescriptor __y0$descriptor() {
        return __y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static MethodHandle __y0$handle() {
        return __y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static MemorySegment __y0$address() {
        return __y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __y0(double)
     * }
     */
    public static double __y0(double x0) {
        var mh$ = __y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static FunctionDescriptor __y1$descriptor() {
        return __y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static MethodHandle __y1$handle() {
        return __y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static MemorySegment __y1$address() {
        return __y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __y1(double)
     * }
     */
    public static double __y1(double x0) {
        var mh$ = __y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static FunctionDescriptor __yn$descriptor() {
        return __yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static MethodHandle __yn$handle() {
        return __yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static MemorySegment __yn$address() {
        return __yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __yn(int, double)
     * }
     */
    public static double __yn(int x0, double x1) {
        var mh$ = __yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static FunctionDescriptor __erf$descriptor() {
        return __erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static MethodHandle __erf$handle() {
        return __erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static MemorySegment __erf$address() {
        return __erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __erf(double)
     * }
     */
    public static double __erf(double x0) {
        var mh$ = __erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static FunctionDescriptor __erfc$descriptor() {
        return __erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static MethodHandle __erfc$handle() {
        return __erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static MemorySegment __erfc$address() {
        return __erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __erfc(double)
     * }
     */
    public static double __erfc(double x0) {
        var mh$ = __erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static FunctionDescriptor __lgamma$descriptor() {
        return __lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static MethodHandle __lgamma$handle() {
        return __lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static MemorySegment __lgamma$address() {
        return __lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __lgamma(double)
     * }
     */
    public static double __lgamma(double x0) {
        var mh$ = __lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static FunctionDescriptor __tgamma$descriptor() {
        return __tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static MethodHandle __tgamma$handle() {
        return __tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static MemorySegment __tgamma$address() {
        return __tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tgamma(double)
     * }
     */
    public static double __tgamma(double x0) {
        var mh$ = __tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("gamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static FunctionDescriptor gamma$descriptor() {
        return gamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static MethodHandle gamma$handle() {
        return gamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static MemorySegment gamma$address() {
        return gamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double gamma(double)
     * }
     */
    public static double gamma(double x0) {
        var mh$ = gamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__gamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static FunctionDescriptor __gamma$descriptor() {
        return __gamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static MethodHandle __gamma$handle() {
        return __gamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static MemorySegment __gamma$address() {
        return __gamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __gamma(double)
     * }
     */
    public static double __gamma(double x0) {
        var mh$ = __gamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static FunctionDescriptor lgamma_r$descriptor() {
        return lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static MethodHandle lgamma_r$handle() {
        return lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static MemorySegment lgamma_r$address() {
        return lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *__signgamp)
     * }
     */
    public static double lgamma_r(double x0, MemorySegment __signgamp) {
        var mh$ = lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma_r", x0, __signgamp);
            }
            return (double)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static FunctionDescriptor __lgamma_r$descriptor() {
        return __lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static MethodHandle __lgamma_r$handle() {
        return __lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static MemorySegment __lgamma_r$address() {
        return __lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __lgamma_r(double, int *__signgamp)
     * }
     */
    public static double __lgamma_r(double x0, MemorySegment __signgamp) {
        var mh$ = __lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgamma_r", x0, __signgamp);
            }
            return (double)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double __x)
     * }
     */
    public static double rint(double __x) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static FunctionDescriptor __rint$descriptor() {
        return __rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static MethodHandle __rint$handle() {
        return __rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static MemorySegment __rint$address() {
        return __rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __rint(double __x)
     * }
     */
    public static double __rint(double __x) {
        var mh$ = __rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__rint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double __x, double __y)
     * }
     */
    public static double nextafter(double __x, double __y) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __nextafter$descriptor() {
        return __nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static MethodHandle __nextafter$handle() {
        return __nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static MemorySegment __nextafter$address() {
        return __nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nextafter(double __x, double __y)
     * }
     */
    public static double __nextafter(double __x, double __y) {
        var mh$ = __nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nextafter", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double __x, double __y)
     * }
     */
    public static double remainder(double __x, double __y) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __remainder$descriptor() {
        return __remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static MethodHandle __remainder$handle() {
        return __remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static MemorySegment __remainder$address() {
        return __remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __remainder(double __x, double __y)
     * }
     */
    public static double __remainder(double __x, double __y) {
        var mh$ = __remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remainder", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double __x, int __n)
     * }
     */
    public static double scalbn(double __x, int __n) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static FunctionDescriptor __scalbn$descriptor() {
        return __scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static MethodHandle __scalbn$handle() {
        return __scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static MemorySegment __scalbn$address() {
        return __scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalbn(double __x, int __n)
     * }
     */
    public static double __scalbn(double __x, int __n) {
        var mh$ = __scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbn", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double __x)
     * }
     */
    public static int ilogb(double __x) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static FunctionDescriptor __ilogb$descriptor() {
        return __ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static MethodHandle __ilogb$handle() {
        return __ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static MemorySegment __ilogb$address() {
        return __ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __ilogb(double __x)
     * }
     */
    public static int __ilogb(double __x) {
        var mh$ = __ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ilogb", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double __x, long __n)
     * }
     */
    public static double scalbln(double __x, long __n) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static FunctionDescriptor __scalbln$descriptor() {
        return __scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static MethodHandle __scalbln$handle() {
        return __scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static MemorySegment __scalbln$address() {
        return __scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalbln(double __x, long __n)
     * }
     */
    public static double __scalbln(double __x, long __n) {
        var mh$ = __scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbln", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double __x)
     * }
     */
    public static double nearbyint(double __x) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static FunctionDescriptor __nearbyint$descriptor() {
        return __nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static MethodHandle __nearbyint$handle() {
        return __nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static MemorySegment __nearbyint$address() {
        return __nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __nearbyint(double __x)
     * }
     */
    public static double __nearbyint(double __x) {
        var mh$ = __nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nearbyint", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double __x)
     * }
     */
    public static double round(double __x) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static FunctionDescriptor __round$descriptor() {
        return __round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static MethodHandle __round$handle() {
        return __round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static MemorySegment __round$address() {
        return __round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __round(double __x)
     * }
     */
    public static double __round(double __x) {
        var mh$ = __round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__round", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double __x)
     * }
     */
    public static double trunc(double __x) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static FunctionDescriptor __trunc$descriptor() {
        return __trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static MethodHandle __trunc$handle() {
        return __trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static MemorySegment __trunc$address() {
        return __trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __trunc(double __x)
     * }
     */
    public static double __trunc(double __x) {
        var mh$ = __trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__trunc", __x);
            }
            return (double)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double __x, double __y, int *__quo)
     * }
     */
    public static double remquo(double __x, double __y, MemorySegment __quo) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", __x, __y, __quo);
            }
            return (double)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static FunctionDescriptor __remquo$descriptor() {
        return __remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MethodHandle __remquo$handle() {
        return __remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static MemorySegment __remquo$address() {
        return __remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __remquo(double __x, double __y, int *__quo)
     * }
     */
    public static double __remquo(double __x, double __y, MemorySegment __quo) {
        var mh$ = __remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remquo", __x, __y, __quo);
            }
            return (double)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double __x)
     * }
     */
    public static long lrint(double __x) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static FunctionDescriptor __lrint$descriptor() {
        return __lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static MethodHandle __lrint$handle() {
        return __lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static MemorySegment __lrint$address() {
        return __lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lrint(double __x)
     * }
     */
    public static long __lrint(double __x) {
        var mh$ = __lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double __x)
     * }
     */
    public static long llrint(double __x) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static FunctionDescriptor __llrint$descriptor() {
        return __llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static MethodHandle __llrint$handle() {
        return __llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static MemorySegment __llrint$address() {
        return __llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llrint(double __x)
     * }
     */
    public static long __llrint(double __x) {
        var mh$ = __llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llrint", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double __x)
     * }
     */
    public static long lround(double __x) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static FunctionDescriptor __lround$descriptor() {
        return __lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static MethodHandle __lround$handle() {
        return __lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static MemorySegment __lround$address() {
        return __lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lround(double __x)
     * }
     */
    public static long __lround(double __x) {
        var mh$ = __lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double __x)
     * }
     */
    public static long llround(double __x) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static FunctionDescriptor __llround$descriptor() {
        return __llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static MethodHandle __llround$handle() {
        return __llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static MemorySegment __llround$address() {
        return __llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llround(double __x)
     * }
     */
    public static long __llround(double __x) {
        var mh$ = __llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llround", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double __x, double __y)
     * }
     */
    public static double fdim(double __x, double __y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fdim$descriptor() {
        return __fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static MethodHandle __fdim$handle() {
        return __fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static MemorySegment __fdim$address() {
        return __fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fdim(double __x, double __y)
     * }
     */
    public static double __fdim(double __x, double __y) {
        var mh$ = __fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fdim", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double __x, double __y)
     * }
     */
    public static double fmax(double __x, double __y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmax$descriptor() {
        return __fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static MethodHandle __fmax$handle() {
        return __fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static MemorySegment __fmax$address() {
        return __fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fmax(double __x, double __y)
     * }
     */
    public static double __fmax(double __x, double __y) {
        var mh$ = __fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmax", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double __x, double __y)
     * }
     */
    public static double fmin(double __x, double __y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static FunctionDescriptor __fmin$descriptor() {
        return __fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static MethodHandle __fmin$handle() {
        return __fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static MemorySegment __fmin$address() {
        return __fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fmin(double __x, double __y)
     * }
     */
    public static double __fmin(double __x, double __y) {
        var mh$ = __fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmin", __x, __y);
            }
            return (double)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double __x, double __y, double __z)
     * }
     */
    public static double fma(double __x, double __y, double __z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static FunctionDescriptor __fma$descriptor() {
        return __fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static MethodHandle __fma$handle() {
        return __fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static MemorySegment __fma$address() {
        return __fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __fma(double __x, double __y, double __z)
     * }
     */
    public static double __fma(double __x, double __y, double __z) {
        var mh$ = __fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fma", __x, __y, __z);
            }
            return (double)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double __x, double __n)
     * }
     */
    public static double scalb(double __x, double __n) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static FunctionDescriptor __scalb$descriptor() {
        return __scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static MethodHandle __scalb$handle() {
        return __scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static MemorySegment __scalb$address() {
        return __scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __scalb(double __x, double __n)
     * }
     */
    public static double __scalb(double __x, double __n) {
        var mh$ = __scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalb", __x, __n);
            }
            return (double)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float __value)
     * }
     */
    public static int __fpclassifyf(float __value) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __signbitf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__signbitf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static FunctionDescriptor __signbitf$descriptor() {
        return __signbitf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static MethodHandle __signbitf$handle() {
        return __signbitf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static MemorySegment __signbitf$address() {
        return __signbitf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __signbitf(float __value)
     * }
     */
    public static int __signbitf(float __value) {
        var mh$ = __signbitf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__signbitf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isinff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__isinff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static FunctionDescriptor __isinff$descriptor() {
        return __isinff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static MethodHandle __isinff$handle() {
        return __isinff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static MemorySegment __isinff$address() {
        return __isinff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isinff(float __value)
     * }
     */
    public static int __isinff(float __value) {
        var mh$ = __isinff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isinff", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static FunctionDescriptor __finitef$descriptor() {
        return __finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static MethodHandle __finitef$handle() {
        return __finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static MemorySegment __finitef$address() {
        return __finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __finitef(float __value)
     * }
     */
    public static int __finitef(float __value) {
        var mh$ = __finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__finitef", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static FunctionDescriptor __isnanf$descriptor() {
        return __isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static MethodHandle __isnanf$handle() {
        return __isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static MemorySegment __isnanf$address() {
        return __isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __isnanf(float __value)
     * }
     */
    public static int __isnanf(float __value) {
        var mh$ = __isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__isnanf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __iseqsigf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__iseqsigf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __iseqsigf$descriptor() {
        return __iseqsigf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static MethodHandle __iseqsigf$handle() {
        return __iseqsigf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static MemorySegment __iseqsigf$address() {
        return __iseqsigf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __iseqsigf(float __x, float __y)
     * }
     */
    public static int __iseqsigf(float __x, float __y) {
        var mh$ = __iseqsigf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__iseqsigf", __x, __y);
            }
            return (int)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __issignalingf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__issignalingf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static FunctionDescriptor __issignalingf$descriptor() {
        return __issignalingf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static MethodHandle __issignalingf$handle() {
        return __issignalingf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static MemorySegment __issignalingf$address() {
        return __issignalingf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __issignalingf(float __value)
     * }
     */
    public static int __issignalingf(float __value) {
        var mh$ = __issignalingf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__issignalingf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acosf(float __x)
     * }
     */
    public static float acosf(float __x) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static FunctionDescriptor __acosf$descriptor() {
        return __acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static MethodHandle __acosf$handle() {
        return __acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static MemorySegment __acosf$address() {
        return __acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __acosf(float __x)
     * }
     */
    public static float __acosf(float __x) {
        var mh$ = __acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinf(float __x)
     * }
     */
    public static float asinf(float __x) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static FunctionDescriptor __asinf$descriptor() {
        return __asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static MethodHandle __asinf$handle() {
        return __asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static MemorySegment __asinf$address() {
        return __asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __asinf(float __x)
     * }
     */
    public static float __asinf(float __x) {
        var mh$ = __asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanf(float __x)
     * }
     */
    public static float atanf(float __x) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static FunctionDescriptor __atanf$descriptor() {
        return __atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static MethodHandle __atanf$handle() {
        return __atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static MemorySegment __atanf$address() {
        return __atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __atanf(float __x)
     * }
     */
    public static float __atanf(float __x) {
        var mh$ = __atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atan2f(float __y, float __x)
     * }
     */
    public static float atan2f(float __y, float __x) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", __y, __x);
            }
            return (float)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static FunctionDescriptor __atan2f$descriptor() {
        return __atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static MethodHandle __atan2f$handle() {
        return __atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static MemorySegment __atan2f$address() {
        return __atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __atan2f(float __y, float __x)
     * }
     */
    public static float __atan2f(float __y, float __x) {
        var mh$ = __atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atan2f", __y, __x);
            }
            return (float)mh$.invokeExact(__y, __x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cosf(float __x)
     * }
     */
    public static float cosf(float __x) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static FunctionDescriptor __cosf$descriptor() {
        return __cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static MethodHandle __cosf$handle() {
        return __cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static MemorySegment __cosf$address() {
        return __cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cosf(float __x)
     * }
     */
    public static float __cosf(float __x) {
        var mh$ = __cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cosf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinf(float __x)
     * }
     */
    public static float sinf(float __x) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static FunctionDescriptor __sinf$descriptor() {
        return __sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static MethodHandle __sinf$handle() {
        return __sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static MemorySegment __sinf$address() {
        return __sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinf(float __x)
     * }
     */
    public static float __sinf(float __x) {
        var mh$ = __sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanf(float __x)
     * }
     */
    public static float tanf(float __x) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static FunctionDescriptor __tanf$descriptor() {
        return __tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static MethodHandle __tanf$handle() {
        return __tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static MemorySegment __tanf$address() {
        return __tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanf(float __x)
     * }
     */
    public static float __tanf(float __x) {
        var mh$ = __tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float coshf(float __x)
     * }
     */
    public static float coshf(float __x) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static FunctionDescriptor __coshf$descriptor() {
        return __coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static MethodHandle __coshf$handle() {
        return __coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static MemorySegment __coshf$address() {
        return __coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __coshf(float __x)
     * }
     */
    public static float __coshf(float __x) {
        var mh$ = __coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__coshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinhf(float __x)
     * }
     */
    public static float sinhf(float __x) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static FunctionDescriptor __sinhf$descriptor() {
        return __sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static MethodHandle __sinhf$handle() {
        return __sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static MemorySegment __sinhf$address() {
        return __sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinhf(float __x)
     * }
     */
    public static float __sinhf(float __x) {
        var mh$ = __sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanhf(float __x)
     * }
     */
    public static float tanhf(float __x) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static FunctionDescriptor __tanhf$descriptor() {
        return __tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static MethodHandle __tanhf$handle() {
        return __tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static MemorySegment __tanhf$address() {
        return __tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanhf(float __x)
     * }
     */
    public static float __tanhf(float __x) {
        var mh$ = __tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acoshf(float __x)
     * }
     */
    public static float acoshf(float __x) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static FunctionDescriptor __acoshf$descriptor() {
        return __acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static MethodHandle __acoshf$handle() {
        return __acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static MemorySegment __acoshf$address() {
        return __acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __acoshf(float __x)
     * }
     */
    public static float __acoshf(float __x) {
        var mh$ = __acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acoshf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinhf(float __x)
     * }
     */
    public static float asinhf(float __x) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static FunctionDescriptor __asinhf$descriptor() {
        return __asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static MethodHandle __asinhf$handle() {
        return __asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static MemorySegment __asinhf$address() {
        return __asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __asinhf(float __x)
     * }
     */
    public static float __asinhf(float __x) {
        var mh$ = __asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__asinhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanhf(float __x)
     * }
     */
    public static float atanhf(float __x) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static FunctionDescriptor __atanhf$descriptor() {
        return __atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static MethodHandle __atanhf$handle() {
        return __atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static MemorySegment __atanhf$address() {
        return __atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __atanhf(float __x)
     * }
     */
    public static float __atanhf(float __x) {
        var mh$ = __atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__atanhf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expf(float __x)
     * }
     */
    public static float expf(float __x) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static FunctionDescriptor __expf$descriptor() {
        return __expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static MethodHandle __expf$handle() {
        return __expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static MemorySegment __expf$address() {
        return __expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __expf(float __x)
     * }
     */
    public static float __expf(float __x) {
        var mh$ = __expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static MemorySegment frexpf$address() {
        return frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float frexpf(float __x, int *__exponent)
     * }
     */
    public static float frexpf(float __x, MemorySegment __exponent) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static FunctionDescriptor __frexpf$descriptor() {
        return __frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static MethodHandle __frexpf$handle() {
        return __frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static MemorySegment __frexpf$address() {
        return __frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __frexpf(float __x, int *__exponent)
     * }
     */
    public static float __frexpf(float __x, MemorySegment __exponent) {
        var mh$ = __frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__frexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static MemorySegment ldexpf$address() {
        return ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ldexpf(float __x, int __exponent)
     * }
     */
    public static float ldexpf(float __x, int __exponent) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static FunctionDescriptor __ldexpf$descriptor() {
        return __ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static MethodHandle __ldexpf$handle() {
        return __ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static MemorySegment __ldexpf$address() {
        return __ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __ldexpf(float __x, int __exponent)
     * }
     */
    public static float __ldexpf(float __x, int __exponent) {
        var mh$ = __ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ldexpf", __x, __exponent);
            }
            return (float)mh$.invokeExact(__x, __exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logf(float __x)
     * }
     */
    public static float logf(float __x) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static FunctionDescriptor __logf$descriptor() {
        return __logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static MethodHandle __logf$handle() {
        return __logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static MemorySegment __logf$address() {
        return __logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __logf(float __x)
     * }
     */
    public static float __logf(float __x) {
        var mh$ = __logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log10f(float __x)
     * }
     */
    public static float log10f(float __x) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static FunctionDescriptor __log10f$descriptor() {
        return __log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static MethodHandle __log10f$handle() {
        return __log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static MemorySegment __log10f$address() {
        return __log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __log10f(float __x)
     * }
     */
    public static float __log10f(float __x) {
        var mh$ = __log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log10f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float modff(float __x, float *__iptr)
     * }
     */
    public static float modff(float __x, MemorySegment __iptr) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", __x, __iptr);
            }
            return (float)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static FunctionDescriptor __modff$descriptor() {
        return __modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static MethodHandle __modff$handle() {
        return __modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static MemorySegment __modff$address() {
        return __modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __modff(float __x, float *__iptr)
     * }
     */
    public static float __modff(float __x, MemorySegment __iptr) {
        var mh$ = __modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__modff", __x, __iptr);
            }
            return (float)mh$.invokeExact(__x, __iptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expm1f(float __x)
     * }
     */
    public static float expm1f(float __x) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static FunctionDescriptor __expm1f$descriptor() {
        return __expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static MethodHandle __expm1f$handle() {
        return __expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static MemorySegment __expm1f$address() {
        return __expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __expm1f(float __x)
     * }
     */
    public static float __expm1f(float __x) {
        var mh$ = __expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__expm1f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log1pf(float __x)
     * }
     */
    public static float log1pf(float __x) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static FunctionDescriptor __log1pf$descriptor() {
        return __log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static MethodHandle __log1pf$handle() {
        return __log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static MemorySegment __log1pf$address() {
        return __log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __log1pf(float __x)
     * }
     */
    public static float __log1pf(float __x) {
        var mh$ = __log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log1pf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logbf(float __x)
     * }
     */
    public static float logbf(float __x) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static FunctionDescriptor __logbf$descriptor() {
        return __logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static MethodHandle __logbf$handle() {
        return __logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static MemorySegment __logbf$address() {
        return __logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __logbf(float __x)
     * }
     */
    public static float __logbf(float __x) {
        var mh$ = __logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__logbf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float exp2f(float __x)
     * }
     */
    public static float exp2f(float __x) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static FunctionDescriptor __exp2f$descriptor() {
        return __exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static MethodHandle __exp2f$handle() {
        return __exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static MemorySegment __exp2f$address() {
        return __exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __exp2f(float __x)
     * }
     */
    public static float __exp2f(float __x) {
        var mh$ = __exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log2f(float __x)
     * }
     */
    public static float log2f(float __x) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static FunctionDescriptor __log2f$descriptor() {
        return __log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static MethodHandle __log2f$handle() {
        return __log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static MemorySegment __log2f$address() {
        return __log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __log2f(float __x)
     * }
     */
    public static float __log2f(float __x) {
        var mh$ = __log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__log2f", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float powf(float __x, float __y)
     * }
     */
    public static float powf(float __x, float __y) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __powf$descriptor() {
        return __powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static MethodHandle __powf$handle() {
        return __powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static MemorySegment __powf$address() {
        return __powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __powf(float __x, float __y)
     * }
     */
    public static float __powf(float __x, float __y) {
        var mh$ = __powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__powf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sqrtf(float __x)
     * }
     */
    public static float sqrtf(float __x) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static FunctionDescriptor __sqrtf$descriptor() {
        return __sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static MethodHandle __sqrtf$handle() {
        return __sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static MemorySegment __sqrtf$address() {
        return __sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sqrtf(float __x)
     * }
     */
    public static float __sqrtf(float __x) {
        var mh$ = __sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sqrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static MemorySegment hypotf$address() {
        return hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float hypotf(float __x, float __y)
     * }
     */
    public static float hypotf(float __x, float __y) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __hypotf$descriptor() {
        return __hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static MethodHandle __hypotf$handle() {
        return __hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static MemorySegment __hypotf$address() {
        return __hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __hypotf(float __x, float __y)
     * }
     */
    public static float __hypotf(float __x, float __y) {
        var mh$ = __hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__hypotf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cbrtf(float __x)
     * }
     */
    public static float cbrtf(float __x) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static FunctionDescriptor __cbrtf$descriptor() {
        return __cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static MethodHandle __cbrtf$handle() {
        return __cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static MemorySegment __cbrtf$address() {
        return __cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cbrtf(float __x)
     * }
     */
    public static float __cbrtf(float __x) {
        var mh$ = __cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cbrtf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ceilf(float __x)
     * }
     */
    public static float ceilf(float __x) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static FunctionDescriptor __ceilf$descriptor() {
        return __ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static MethodHandle __ceilf$handle() {
        return __ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static MemorySegment __ceilf$address() {
        return __ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __ceilf(float __x)
     * }
     */
    public static float __ceilf(float __x) {
        var mh$ = __ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ceilf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static MemorySegment fabsf$address() {
        return fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fabsf(float __x)
     * }
     */
    public static float fabsf(float __x) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static FunctionDescriptor __fabsf$descriptor() {
        return __fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static MethodHandle __fabsf$handle() {
        return __fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static MemorySegment __fabsf$address() {
        return __fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fabsf(float __x)
     * }
     */
    public static float __fabsf(float __x) {
        var mh$ = __fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fabsf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float floorf(float __x)
     * }
     */
    public static float floorf(float __x) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static FunctionDescriptor __floorf$descriptor() {
        return __floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static MethodHandle __floorf$handle() {
        return __floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static MemorySegment __floorf$address() {
        return __floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __floorf(float __x)
     * }
     */
    public static float __floorf(float __x) {
        var mh$ = __floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__floorf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmodf(float __x, float __y)
     * }
     */
    public static float fmodf(float __x, float __y) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fmodf$descriptor() {
        return __fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static MethodHandle __fmodf$handle() {
        return __fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static MemorySegment __fmodf$address() {
        return __fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fmodf(float __x, float __y)
     * }
     */
    public static float __fmodf(float __x, float __y) {
        var mh$ = __fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmodf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isinff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("isinff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static FunctionDescriptor isinff$descriptor() {
        return isinff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static MethodHandle isinff$handle() {
        return isinff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static MemorySegment isinff$address() {
        return isinff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isinff(float __value)
     * }
     */
    public static int isinff(float __value) {
        var mh$ = isinff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isinff", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static FunctionDescriptor finitef$descriptor() {
        return finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static MethodHandle finitef$handle() {
        return finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static MemorySegment finitef$address() {
        return finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int finitef(float __value)
     * }
     */
    public static int finitef(float __value) {
        var mh$ = finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("finitef", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dremf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("dremf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor dremf$descriptor() {
        return dremf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static MethodHandle dremf$handle() {
        return dremf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static MemorySegment dremf$address() {
        return dremf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float dremf(float __x, float __y)
     * }
     */
    public static float dremf(float __x, float __y) {
        var mh$ = dremf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dremf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __dremf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__dremf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __dremf$descriptor() {
        return __dremf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static MethodHandle __dremf$handle() {
        return __dremf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static MemorySegment __dremf$address() {
        return __dremf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __dremf(float __x, float __y)
     * }
     */
    public static float __dremf(float __x, float __y) {
        var mh$ = __dremf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__dremf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class significandf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("significandf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static FunctionDescriptor significandf$descriptor() {
        return significandf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static MethodHandle significandf$handle() {
        return significandf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static MemorySegment significandf$address() {
        return significandf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float significandf(float __x)
     * }
     */
    public static float significandf(float __x) {
        var mh$ = significandf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("significandf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __significandf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__significandf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static FunctionDescriptor __significandf$descriptor() {
        return __significandf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static MethodHandle __significandf$handle() {
        return __significandf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static MemorySegment __significandf$address() {
        return __significandf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __significandf(float __x)
     * }
     */
    public static float __significandf(float __x) {
        var mh$ = __significandf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__significandf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float copysignf(float __x, float __y)
     * }
     */
    public static float copysignf(float __x, float __y) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __copysignf$descriptor() {
        return __copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static MethodHandle __copysignf$handle() {
        return __copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static MemorySegment __copysignf$address() {
        return __copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __copysignf(float __x, float __y)
     * }
     */
    public static float __copysignf(float __x, float __y) {
        var mh$ = __copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__copysignf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nanf(const char *__tagb)
     * }
     */
    public static float nanf(MemorySegment __tagb) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", __tagb);
            }
            return (float)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static FunctionDescriptor __nanf$descriptor() {
        return __nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static MethodHandle __nanf$handle() {
        return __nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static MemorySegment __nanf$address() {
        return __nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __nanf(const char *__tagb)
     * }
     */
    public static float __nanf(MemorySegment __tagb) {
        var mh$ = __nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nanf", __tagb);
            }
            return (float)mh$.invokeExact(__tagb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static FunctionDescriptor isnanf$descriptor() {
        return isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static MethodHandle isnanf$handle() {
        return isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static MemorySegment isnanf$address() {
        return isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isnanf(float __value)
     * }
     */
    public static int isnanf(float __value) {
        var mh$ = isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isnanf", __value);
            }
            return (int)mh$.invokeExact(__value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("j0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static FunctionDescriptor j0f$descriptor() {
        return j0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static MethodHandle j0f$handle() {
        return j0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static MemorySegment j0f$address() {
        return j0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float j0f(float)
     * }
     */
    public static float j0f(float x0) {
        var mh$ = j0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__j0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static FunctionDescriptor __j0f$descriptor() {
        return __j0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static MethodHandle __j0f$handle() {
        return __j0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static MemorySegment __j0f$address() {
        return __j0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __j0f(float)
     * }
     */
    public static float __j0f(float x0) {
        var mh$ = __j0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("j1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static FunctionDescriptor j1f$descriptor() {
        return j1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static MethodHandle j1f$handle() {
        return j1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static MemorySegment j1f$address() {
        return j1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float j1f(float)
     * }
     */
    public static float j1f(float x0) {
        var mh$ = j1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __j1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__j1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static FunctionDescriptor __j1f$descriptor() {
        return __j1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static MethodHandle __j1f$handle() {
        return __j1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static MemorySegment __j1f$address() {
        return __j1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __j1f(float)
     * }
     */
    public static float __j1f(float x0) {
        var mh$ = __j1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__j1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("jnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static FunctionDescriptor jnf$descriptor() {
        return jnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static MethodHandle jnf$handle() {
        return jnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static MemorySegment jnf$address() {
        return jnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float jnf(int, float)
     * }
     */
    public static float jnf(int x0, float x1) {
        var mh$ = jnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __jnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__jnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static FunctionDescriptor __jnf$descriptor() {
        return __jnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static MethodHandle __jnf$handle() {
        return __jnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static MemorySegment __jnf$address() {
        return __jnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __jnf(int, float)
     * }
     */
    public static float __jnf(int x0, float x1) {
        var mh$ = __jnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__jnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("y0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static FunctionDescriptor y0f$descriptor() {
        return y0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static MethodHandle y0f$handle() {
        return y0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static MemorySegment y0f$address() {
        return y0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float y0f(float)
     * }
     */
    public static float y0f(float x0) {
        var mh$ = y0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y0f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__y0f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static FunctionDescriptor __y0f$descriptor() {
        return __y0f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static MethodHandle __y0f$handle() {
        return __y0f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static MemorySegment __y0f$address() {
        return __y0f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __y0f(float)
     * }
     */
    public static float __y0f(float x0) {
        var mh$ = __y0f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y0f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("y1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static FunctionDescriptor y1f$descriptor() {
        return y1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static MethodHandle y1f$handle() {
        return y1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static MemorySegment y1f$address() {
        return y1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float y1f(float)
     * }
     */
    public static float y1f(float x0) {
        var mh$ = y1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __y1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__y1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static FunctionDescriptor __y1f$descriptor() {
        return __y1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static MethodHandle __y1f$handle() {
        return __y1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static MemorySegment __y1f$address() {
        return __y1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __y1f(float)
     * }
     */
    public static float __y1f(float x0) {
        var mh$ = __y1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__y1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ynf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ynf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static FunctionDescriptor ynf$descriptor() {
        return ynf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static MethodHandle ynf$handle() {
        return ynf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static MemorySegment ynf$address() {
        return ynf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ynf(int, float)
     * }
     */
    public static float ynf(int x0, float x1) {
        var mh$ = ynf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ynf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ynf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ynf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static FunctionDescriptor __ynf$descriptor() {
        return __ynf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static MethodHandle __ynf$handle() {
        return __ynf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static MemorySegment __ynf$address() {
        return __ynf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __ynf(int, float)
     * }
     */
    public static float __ynf(int x0, float x1) {
        var mh$ = __ynf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ynf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static FunctionDescriptor __erff$descriptor() {
        return __erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static MethodHandle __erff$handle() {
        return __erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static MemorySegment __erff$address() {
        return __erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __erff(float)
     * }
     */
    public static float __erff(float x0) {
        var mh$ = __erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static FunctionDescriptor __erfcf$descriptor() {
        return __erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static MethodHandle __erfcf$handle() {
        return __erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static MemorySegment __erfcf$address() {
        return __erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __erfcf(float)
     * }
     */
    public static float __erfcf(float x0) {
        var mh$ = __erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static FunctionDescriptor __lgammaf$descriptor() {
        return __lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static MethodHandle __lgammaf$handle() {
        return __lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static MemorySegment __lgammaf$address() {
        return __lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __lgammaf(float)
     * }
     */
    public static float __lgammaf(float x0) {
        var mh$ = __lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static FunctionDescriptor __tgammaf$descriptor() {
        return __tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static MethodHandle __tgammaf$handle() {
        return __tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static MemorySegment __tgammaf$address() {
        return __tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tgammaf(float)
     * }
     */
    public static float __tgammaf(float x0) {
        var mh$ = __tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("gammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static FunctionDescriptor gammaf$descriptor() {
        return gammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static MethodHandle gammaf$handle() {
        return gammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static MemorySegment gammaf$address() {
        return gammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float gammaf(float)
     * }
     */
    public static float gammaf(float x0) {
        var mh$ = gammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__gammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static FunctionDescriptor __gammaf$descriptor() {
        return __gammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static MethodHandle __gammaf$handle() {
        return __gammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static MemorySegment __gammaf$address() {
        return __gammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __gammaf(float)
     * }
     */
    public static float __gammaf(float x0) {
        var mh$ = __gammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lgammaf_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static FunctionDescriptor lgammaf_r$descriptor() {
        return lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MethodHandle lgammaf_r$handle() {
        return lgammaf_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MemorySegment lgammaf_r$address() {
        return lgammaf_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *__signgamp)
     * }
     */
    public static float lgammaf_r(float x0, MemorySegment __signgamp) {
        var mh$ = lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf_r", x0, __signgamp);
            }
            return (float)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lgammaf_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static FunctionDescriptor __lgammaf_r$descriptor() {
        return __lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MethodHandle __lgammaf_r$handle() {
        return __lgammaf_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static MemorySegment __lgammaf_r$address() {
        return __lgammaf_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __lgammaf_r(float, int *__signgamp)
     * }
     */
    public static float __lgammaf_r(float x0, MemorySegment __signgamp) {
        var mh$ = __lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lgammaf_r", x0, __signgamp);
            }
            return (float)mh$.invokeExact(x0, __signgamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float rintf(float __x)
     * }
     */
    public static float rintf(float __x) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static FunctionDescriptor __rintf$descriptor() {
        return __rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static MethodHandle __rintf$handle() {
        return __rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static MemorySegment __rintf$address() {
        return __rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __rintf(float __x)
     * }
     */
    public static float __rintf(float __x) {
        var mh$ = __rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__rintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nextafterf(float __x, float __y)
     * }
     */
    public static float nextafterf(float __x, float __y) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __nextafterf$descriptor() {
        return __nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static MethodHandle __nextafterf$handle() {
        return __nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static MemorySegment __nextafterf$address() {
        return __nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __nextafterf(float __x, float __y)
     * }
     */
    public static float __nextafterf(float __x, float __y) {
        var mh$ = __nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nextafterf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remainderf(float __x, float __y)
     * }
     */
    public static float remainderf(float __x, float __y) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __remainderf$descriptor() {
        return __remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static MethodHandle __remainderf$handle() {
        return __remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static MemorySegment __remainderf$address() {
        return __remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __remainderf(float __x, float __y)
     * }
     */
    public static float __remainderf(float __x, float __y) {
        var mh$ = __remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remainderf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbnf(float __x, int __n)
     * }
     */
    public static float scalbnf(float __x, int __n) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static FunctionDescriptor __scalbnf$descriptor() {
        return __scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static MethodHandle __scalbnf$handle() {
        return __scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static MemorySegment __scalbnf$address() {
        return __scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __scalbnf(float __x, int __n)
     * }
     */
    public static float __scalbnf(float __x, int __n) {
        var mh$ = __scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogbf(float __x)
     * }
     */
    public static int ilogbf(float __x) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static FunctionDescriptor __ilogbf$descriptor() {
        return __ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static MethodHandle __ilogbf$handle() {
        return __ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static MemorySegment __ilogbf$address() {
        return __ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __ilogbf(float __x)
     * }
     */
    public static int __ilogbf(float __x) {
        var mh$ = __ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ilogbf", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalblnf(float __x, long __n)
     * }
     */
    public static float scalblnf(float __x, long __n) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static FunctionDescriptor __scalblnf$descriptor() {
        return __scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static MethodHandle __scalblnf$handle() {
        return __scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static MemorySegment __scalblnf$address() {
        return __scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __scalblnf(float __x, long __n)
     * }
     */
    public static float __scalblnf(float __x, long __n) {
        var mh$ = __scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalblnf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float __x)
     * }
     */
    public static float nearbyintf(float __x) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static FunctionDescriptor __nearbyintf$descriptor() {
        return __nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static MethodHandle __nearbyintf$handle() {
        return __nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static MemorySegment __nearbyintf$address() {
        return __nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __nearbyintf(float __x)
     * }
     */
    public static float __nearbyintf(float __x) {
        var mh$ = __nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__nearbyintf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float roundf(float __x)
     * }
     */
    public static float roundf(float __x) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static FunctionDescriptor __roundf$descriptor() {
        return __roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static MethodHandle __roundf$handle() {
        return __roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static MemorySegment __roundf$address() {
        return __roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __roundf(float __x)
     * }
     */
    public static float __roundf(float __x) {
        var mh$ = __roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__roundf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float truncf(float __x)
     * }
     */
    public static float truncf(float __x) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static FunctionDescriptor __truncf$descriptor() {
        return __truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static MethodHandle __truncf$handle() {
        return __truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static MemorySegment __truncf$address() {
        return __truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __truncf(float __x)
     * }
     */
    public static float __truncf(float __x) {
        var mh$ = __truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__truncf", __x);
            }
            return (float)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remquof(float __x, float __y, int *__quo)
     * }
     */
    public static float remquof(float __x, float __y, MemorySegment __quo) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", __x, __y, __quo);
            }
            return (float)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static FunctionDescriptor __remquof$descriptor() {
        return __remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MethodHandle __remquof$handle() {
        return __remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static MemorySegment __remquof$address() {
        return __remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __remquof(float __x, float __y, int *__quo)
     * }
     */
    public static float __remquof(float __x, float __y, MemorySegment __quo) {
        var mh$ = __remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__remquof", __x, __y, __quo);
            }
            return (float)mh$.invokeExact(__x, __y, __quo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrintf(float __x)
     * }
     */
    public static long lrintf(float __x) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static FunctionDescriptor __lrintf$descriptor() {
        return __lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static MethodHandle __lrintf$handle() {
        return __lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static MemorySegment __lrintf$address() {
        return __lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lrintf(float __x)
     * }
     */
    public static long __lrintf(float __x) {
        var mh$ = __lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrintf(float __x)
     * }
     */
    public static long llrintf(float __x) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static FunctionDescriptor __llrintf$descriptor() {
        return __llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static MethodHandle __llrintf$handle() {
        return __llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static MemorySegment __llrintf$address() {
        return __llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llrintf(float __x)
     * }
     */
    public static long __llrintf(float __x) {
        var mh$ = __llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llrintf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lroundf(float __x)
     * }
     */
    public static long lroundf(float __x) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static FunctionDescriptor __lroundf$descriptor() {
        return __lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static MethodHandle __lroundf$handle() {
        return __lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static MemorySegment __lroundf$address() {
        return __lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long __lroundf(float __x)
     * }
     */
    public static long __lroundf(float __x) {
        var mh$ = __lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__lroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llroundf(float __x)
     * }
     */
    public static long llroundf(float __x) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static FunctionDescriptor __llroundf$descriptor() {
        return __llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static MethodHandle __llroundf$handle() {
        return __llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static MemorySegment __llroundf$address() {
        return __llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long __llroundf(float __x)
     * }
     */
    public static long __llroundf(float __x) {
        var mh$ = __llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__llroundf", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fdimf(float __x, float __y)
     * }
     */
    public static float fdimf(float __x, float __y) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fdimf$descriptor() {
        return __fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static MethodHandle __fdimf$handle() {
        return __fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static MemorySegment __fdimf$address() {
        return __fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fdimf(float __x, float __y)
     * }
     */
    public static float __fdimf(float __x, float __y) {
        var mh$ = __fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fdimf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaxf(float __x, float __y)
     * }
     */
    public static float fmaxf(float __x, float __y) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fmaxf$descriptor() {
        return __fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static MethodHandle __fmaxf$handle() {
        return __fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static MemorySegment __fmaxf$address() {
        return __fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fmaxf(float __x, float __y)
     * }
     */
    public static float __fmaxf(float __x, float __y) {
        var mh$ = __fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmaxf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fminf(float __x, float __y)
     * }
     */
    public static float fminf(float __x, float __y) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static FunctionDescriptor __fminf$descriptor() {
        return __fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static MethodHandle __fminf$handle() {
        return __fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static MemorySegment __fminf$address() {
        return __fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fminf(float __x, float __y)
     * }
     */
    public static float __fminf(float __x, float __y) {
        var mh$ = __fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fminf", __x, __y);
            }
            return (float)mh$.invokeExact(__x, __y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaf(float __x, float __y, float __z)
     * }
     */
    public static float fmaf(float __x, float __y, float __z) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", __x, __y, __z);
            }
            return (float)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static FunctionDescriptor __fmaf$descriptor() {
        return __fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static MethodHandle __fmaf$handle() {
        return __fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static MemorySegment __fmaf$address() {
        return __fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __fmaf(float __x, float __y, float __z)
     * }
     */
    public static float __fmaf(float __x, float __y, float __z) {
        var mh$ = __fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fmaf", __x, __y, __z);
            }
            return (float)mh$.invokeExact(__x, __y, __z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("scalbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static FunctionDescriptor scalbf$descriptor() {
        return scalbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static MethodHandle scalbf$handle() {
        return scalbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static MemorySegment scalbf$address() {
        return scalbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbf(float __x, float __n)
     * }
     */
    public static float scalbf(float __x, float __n) {
        var mh$ = scalbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __scalbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__scalbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static FunctionDescriptor __scalbf$descriptor() {
        return __scalbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static MethodHandle __scalbf$handle() {
        return __scalbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static MemorySegment __scalbf$address() {
        return __scalbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __scalbf(float __x, float __n)
     * }
     */
    public static float __scalbf(float __x, float __n) {
        var mh$ = __scalbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__scalbf", __x, __n);
            }
            return (float)mh$.invokeExact(__x, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = FFmpeg.C_INT;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = FFmpeg.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = FFmpeg.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fopencookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie$address() {
        return fopencookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_LONG,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = FFmpeg.C_INT;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = FFmpeg.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = FFmpeg.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __size) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __size);
            }
            mh$.invokeExact(__buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__memcmpeq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment __memcmpeq$address() {
        return __memcmpeq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = FFmpeg.C_POINTER;

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MemorySegment strcoll_l$address() {
        return strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MemorySegment strxfrm_l$address() {
        return strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strchrnul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul$address() {
        return strchrnul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r$address() {
        return __strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem(MemorySegment __haystack, long __haystacklen, MemorySegment __needle, long __needlelen) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __haystack, __haystacklen, __needle, __needlelen);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __haystacklen, __needle, __needlelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __mempcpy$descriptor() {
        return __mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __mempcpy$handle() {
        return __mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy$address() {
        return __mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor mempcpy$descriptor() {
        return mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle mempcpy$handle() {
        return mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy$address() {
        return mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__xpg_strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strerror_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l$address() {
        return strerror_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strcasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MemorySegment strcasecmp_l$address() {
        return strcasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strncasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MemorySegment strncasecmp_l$address() {
        return strncasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("explicit_bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment explicit_bzero$address() {
        return explicit_bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy$address() {
        return __stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("__stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy$address() {
        return __stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = FFmpeg.C_LONG;

    private static class av_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static FunctionDescriptor av_strerror$descriptor() {
        return av_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MethodHandle av_strerror$handle() {
        return av_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MemorySegment av_strerror$address() {
        return av_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static int av_strerror(int errnum, MemorySegment errbuf, long errbuf_size) {
        var mh$ = av_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strerror", errnum, errbuf, errbuf_size);
            }
            return (int)mh$.invokeExact(errnum, errbuf, errbuf_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc$descriptor() {
        return av_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MethodHandle av_malloc$handle() {
        return av_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc$address() {
        return av_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc(long size) {
        var mh$ = av_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_mallocz$descriptor() {
        return av_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MethodHandle av_mallocz$handle() {
        return av_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz$address() {
        return av_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz(long size) {
        var mh$ = av_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mallocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_malloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc_array$descriptor() {
        return av_malloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_malloc_array$handle() {
        return av_malloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array$address() {
        return av_malloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array(long nmemb, long size) {
        var mh$ = av_malloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc_array", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_calloc$descriptor() {
        return av_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_calloc$handle() {
        return av_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc$address() {
        return av_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc(long nmemb, long size) {
        var mh$ = av_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_calloc", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc$descriptor() {
        return av_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_realloc$handle() {
        return av_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc$address() {
        return av_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc(MemorySegment ptr, long size) {
        var mh$ = av_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_reallocp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp$descriptor() {
        return av_reallocp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_reallocp$handle() {
        return av_reallocp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_reallocp$address() {
        return av_reallocp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static int av_reallocp(MemorySegment ptr, long size) {
        var mh$ = av_reallocp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp", ptr, size);
            }
            return (int)mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_realloc_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor av_realloc_f$descriptor() {
        return av_realloc_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle av_realloc_f$handle() {
        return av_realloc_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f$address() {
        return av_realloc_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f(MemorySegment ptr, long nelem, long elsize) {
        var mh$ = av_realloc_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_f", ptr, nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_realloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc_array$descriptor() {
        return av_realloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_realloc_array$handle() {
        return av_realloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array$address() {
        return av_realloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_realloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_array", ptr, nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_reallocp_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp_array$descriptor() {
        return av_reallocp_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_reallocp_array$handle() {
        return av_reallocp_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_reallocp_array$address() {
        return av_reallocp_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static int av_reallocp_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_reallocp_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp_array", ptr, nmemb, size);
            }
            return (int)mh$.invokeExact(ptr, nmemb, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_fast_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_realloc$descriptor() {
        return av_fast_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_realloc$handle() {
        return av_fast_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc$address() {
        return av_fast_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_realloc", ptr, size, min_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_fast_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_malloc$descriptor() {
        return av_fast_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_malloc$handle() {
        return av_fast_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_malloc$address() {
        return av_fast_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_fast_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_mallocz$descriptor() {
        return av_fast_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_mallocz$handle() {
        return av_fast_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_mallocz$address() {
        return av_fast_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static FunctionDescriptor av_free$descriptor() {
        return av_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MethodHandle av_free$handle() {
        return av_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MemorySegment av_free$address() {
        return av_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static void av_free(MemorySegment ptr) {
        var mh$ = av_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_freep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_freep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static FunctionDescriptor av_freep$descriptor() {
        return av_freep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MethodHandle av_freep$handle() {
        return av_freep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MemorySegment av_freep$address() {
        return av_freep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static void av_freep(MemorySegment ptr) {
        var mh$ = av_freep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_freep", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static FunctionDescriptor av_strdup$descriptor() {
        return av_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MethodHandle av_strdup$handle() {
        return av_strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup$address() {
        return av_strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup(MemorySegment s) {
        var mh$ = av_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strdup", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static FunctionDescriptor av_strndup$descriptor() {
        return av_strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MethodHandle av_strndup$handle() {
        return av_strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup$address() {
        return av_strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup(MemorySegment s, long len) {
        var mh$ = av_strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strndup", s, len);
            }
            return (MemorySegment)mh$.invokeExact(s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_memdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static FunctionDescriptor av_memdup$descriptor() {
        return av_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MethodHandle av_memdup$handle() {
        return av_memdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup$address() {
        return av_memdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup(MemorySegment p, long size) {
        var mh$ = av_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memdup", p, size);
            }
            return (MemorySegment)mh$.invokeExact(p, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memcpy_backptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_memcpy_backptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static FunctionDescriptor av_memcpy_backptr$descriptor() {
        return av_memcpy_backptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MethodHandle av_memcpy_backptr$handle() {
        return av_memcpy_backptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MemorySegment av_memcpy_backptr$address() {
        return av_memcpy_backptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static void av_memcpy_backptr(MemorySegment dst, int back, int cnt) {
        var mh$ = av_memcpy_backptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memcpy_backptr", dst, back, cnt);
            }
            mh$.invokeExact(dst, back, cnt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_dynarray_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add$descriptor() {
        return av_dynarray_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add$handle() {
        return av_dynarray_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add$address() {
        return av_dynarray_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static void av_dynarray_add(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add", tab_ptr, nb_ptr, elem);
            }
            mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add_nofree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_dynarray_add_nofree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add_nofree$descriptor() {
        return av_dynarray_add_nofree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add_nofree$handle() {
        return av_dynarray_add_nofree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add_nofree$address() {
        return av_dynarray_add_nofree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static int av_dynarray_add_nofree(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add_nofree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add_nofree", tab_ptr, nb_ptr, elem);
            }
            return (int)mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray2_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_dynarray2_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static FunctionDescriptor av_dynarray2_add$descriptor() {
        return av_dynarray2_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MethodHandle av_dynarray2_add$handle() {
        return av_dynarray2_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add$address() {
        return av_dynarray2_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add(MemorySegment tab_ptr, MemorySegment nb_ptr, long elem_size, MemorySegment elem_data) {
        var mh$ = av_dynarray2_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray2_add", tab_ptr, nb_ptr, elem_size, elem_data);
            }
            return (MemorySegment)mh$.invokeExact(tab_ptr, nb_ptr, elem_size, elem_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_size_mult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_size_mult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static FunctionDescriptor av_size_mult$descriptor() {
        return av_size_mult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MethodHandle av_size_mult$handle() {
        return av_size_mult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MemorySegment av_size_mult$address() {
        return av_size_mult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static int av_size_mult(long a, long b, MemorySegment r) {
        var mh$ = av_size_mult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_size_mult", a, b, r);
            }
            return (int)mh$.invokeExact(a, b, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_max_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_max_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static FunctionDescriptor av_max_alloc$descriptor() {
        return av_max_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MethodHandle av_max_alloc$handle() {
        return av_max_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MemorySegment av_max_alloc$address() {
        return av_max_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static void av_max_alloc(long max) {
        var mh$ = av_max_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_max_alloc", max);
            }
            mh$.invokeExact(max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2$descriptor() {
        return av_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static MethodHandle av_log2$handle() {
        return av_log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static MemorySegment av_log2$address() {
        return av_log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static int av_log2(int v) {
        var mh$ = av_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2_16bit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log2_16bit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2_16bit$descriptor() {
        return av_log2_16bit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static MethodHandle av_log2_16bit$handle() {
        return av_log2_16bit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static MemorySegment av_log2_16bit$address() {
        return av_log2_16bit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static int av_log2_16bit(int v) {
        var mh$ = av_log2_16bit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2_16bit", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static FunctionDescriptor av_reduce$descriptor() {
        return av_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static MethodHandle av_reduce$handle() {
        return av_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static MemorySegment av_reduce$address() {
        return av_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static int av_reduce(MemorySegment dst_num, MemorySegment dst_den, long num, long den, long max) {
        var mh$ = av_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reduce", dst_num, dst_den, num, den, max);
            }
            return (int)mh$.invokeExact(dst_num, dst_den, num, den, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mul_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_mul_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_mul_q$descriptor() {
        return av_mul_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_mul_q$handle() {
        return av_mul_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_mul_q$address() {
        return av_mul_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_mul_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_mul_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mul_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_div_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_div_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_div_q$descriptor() {
        return av_div_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_div_q$handle() {
        return av_div_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_div_q$address() {
        return av_div_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_div_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_div_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_div_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_add_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_add_q$descriptor() {
        return av_add_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_add_q$handle() {
        return av_add_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_add_q$address() {
        return av_add_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_add_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_add_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sub_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_sub_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_sub_q$descriptor() {
        return av_sub_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_sub_q$handle() {
        return av_sub_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_sub_q$address() {
        return av_sub_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_sub_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_sub_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sub_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_d2q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_d2q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static FunctionDescriptor av_d2q$descriptor() {
        return av_d2q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MethodHandle av_d2q$handle() {
        return av_d2q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MemorySegment av_d2q$address() {
        return av_d2q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MemorySegment av_d2q(SegmentAllocator allocator, double d, int max) {
        var mh$ = av_d2q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_d2q", allocator, d, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, d, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_nearer_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_nearer_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static FunctionDescriptor av_nearer_q$descriptor() {
        return av_nearer_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static MethodHandle av_nearer_q$handle() {
        return av_nearer_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static MemorySegment av_nearer_q$address() {
        return av_nearer_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static int av_nearer_q(MemorySegment q, MemorySegment q1, MemorySegment q2) {
        var mh$ = av_nearer_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_nearer_q", q, q1, q2);
            }
            return (int)mh$.invokeExact(q, q1, q2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_nearest_q_idx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_find_nearest_q_idx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static FunctionDescriptor av_find_nearest_q_idx$descriptor() {
        return av_find_nearest_q_idx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static MethodHandle av_find_nearest_q_idx$handle() {
        return av_find_nearest_q_idx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static MemorySegment av_find_nearest_q_idx$address() {
        return av_find_nearest_q_idx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static int av_find_nearest_q_idx(MemorySegment q, MemorySegment q_list) {
        var mh$ = av_find_nearest_q_idx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_nearest_q_idx", q, q_list);
            }
            return (int)mh$.invokeExact(q, q_list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_q2intfloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_q2intfloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static FunctionDescriptor av_q2intfloat$descriptor() {
        return av_q2intfloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static MethodHandle av_q2intfloat$handle() {
        return av_q2intfloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static MemorySegment av_q2intfloat$address() {
        return av_q2intfloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static int av_q2intfloat(MemorySegment q) {
        var mh$ = av_q2intfloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_q2intfloat", q);
            }
            return (int)mh$.invokeExact(q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_gcd_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout(),
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_gcd_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static FunctionDescriptor av_gcd_q$descriptor() {
        return av_gcd_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MethodHandle av_gcd_q$handle() {
        return av_gcd_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MemorySegment av_gcd_q$address() {
        return av_gcd_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MemorySegment av_gcd_q(SegmentAllocator allocator, MemorySegment a, MemorySegment b, int max_den, MemorySegment def) {
        var mh$ = av_gcd_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd_q", allocator, a, b, max_den, def);
            }
            return (MemorySegment)mh$.invokeExact(allocator, a, b, max_den, def);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_ROUND_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_ZERO = 0
     * }
     */
    public static int AV_ROUND_ZERO() {
        return AV_ROUND_ZERO;
    }
    private static final int AV_ROUND_INF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_INF = 1
     * }
     */
    public static int AV_ROUND_INF() {
        return AV_ROUND_INF;
    }
    private static final int AV_ROUND_DOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_DOWN = 2
     * }
     */
    public static int AV_ROUND_DOWN() {
        return AV_ROUND_DOWN;
    }
    private static final int AV_ROUND_UP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_UP = 3
     * }
     */
    public static int AV_ROUND_UP() {
        return AV_ROUND_UP;
    }
    private static final int AV_ROUND_NEAR_INF = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_NEAR_INF = 5
     * }
     */
    public static int AV_ROUND_NEAR_INF() {
        return AV_ROUND_NEAR_INF;
    }
    private static final int AV_ROUND_PASS_MINMAX = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_PASS_MINMAX = 8192
     * }
     */
    public static int AV_ROUND_PASS_MINMAX() {
        return AV_ROUND_PASS_MINMAX;
    }

    private static class av_gcd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_gcd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static FunctionDescriptor av_gcd$descriptor() {
        return av_gcd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static MethodHandle av_gcd$handle() {
        return av_gcd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static MemorySegment av_gcd$address() {
        return av_gcd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static long av_gcd(long a, long b) {
        var mh$ = av_gcd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd", a, b);
            }
            return (long)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_rescale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static FunctionDescriptor av_rescale$descriptor() {
        return av_rescale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static MethodHandle av_rescale$handle() {
        return av_rescale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static MemorySegment av_rescale$address() {
        return av_rescale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static long av_rescale(long a, long b, long c) {
        var mh$ = av_rescale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale", a, b, c);
            }
            return (long)mh$.invokeExact(a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_rescale_rnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_rnd$descriptor() {
        return av_rescale_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_rnd$handle() {
        return av_rescale_rnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static MemorySegment av_rescale_rnd$address() {
        return av_rescale_rnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_rnd(long a, long b, long c, int rnd) {
        var mh$ = av_rescale_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_rnd", a, b, c, rnd);
            }
            return (long)mh$.invokeExact(a, b, c, rnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_rescale_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static FunctionDescriptor av_rescale_q$descriptor() {
        return av_rescale_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static MethodHandle av_rescale_q$handle() {
        return av_rescale_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static MemorySegment av_rescale_q$address() {
        return av_rescale_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static long av_rescale_q(long a, MemorySegment bq, MemorySegment cq) {
        var mh$ = av_rescale_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q", a, bq, cq);
            }
            return (long)mh$.invokeExact(a, bq, cq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            AVRational.layout(),
            AVRational.layout(),
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_rescale_q_rnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_q_rnd$descriptor() {
        return av_rescale_q_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_q_rnd$handle() {
        return av_rescale_q_rnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static MemorySegment av_rescale_q_rnd$address() {
        return av_rescale_q_rnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_q_rnd(long a, MemorySegment bq, MemorySegment cq, int rnd) {
        var mh$ = av_rescale_q_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q_rnd", a, bq, cq, rnd);
            }
            return (long)mh$.invokeExact(a, bq, cq, rnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_ts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_compare_ts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static FunctionDescriptor av_compare_ts$descriptor() {
        return av_compare_ts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static MethodHandle av_compare_ts$handle() {
        return av_compare_ts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static MemorySegment av_compare_ts$address() {
        return av_compare_ts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static int av_compare_ts(long ts_a, MemorySegment tb_a, long ts_b, MemorySegment tb_b) {
        var mh$ = av_compare_ts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_ts", ts_a, tb_a, ts_b, tb_b);
            }
            return (int)mh$.invokeExact(ts_a, tb_a, ts_b, tb_b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_mod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_compare_mod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static FunctionDescriptor av_compare_mod$descriptor() {
        return av_compare_mod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static MethodHandle av_compare_mod$handle() {
        return av_compare_mod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static MemorySegment av_compare_mod$address() {
        return av_compare_mod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static long av_compare_mod(long a, long b, long mod) {
        var mh$ = av_compare_mod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_mod", a, b, mod);
            }
            return (long)mh$.invokeExact(a, b, mod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_delta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_rescale_delta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static FunctionDescriptor av_rescale_delta$descriptor() {
        return av_rescale_delta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static MethodHandle av_rescale_delta$handle() {
        return av_rescale_delta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static MemorySegment av_rescale_delta$address() {
        return av_rescale_delta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static long av_rescale_delta(MemorySegment in_tb, long in_ts, MemorySegment fs_tb, int duration, MemorySegment last, MemorySegment out_tb) {
        var mh$ = av_rescale_delta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_delta", in_tb, in_ts, fs_tb, duration, last, out_tb);
            }
            return (long)mh$.invokeExact(in_tb, in_ts, fs_tb, duration, last, out_tb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_stable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_add_stable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static FunctionDescriptor av_add_stable$descriptor() {
        return av_add_stable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static MethodHandle av_add_stable$handle() {
        return av_add_stable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static MemorySegment av_add_stable$address() {
        return av_add_stable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static long av_add_stable(MemorySegment ts_tb, long ts, MemorySegment inc_tb, long inc) {
        var mh$ = av_add_stable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_stable", ts_tb, ts, inc_tb, inc);
            }
            return (long)mh$.invokeExact(ts_tb, ts, inc_tb, inc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_bessel_i0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_bessel_i0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static FunctionDescriptor av_bessel_i0$descriptor() {
        return av_bessel_i0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static MethodHandle av_bessel_i0$handle() {
        return av_bessel_i0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static MemorySegment av_bessel_i0$address() {
        return av_bessel_i0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static double av_bessel_i0(double x) {
        var mh$ = av_bessel_i0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_bessel_i0", x);
            }
            return (double)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CLASS_CATEGORY_NA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NA = 0
     * }
     */
    public static int AV_CLASS_CATEGORY_NA() {
        return AV_CLASS_CATEGORY_NA;
    }
    private static final int AV_CLASS_CATEGORY_INPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_INPUT = 1
     * }
     */
    public static int AV_CLASS_CATEGORY_INPUT() {
        return AV_CLASS_CATEGORY_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_OUTPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_OUTPUT = 2
     * }
     */
    public static int AV_CLASS_CATEGORY_OUTPUT() {
        return AV_CLASS_CATEGORY_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_MUXER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_MUXER = 3
     * }
     */
    public static int AV_CLASS_CATEGORY_MUXER() {
        return AV_CLASS_CATEGORY_MUXER;
    }
    private static final int AV_CLASS_CATEGORY_DEMUXER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEMUXER = 4
     * }
     */
    public static int AV_CLASS_CATEGORY_DEMUXER() {
        return AV_CLASS_CATEGORY_DEMUXER;
    }
    private static final int AV_CLASS_CATEGORY_ENCODER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_ENCODER = 5
     * }
     */
    public static int AV_CLASS_CATEGORY_ENCODER() {
        return AV_CLASS_CATEGORY_ENCODER;
    }
    private static final int AV_CLASS_CATEGORY_DECODER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DECODER = 6
     * }
     */
    public static int AV_CLASS_CATEGORY_DECODER() {
        return AV_CLASS_CATEGORY_DECODER;
    }
    private static final int AV_CLASS_CATEGORY_FILTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_FILTER = 7
     * }
     */
    public static int AV_CLASS_CATEGORY_FILTER() {
        return AV_CLASS_CATEGORY_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_BITSTREAM_FILTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8
     * }
     */
    public static int AV_CLASS_CATEGORY_BITSTREAM_FILTER() {
        return AV_CLASS_CATEGORY_BITSTREAM_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_SWSCALER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWSCALER = 9
     * }
     */
    public static int AV_CLASS_CATEGORY_SWSCALER() {
        return AV_CLASS_CATEGORY_SWSCALER;
    }
    private static final int AV_CLASS_CATEGORY_SWRESAMPLER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWRESAMPLER = 10
     * }
     */
    public static int AV_CLASS_CATEGORY_SWRESAMPLER() {
        return AV_CLASS_CATEGORY_SWRESAMPLER;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_OUTPUT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_INPUT = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_INPUT = 45
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_NB = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NB = 46
     * }
     */
    public static int AV_CLASS_CATEGORY_NB() {
        return AV_CLASS_CATEGORY_NB;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log(void *avcl, int level, const char *fmt, ...)
     * }
     */
    public static class av_log {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                FFmpeg.C_POINTER,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log(void *avcl, int level, const char *fmt, ...)
         * }
         */
        public static av_log makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int level, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log", avcl, level, fmt, x3);
                }
                 spreader.invokeExact(avcl, level, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
     * }
     */
    public static class av_log_once {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                FFmpeg.C_POINTER,
                FFmpeg.C_INT,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_once");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log_once(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
         * }
         */
        public static av_log_once makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log_once(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int initial_level, int subsequent_level, MemorySegment state, MemorySegment fmt, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log_once", avcl, initial_level, subsequent_level, state, fmt, x5);
                }
                 spreader.invokeExact(avcl, initial_level, subsequent_level, state, fmt, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class av_vlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_vlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_vlog$descriptor() {
        return av_vlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_vlog$handle() {
        return av_vlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MemorySegment av_vlog$address() {
        return av_vlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_vlog(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_vlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_vlog", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_get_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static FunctionDescriptor av_log_get_level$descriptor() {
        return av_log_get_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static MethodHandle av_log_get_level$handle() {
        return av_log_get_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static MemorySegment av_log_get_level$address() {
        return av_log_get_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static int av_log_get_level() {
        var mh$ = av_log_get_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_level");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_set_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static FunctionDescriptor av_log_set_level$descriptor() {
        return av_log_set_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MethodHandle av_log_set_level$handle() {
        return av_log_set_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MemorySegment av_log_set_level$address() {
        return av_log_set_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static void av_log_set_level(int level) {
        var mh$ = av_log_set_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_level", level);
            }
            mh$.invokeExact(level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_set_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, struct __va_list_tag *))
     * }
     */
    public static FunctionDescriptor av_log_set_callback$descriptor() {
        return av_log_set_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, struct __va_list_tag *))
     * }
     */
    public static MethodHandle av_log_set_callback$handle() {
        return av_log_set_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, struct __va_list_tag *))
     * }
     */
    public static MemorySegment av_log_set_callback$address() {
        return av_log_set_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, struct __va_list_tag *))
     * }
     */
    public static void av_log_set_callback(MemorySegment callback) {
        var mh$ = av_log_set_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_callback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_default_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_default_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_log_default_callback$descriptor() {
        return av_log_default_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_log_default_callback$handle() {
        return av_log_default_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MemorySegment av_log_default_callback$address() {
        return av_log_default_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_log_default_callback(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_log_default_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_default_callback", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_item_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_default_item_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static FunctionDescriptor av_default_item_name$descriptor() {
        return av_default_item_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MethodHandle av_default_item_name$handle() {
        return av_default_item_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MemorySegment av_default_item_name$address() {
        return av_default_item_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MemorySegment av_default_item_name(MemorySegment ctx) {
        var mh$ = av_default_item_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_item_name", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_get_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_default_get_category");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static FunctionDescriptor av_default_get_category$descriptor() {
        return av_default_get_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static MethodHandle av_default_get_category$handle() {
        return av_default_get_category.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static MemorySegment av_default_get_category$address() {
        return av_default_get_category.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static int av_default_get_category(MemorySegment ptr) {
        var mh$ = av_default_get_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_get_category", ptr);
            }
            return (int)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_format_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line$descriptor() {
        return av_log_format_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line$handle() {
        return av_log_format_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MemorySegment av_log_format_line$address() {
        return av_log_format_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static void av_log_format_line(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_format_line2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line2$descriptor() {
        return av_log_format_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line2$handle() {
        return av_log_format_line2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MemorySegment av_log_format_line2$address() {
        return av_log_format_line2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static int av_log_format_line2(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line2", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            return (int)mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_set_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static FunctionDescriptor av_log_set_flags$descriptor() {
        return av_log_set_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static MethodHandle av_log_set_flags$handle() {
        return av_log_set_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static MemorySegment av_log_set_flags$address() {
        return av_log_set_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static void av_log_set_flags(int arg) {
        var mh$ = av_log_set_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_flags", arg);
            }
            mh$.invokeExact(arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_log_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static FunctionDescriptor av_log_get_flags$descriptor() {
        return av_log_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static MethodHandle av_log_get_flags$handle() {
        return av_log_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static MemorySegment av_log_get_flags$address() {
        return av_log_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static int av_log_get_flags() {
        var mh$ = av_log_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_flags");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PIX_FMT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NONE = -1
     * }
     */
    public static int AV_PIX_FMT_NONE() {
        return AV_PIX_FMT_NONE;
    }
    private static final int AV_PIX_FMT_YUV420P = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P = 0
     * }
     */
    public static int AV_PIX_FMT_YUV420P() {
        return AV_PIX_FMT_YUV420P;
    }
    private static final int AV_PIX_FMT_YUYV422 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUYV422 = 1
     * }
     */
    public static int AV_PIX_FMT_YUYV422() {
        return AV_PIX_FMT_YUYV422;
    }
    private static final int AV_PIX_FMT_RGB24 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB24 = 2
     * }
     */
    public static int AV_PIX_FMT_RGB24() {
        return AV_PIX_FMT_RGB24;
    }
    private static final int AV_PIX_FMT_BGR24 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR24 = 3
     * }
     */
    public static int AV_PIX_FMT_BGR24() {
        return AV_PIX_FMT_BGR24;
    }
    private static final int AV_PIX_FMT_YUV422P = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P = 4
     * }
     */
    public static int AV_PIX_FMT_YUV422P() {
        return AV_PIX_FMT_YUV422P;
    }
    private static final int AV_PIX_FMT_YUV444P = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P = 5
     * }
     */
    public static int AV_PIX_FMT_YUV444P() {
        return AV_PIX_FMT_YUV444P;
    }
    private static final int AV_PIX_FMT_YUV410P = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV410P = 6
     * }
     */
    public static int AV_PIX_FMT_YUV410P() {
        return AV_PIX_FMT_YUV410P;
    }
    private static final int AV_PIX_FMT_YUV411P = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV411P = 7
     * }
     */
    public static int AV_PIX_FMT_YUV411P() {
        return AV_PIX_FMT_YUV411P;
    }
    private static final int AV_PIX_FMT_GRAY8 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8 = 8
     * }
     */
    public static int AV_PIX_FMT_GRAY8() {
        return AV_PIX_FMT_GRAY8;
    }
    private static final int AV_PIX_FMT_MONOWHITE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOWHITE = 9
     * }
     */
    public static int AV_PIX_FMT_MONOWHITE() {
        return AV_PIX_FMT_MONOWHITE;
    }
    private static final int AV_PIX_FMT_MONOBLACK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOBLACK = 10
     * }
     */
    public static int AV_PIX_FMT_MONOBLACK() {
        return AV_PIX_FMT_MONOBLACK;
    }
    private static final int AV_PIX_FMT_PAL8 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_PAL8 = 11
     * }
     */
    public static int AV_PIX_FMT_PAL8() {
        return AV_PIX_FMT_PAL8;
    }
    private static final int AV_PIX_FMT_YUVJ420P = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ420P = 12
     * }
     */
    public static int AV_PIX_FMT_YUVJ420P() {
        return AV_PIX_FMT_YUVJ420P;
    }
    private static final int AV_PIX_FMT_YUVJ422P = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ422P = 13
     * }
     */
    public static int AV_PIX_FMT_YUVJ422P() {
        return AV_PIX_FMT_YUVJ422P;
    }
    private static final int AV_PIX_FMT_YUVJ444P = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ444P = 14
     * }
     */
    public static int AV_PIX_FMT_YUVJ444P() {
        return AV_PIX_FMT_YUVJ444P;
    }
    private static final int AV_PIX_FMT_UYVY422 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYVY422 = 15
     * }
     */
    public static int AV_PIX_FMT_UYVY422() {
        return AV_PIX_FMT_UYVY422;
    }
    private static final int AV_PIX_FMT_UYYVYY411 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYYVYY411 = 16
     * }
     */
    public static int AV_PIX_FMT_UYYVYY411() {
        return AV_PIX_FMT_UYYVYY411;
    }
    private static final int AV_PIX_FMT_BGR8 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR8 = 17
     * }
     */
    public static int AV_PIX_FMT_BGR8() {
        return AV_PIX_FMT_BGR8;
    }
    private static final int AV_PIX_FMT_BGR4 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4 = 18
     * }
     */
    public static int AV_PIX_FMT_BGR4() {
        return AV_PIX_FMT_BGR4;
    }
    private static final int AV_PIX_FMT_BGR4_BYTE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4_BYTE = 19
     * }
     */
    public static int AV_PIX_FMT_BGR4_BYTE() {
        return AV_PIX_FMT_BGR4_BYTE;
    }
    private static final int AV_PIX_FMT_RGB8 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB8 = 20
     * }
     */
    public static int AV_PIX_FMT_RGB8() {
        return AV_PIX_FMT_RGB8;
    }
    private static final int AV_PIX_FMT_RGB4 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4 = 21
     * }
     */
    public static int AV_PIX_FMT_RGB4() {
        return AV_PIX_FMT_RGB4;
    }
    private static final int AV_PIX_FMT_RGB4_BYTE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4_BYTE = 22
     * }
     */
    public static int AV_PIX_FMT_RGB4_BYTE() {
        return AV_PIX_FMT_RGB4_BYTE;
    }
    private static final int AV_PIX_FMT_NV12 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV12 = 23
     * }
     */
    public static int AV_PIX_FMT_NV12() {
        return AV_PIX_FMT_NV12;
    }
    private static final int AV_PIX_FMT_NV21 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV21 = 24
     * }
     */
    public static int AV_PIX_FMT_NV21() {
        return AV_PIX_FMT_NV21;
    }
    private static final int AV_PIX_FMT_ARGB = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ARGB = 25
     * }
     */
    public static int AV_PIX_FMT_ARGB() {
        return AV_PIX_FMT_ARGB;
    }
    private static final int AV_PIX_FMT_RGBA = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA = 26
     * }
     */
    public static int AV_PIX_FMT_RGBA() {
        return AV_PIX_FMT_RGBA;
    }
    private static final int AV_PIX_FMT_ABGR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ABGR = 27
     * }
     */
    public static int AV_PIX_FMT_ABGR() {
        return AV_PIX_FMT_ABGR;
    }
    private static final int AV_PIX_FMT_BGRA = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA = 28
     * }
     */
    public static int AV_PIX_FMT_BGRA() {
        return AV_PIX_FMT_BGRA;
    }
    private static final int AV_PIX_FMT_GRAY16BE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16BE = 29
     * }
     */
    public static int AV_PIX_FMT_GRAY16BE() {
        return AV_PIX_FMT_GRAY16BE;
    }
    private static final int AV_PIX_FMT_GRAY16LE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16LE = 30
     * }
     */
    public static int AV_PIX_FMT_GRAY16LE() {
        return AV_PIX_FMT_GRAY16LE;
    }
    private static final int AV_PIX_FMT_YUV440P = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P = 31
     * }
     */
    public static int AV_PIX_FMT_YUV440P() {
        return AV_PIX_FMT_YUV440P;
    }
    private static final int AV_PIX_FMT_YUVJ440P = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ440P = 32
     * }
     */
    public static int AV_PIX_FMT_YUVJ440P() {
        return AV_PIX_FMT_YUVJ440P;
    }
    private static final int AV_PIX_FMT_YUVA420P = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P = 33
     * }
     */
    public static int AV_PIX_FMT_YUVA420P() {
        return AV_PIX_FMT_YUVA420P;
    }
    private static final int AV_PIX_FMT_RGB48BE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48BE = 34
     * }
     */
    public static int AV_PIX_FMT_RGB48BE() {
        return AV_PIX_FMT_RGB48BE;
    }
    private static final int AV_PIX_FMT_RGB48LE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48LE = 35
     * }
     */
    public static int AV_PIX_FMT_RGB48LE() {
        return AV_PIX_FMT_RGB48LE;
    }
    private static final int AV_PIX_FMT_RGB565BE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565BE = 36
     * }
     */
    public static int AV_PIX_FMT_RGB565BE() {
        return AV_PIX_FMT_RGB565BE;
    }
    private static final int AV_PIX_FMT_RGB565LE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565LE = 37
     * }
     */
    public static int AV_PIX_FMT_RGB565LE() {
        return AV_PIX_FMT_RGB565LE;
    }
    private static final int AV_PIX_FMT_RGB555BE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555BE = 38
     * }
     */
    public static int AV_PIX_FMT_RGB555BE() {
        return AV_PIX_FMT_RGB555BE;
    }
    private static final int AV_PIX_FMT_RGB555LE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555LE = 39
     * }
     */
    public static int AV_PIX_FMT_RGB555LE() {
        return AV_PIX_FMT_RGB555LE;
    }
    private static final int AV_PIX_FMT_BGR565BE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565BE = 40
     * }
     */
    public static int AV_PIX_FMT_BGR565BE() {
        return AV_PIX_FMT_BGR565BE;
    }
    private static final int AV_PIX_FMT_BGR565LE = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565LE = 41
     * }
     */
    public static int AV_PIX_FMT_BGR565LE() {
        return AV_PIX_FMT_BGR565LE;
    }
    private static final int AV_PIX_FMT_BGR555BE = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555BE = 42
     * }
     */
    public static int AV_PIX_FMT_BGR555BE() {
        return AV_PIX_FMT_BGR555BE;
    }
    private static final int AV_PIX_FMT_BGR555LE = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555LE = 43
     * }
     */
    public static int AV_PIX_FMT_BGR555LE() {
        return AV_PIX_FMT_BGR555LE;
    }
    private static final int AV_PIX_FMT_VAAPI = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VAAPI = 44
     * }
     */
    public static int AV_PIX_FMT_VAAPI() {
        return AV_PIX_FMT_VAAPI;
    }
    private static final int AV_PIX_FMT_YUV420P16LE = (int)45L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16LE = 45
     * }
     */
    public static int AV_PIX_FMT_YUV420P16LE() {
        return AV_PIX_FMT_YUV420P16LE;
    }
    private static final int AV_PIX_FMT_YUV420P16BE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16BE = 46
     * }
     */
    public static int AV_PIX_FMT_YUV420P16BE() {
        return AV_PIX_FMT_YUV420P16BE;
    }
    private static final int AV_PIX_FMT_YUV422P16LE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16LE = 47
     * }
     */
    public static int AV_PIX_FMT_YUV422P16LE() {
        return AV_PIX_FMT_YUV422P16LE;
    }
    private static final int AV_PIX_FMT_YUV422P16BE = (int)48L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16BE = 48
     * }
     */
    public static int AV_PIX_FMT_YUV422P16BE() {
        return AV_PIX_FMT_YUV422P16BE;
    }
    private static final int AV_PIX_FMT_YUV444P16LE = (int)49L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16LE = 49
     * }
     */
    public static int AV_PIX_FMT_YUV444P16LE() {
        return AV_PIX_FMT_YUV444P16LE;
    }
    private static final int AV_PIX_FMT_YUV444P16BE = (int)50L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16BE = 50
     * }
     */
    public static int AV_PIX_FMT_YUV444P16BE() {
        return AV_PIX_FMT_YUV444P16BE;
    }
    private static final int AV_PIX_FMT_DXVA2_VLD = (int)51L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DXVA2_VLD = 51
     * }
     */
    public static int AV_PIX_FMT_DXVA2_VLD() {
        return AV_PIX_FMT_DXVA2_VLD;
    }
    private static final int AV_PIX_FMT_RGB444LE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444LE = 52
     * }
     */
    public static int AV_PIX_FMT_RGB444LE() {
        return AV_PIX_FMT_RGB444LE;
    }
    private static final int AV_PIX_FMT_RGB444BE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444BE = 53
     * }
     */
    public static int AV_PIX_FMT_RGB444BE() {
        return AV_PIX_FMT_RGB444BE;
    }
    private static final int AV_PIX_FMT_BGR444LE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444LE = 54
     * }
     */
    public static int AV_PIX_FMT_BGR444LE() {
        return AV_PIX_FMT_BGR444LE;
    }
    private static final int AV_PIX_FMT_BGR444BE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444BE = 55
     * }
     */
    public static int AV_PIX_FMT_BGR444BE() {
        return AV_PIX_FMT_BGR444BE;
    }
    private static final int AV_PIX_FMT_YA8 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA8 = 56
     * }
     */
    public static int AV_PIX_FMT_YA8() {
        return AV_PIX_FMT_YA8;
    }
    private static final int AV_PIX_FMT_Y400A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y400A = 56
     * }
     */
    public static int AV_PIX_FMT_Y400A() {
        return AV_PIX_FMT_Y400A;
    }
    private static final int AV_PIX_FMT_GRAY8A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8A = 56
     * }
     */
    public static int AV_PIX_FMT_GRAY8A() {
        return AV_PIX_FMT_GRAY8A;
    }
    private static final int AV_PIX_FMT_BGR48BE = (int)57L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48BE = 57
     * }
     */
    public static int AV_PIX_FMT_BGR48BE() {
        return AV_PIX_FMT_BGR48BE;
    }
    private static final int AV_PIX_FMT_BGR48LE = (int)58L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48LE = 58
     * }
     */
    public static int AV_PIX_FMT_BGR48LE() {
        return AV_PIX_FMT_BGR48LE;
    }
    private static final int AV_PIX_FMT_YUV420P9BE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9BE = 59
     * }
     */
    public static int AV_PIX_FMT_YUV420P9BE() {
        return AV_PIX_FMT_YUV420P9BE;
    }
    private static final int AV_PIX_FMT_YUV420P9LE = (int)60L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9LE = 60
     * }
     */
    public static int AV_PIX_FMT_YUV420P9LE() {
        return AV_PIX_FMT_YUV420P9LE;
    }
    private static final int AV_PIX_FMT_YUV420P10BE = (int)61L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10BE = 61
     * }
     */
    public static int AV_PIX_FMT_YUV420P10BE() {
        return AV_PIX_FMT_YUV420P10BE;
    }
    private static final int AV_PIX_FMT_YUV420P10LE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10LE = 62
     * }
     */
    public static int AV_PIX_FMT_YUV420P10LE() {
        return AV_PIX_FMT_YUV420P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P10BE = (int)63L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10BE = 63
     * }
     */
    public static int AV_PIX_FMT_YUV422P10BE() {
        return AV_PIX_FMT_YUV422P10BE;
    }
    private static final int AV_PIX_FMT_YUV422P10LE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10LE = 64
     * }
     */
    public static int AV_PIX_FMT_YUV422P10LE() {
        return AV_PIX_FMT_YUV422P10LE;
    }
    private static final int AV_PIX_FMT_YUV444P9BE = (int)65L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9BE = 65
     * }
     */
    public static int AV_PIX_FMT_YUV444P9BE() {
        return AV_PIX_FMT_YUV444P9BE;
    }
    private static final int AV_PIX_FMT_YUV444P9LE = (int)66L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9LE = 66
     * }
     */
    public static int AV_PIX_FMT_YUV444P9LE() {
        return AV_PIX_FMT_YUV444P9LE;
    }
    private static final int AV_PIX_FMT_YUV444P10BE = (int)67L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10BE = 67
     * }
     */
    public static int AV_PIX_FMT_YUV444P10BE() {
        return AV_PIX_FMT_YUV444P10BE;
    }
    private static final int AV_PIX_FMT_YUV444P10LE = (int)68L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10LE = 68
     * }
     */
    public static int AV_PIX_FMT_YUV444P10LE() {
        return AV_PIX_FMT_YUV444P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P9BE = (int)69L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9BE = 69
     * }
     */
    public static int AV_PIX_FMT_YUV422P9BE() {
        return AV_PIX_FMT_YUV422P9BE;
    }
    private static final int AV_PIX_FMT_YUV422P9LE = (int)70L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9LE = 70
     * }
     */
    public static int AV_PIX_FMT_YUV422P9LE() {
        return AV_PIX_FMT_YUV422P9LE;
    }
    private static final int AV_PIX_FMT_GBRP = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP = 71
     * }
     */
    public static int AV_PIX_FMT_GBRP() {
        return AV_PIX_FMT_GBRP;
    }
    private static final int AV_PIX_FMT_GBR24P = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBR24P = 71
     * }
     */
    public static int AV_PIX_FMT_GBR24P() {
        return AV_PIX_FMT_GBR24P;
    }
    private static final int AV_PIX_FMT_GBRP9BE = (int)72L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9BE = 72
     * }
     */
    public static int AV_PIX_FMT_GBRP9BE() {
        return AV_PIX_FMT_GBRP9BE;
    }
    private static final int AV_PIX_FMT_GBRP9LE = (int)73L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9LE = 73
     * }
     */
    public static int AV_PIX_FMT_GBRP9LE() {
        return AV_PIX_FMT_GBRP9LE;
    }
    private static final int AV_PIX_FMT_GBRP10BE = (int)74L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10BE = 74
     * }
     */
    public static int AV_PIX_FMT_GBRP10BE() {
        return AV_PIX_FMT_GBRP10BE;
    }
    private static final int AV_PIX_FMT_GBRP10LE = (int)75L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10LE = 75
     * }
     */
    public static int AV_PIX_FMT_GBRP10LE() {
        return AV_PIX_FMT_GBRP10LE;
    }
    private static final int AV_PIX_FMT_GBRP16BE = (int)76L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16BE = 76
     * }
     */
    public static int AV_PIX_FMT_GBRP16BE() {
        return AV_PIX_FMT_GBRP16BE;
    }
    private static final int AV_PIX_FMT_GBRP16LE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16LE = 77
     * }
     */
    public static int AV_PIX_FMT_GBRP16LE() {
        return AV_PIX_FMT_GBRP16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P = (int)78L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P = 78
     * }
     */
    public static int AV_PIX_FMT_YUVA422P() {
        return AV_PIX_FMT_YUVA422P;
    }
    private static final int AV_PIX_FMT_YUVA444P = (int)79L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P = 79
     * }
     */
    public static int AV_PIX_FMT_YUVA444P() {
        return AV_PIX_FMT_YUVA444P;
    }
    private static final int AV_PIX_FMT_YUVA420P9BE = (int)80L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9BE = 80
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9BE() {
        return AV_PIX_FMT_YUVA420P9BE;
    }
    private static final int AV_PIX_FMT_YUVA420P9LE = (int)81L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9LE = 81
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9LE() {
        return AV_PIX_FMT_YUVA420P9LE;
    }
    private static final int AV_PIX_FMT_YUVA422P9BE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9BE = 82
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9BE() {
        return AV_PIX_FMT_YUVA422P9BE;
    }
    private static final int AV_PIX_FMT_YUVA422P9LE = (int)83L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9LE = 83
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9LE() {
        return AV_PIX_FMT_YUVA422P9LE;
    }
    private static final int AV_PIX_FMT_YUVA444P9BE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9BE = 84
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9BE() {
        return AV_PIX_FMT_YUVA444P9BE;
    }
    private static final int AV_PIX_FMT_YUVA444P9LE = (int)85L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9LE = 85
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9LE() {
        return AV_PIX_FMT_YUVA444P9LE;
    }
    private static final int AV_PIX_FMT_YUVA420P10BE = (int)86L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10BE = 86
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10BE() {
        return AV_PIX_FMT_YUVA420P10BE;
    }
    private static final int AV_PIX_FMT_YUVA420P10LE = (int)87L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10LE = 87
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10LE() {
        return AV_PIX_FMT_YUVA420P10LE;
    }
    private static final int AV_PIX_FMT_YUVA422P10BE = (int)88L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10BE = 88
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10BE() {
        return AV_PIX_FMT_YUVA422P10BE;
    }
    private static final int AV_PIX_FMT_YUVA422P10LE = (int)89L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10LE = 89
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10LE() {
        return AV_PIX_FMT_YUVA422P10LE;
    }
    private static final int AV_PIX_FMT_YUVA444P10BE = (int)90L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10BE = 90
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10BE() {
        return AV_PIX_FMT_YUVA444P10BE;
    }
    private static final int AV_PIX_FMT_YUVA444P10LE = (int)91L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10LE = 91
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10LE() {
        return AV_PIX_FMT_YUVA444P10LE;
    }
    private static final int AV_PIX_FMT_YUVA420P16BE = (int)92L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16BE = 92
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16BE() {
        return AV_PIX_FMT_YUVA420P16BE;
    }
    private static final int AV_PIX_FMT_YUVA420P16LE = (int)93L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16LE = 93
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16LE() {
        return AV_PIX_FMT_YUVA420P16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P16BE = (int)94L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16BE = 94
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16BE() {
        return AV_PIX_FMT_YUVA422P16BE;
    }
    private static final int AV_PIX_FMT_YUVA422P16LE = (int)95L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16LE = 95
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16LE() {
        return AV_PIX_FMT_YUVA422P16LE;
    }
    private static final int AV_PIX_FMT_YUVA444P16BE = (int)96L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16BE = 96
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16BE() {
        return AV_PIX_FMT_YUVA444P16BE;
    }
    private static final int AV_PIX_FMT_YUVA444P16LE = (int)97L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16LE = 97
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16LE() {
        return AV_PIX_FMT_YUVA444P16LE;
    }
    private static final int AV_PIX_FMT_VDPAU = (int)98L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VDPAU = 98
     * }
     */
    public static int AV_PIX_FMT_VDPAU() {
        return AV_PIX_FMT_VDPAU;
    }
    private static final int AV_PIX_FMT_XYZ12LE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12LE = 99
     * }
     */
    public static int AV_PIX_FMT_XYZ12LE() {
        return AV_PIX_FMT_XYZ12LE;
    }
    private static final int AV_PIX_FMT_XYZ12BE = (int)100L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12BE = 100
     * }
     */
    public static int AV_PIX_FMT_XYZ12BE() {
        return AV_PIX_FMT_XYZ12BE;
    }
    private static final int AV_PIX_FMT_NV16 = (int)101L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV16 = 101
     * }
     */
    public static int AV_PIX_FMT_NV16() {
        return AV_PIX_FMT_NV16;
    }
    private static final int AV_PIX_FMT_NV20LE = (int)102L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20LE = 102
     * }
     */
    public static int AV_PIX_FMT_NV20LE() {
        return AV_PIX_FMT_NV20LE;
    }
    private static final int AV_PIX_FMT_NV20BE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20BE = 103
     * }
     */
    public static int AV_PIX_FMT_NV20BE() {
        return AV_PIX_FMT_NV20BE;
    }
    private static final int AV_PIX_FMT_RGBA64BE = (int)104L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64BE = 104
     * }
     */
    public static int AV_PIX_FMT_RGBA64BE() {
        return AV_PIX_FMT_RGBA64BE;
    }
    private static final int AV_PIX_FMT_RGBA64LE = (int)105L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64LE = 105
     * }
     */
    public static int AV_PIX_FMT_RGBA64LE() {
        return AV_PIX_FMT_RGBA64LE;
    }
    private static final int AV_PIX_FMT_BGRA64BE = (int)106L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64BE = 106
     * }
     */
    public static int AV_PIX_FMT_BGRA64BE() {
        return AV_PIX_FMT_BGRA64BE;
    }
    private static final int AV_PIX_FMT_BGRA64LE = (int)107L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64LE = 107
     * }
     */
    public static int AV_PIX_FMT_BGRA64LE() {
        return AV_PIX_FMT_BGRA64LE;
    }
    private static final int AV_PIX_FMT_YVYU422 = (int)108L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YVYU422 = 108
     * }
     */
    public static int AV_PIX_FMT_YVYU422() {
        return AV_PIX_FMT_YVYU422;
    }
    private static final int AV_PIX_FMT_YA16BE = (int)109L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16BE = 109
     * }
     */
    public static int AV_PIX_FMT_YA16BE() {
        return AV_PIX_FMT_YA16BE;
    }
    private static final int AV_PIX_FMT_YA16LE = (int)110L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16LE = 110
     * }
     */
    public static int AV_PIX_FMT_YA16LE() {
        return AV_PIX_FMT_YA16LE;
    }
    private static final int AV_PIX_FMT_GBRAP = (int)111L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP = 111
     * }
     */
    public static int AV_PIX_FMT_GBRAP() {
        return AV_PIX_FMT_GBRAP;
    }
    private static final int AV_PIX_FMT_GBRAP16BE = (int)112L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16BE = 112
     * }
     */
    public static int AV_PIX_FMT_GBRAP16BE() {
        return AV_PIX_FMT_GBRAP16BE;
    }
    private static final int AV_PIX_FMT_GBRAP16LE = (int)113L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16LE = 113
     * }
     */
    public static int AV_PIX_FMT_GBRAP16LE() {
        return AV_PIX_FMT_GBRAP16LE;
    }
    private static final int AV_PIX_FMT_QSV = (int)114L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_QSV = 114
     * }
     */
    public static int AV_PIX_FMT_QSV() {
        return AV_PIX_FMT_QSV;
    }
    private static final int AV_PIX_FMT_MMAL = (int)115L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MMAL = 115
     * }
     */
    public static int AV_PIX_FMT_MMAL() {
        return AV_PIX_FMT_MMAL;
    }
    private static final int AV_PIX_FMT_D3D11VA_VLD = (int)116L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11VA_VLD = 116
     * }
     */
    public static int AV_PIX_FMT_D3D11VA_VLD() {
        return AV_PIX_FMT_D3D11VA_VLD;
    }
    private static final int AV_PIX_FMT_CUDA = (int)117L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_CUDA = 117
     * }
     */
    public static int AV_PIX_FMT_CUDA() {
        return AV_PIX_FMT_CUDA;
    }
    private static final int AV_PIX_FMT_0RGB = (int)118L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0RGB = 118
     * }
     */
    public static int AV_PIX_FMT_0RGB() {
        return AV_PIX_FMT_0RGB;
    }
    private static final int AV_PIX_FMT_RGB0 = (int)119L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB0 = 119
     * }
     */
    public static int AV_PIX_FMT_RGB0() {
        return AV_PIX_FMT_RGB0;
    }
    private static final int AV_PIX_FMT_0BGR = (int)120L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0BGR = 120
     * }
     */
    public static int AV_PIX_FMT_0BGR() {
        return AV_PIX_FMT_0BGR;
    }
    private static final int AV_PIX_FMT_BGR0 = (int)121L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR0 = 121
     * }
     */
    public static int AV_PIX_FMT_BGR0() {
        return AV_PIX_FMT_BGR0;
    }
    private static final int AV_PIX_FMT_YUV420P12BE = (int)122L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12BE = 122
     * }
     */
    public static int AV_PIX_FMT_YUV420P12BE() {
        return AV_PIX_FMT_YUV420P12BE;
    }
    private static final int AV_PIX_FMT_YUV420P12LE = (int)123L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12LE = 123
     * }
     */
    public static int AV_PIX_FMT_YUV420P12LE() {
        return AV_PIX_FMT_YUV420P12LE;
    }
    private static final int AV_PIX_FMT_YUV420P14BE = (int)124L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14BE = 124
     * }
     */
    public static int AV_PIX_FMT_YUV420P14BE() {
        return AV_PIX_FMT_YUV420P14BE;
    }
    private static final int AV_PIX_FMT_YUV420P14LE = (int)125L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14LE = 125
     * }
     */
    public static int AV_PIX_FMT_YUV420P14LE() {
        return AV_PIX_FMT_YUV420P14LE;
    }
    private static final int AV_PIX_FMT_YUV422P12BE = (int)126L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12BE = 126
     * }
     */
    public static int AV_PIX_FMT_YUV422P12BE() {
        return AV_PIX_FMT_YUV422P12BE;
    }
    private static final int AV_PIX_FMT_YUV422P12LE = (int)127L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12LE = 127
     * }
     */
    public static int AV_PIX_FMT_YUV422P12LE() {
        return AV_PIX_FMT_YUV422P12LE;
    }
    private static final int AV_PIX_FMT_YUV422P14BE = (int)128L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14BE = 128
     * }
     */
    public static int AV_PIX_FMT_YUV422P14BE() {
        return AV_PIX_FMT_YUV422P14BE;
    }
    private static final int AV_PIX_FMT_YUV422P14LE = (int)129L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14LE = 129
     * }
     */
    public static int AV_PIX_FMT_YUV422P14LE() {
        return AV_PIX_FMT_YUV422P14LE;
    }
    private static final int AV_PIX_FMT_YUV444P12BE = (int)130L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12BE = 130
     * }
     */
    public static int AV_PIX_FMT_YUV444P12BE() {
        return AV_PIX_FMT_YUV444P12BE;
    }
    private static final int AV_PIX_FMT_YUV444P12LE = (int)131L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12LE = 131
     * }
     */
    public static int AV_PIX_FMT_YUV444P12LE() {
        return AV_PIX_FMT_YUV444P12LE;
    }
    private static final int AV_PIX_FMT_YUV444P14BE = (int)132L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14BE = 132
     * }
     */
    public static int AV_PIX_FMT_YUV444P14BE() {
        return AV_PIX_FMT_YUV444P14BE;
    }
    private static final int AV_PIX_FMT_YUV444P14LE = (int)133L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14LE = 133
     * }
     */
    public static int AV_PIX_FMT_YUV444P14LE() {
        return AV_PIX_FMT_YUV444P14LE;
    }
    private static final int AV_PIX_FMT_GBRP12BE = (int)134L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12BE = 134
     * }
     */
    public static int AV_PIX_FMT_GBRP12BE() {
        return AV_PIX_FMT_GBRP12BE;
    }
    private static final int AV_PIX_FMT_GBRP12LE = (int)135L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12LE = 135
     * }
     */
    public static int AV_PIX_FMT_GBRP12LE() {
        return AV_PIX_FMT_GBRP12LE;
    }
    private static final int AV_PIX_FMT_GBRP14BE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14BE = 136
     * }
     */
    public static int AV_PIX_FMT_GBRP14BE() {
        return AV_PIX_FMT_GBRP14BE;
    }
    private static final int AV_PIX_FMT_GBRP14LE = (int)137L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14LE = 137
     * }
     */
    public static int AV_PIX_FMT_GBRP14LE() {
        return AV_PIX_FMT_GBRP14LE;
    }
    private static final int AV_PIX_FMT_YUVJ411P = (int)138L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ411P = 138
     * }
     */
    public static int AV_PIX_FMT_YUVJ411P() {
        return AV_PIX_FMT_YUVJ411P;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR8 = (int)139L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR8 = 139
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR8() {
        return AV_PIX_FMT_BAYER_BGGR8;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB8 = (int)140L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB8 = 140
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB8() {
        return AV_PIX_FMT_BAYER_RGGB8;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG8 = (int)141L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG8 = 141
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG8() {
        return AV_PIX_FMT_BAYER_GBRG8;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG8 = (int)142L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG8 = 142
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG8() {
        return AV_PIX_FMT_BAYER_GRBG8;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16LE = (int)143L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16LE = 143
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16LE() {
        return AV_PIX_FMT_BAYER_BGGR16LE;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16BE = (int)144L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16BE = 144
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16BE() {
        return AV_PIX_FMT_BAYER_BGGR16BE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16LE = (int)145L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16LE = 145
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16LE() {
        return AV_PIX_FMT_BAYER_RGGB16LE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16BE = (int)146L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16BE = 146
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16BE() {
        return AV_PIX_FMT_BAYER_RGGB16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16LE = (int)147L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16LE = 147
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16LE() {
        return AV_PIX_FMT_BAYER_GBRG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16BE = (int)148L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16BE = 148
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16BE() {
        return AV_PIX_FMT_BAYER_GBRG16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16LE = (int)149L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16LE = 149
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16LE() {
        return AV_PIX_FMT_BAYER_GRBG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16BE = (int)150L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16BE = 150
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16BE() {
        return AV_PIX_FMT_BAYER_GRBG16BE;
    }
    private static final int AV_PIX_FMT_YUV440P10LE = (int)151L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10LE = 151
     * }
     */
    public static int AV_PIX_FMT_YUV440P10LE() {
        return AV_PIX_FMT_YUV440P10LE;
    }
    private static final int AV_PIX_FMT_YUV440P10BE = (int)152L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10BE = 152
     * }
     */
    public static int AV_PIX_FMT_YUV440P10BE() {
        return AV_PIX_FMT_YUV440P10BE;
    }
    private static final int AV_PIX_FMT_YUV440P12LE = (int)153L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12LE = 153
     * }
     */
    public static int AV_PIX_FMT_YUV440P12LE() {
        return AV_PIX_FMT_YUV440P12LE;
    }
    private static final int AV_PIX_FMT_YUV440P12BE = (int)154L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12BE = 154
     * }
     */
    public static int AV_PIX_FMT_YUV440P12BE() {
        return AV_PIX_FMT_YUV440P12BE;
    }
    private static final int AV_PIX_FMT_AYUV64LE = (int)155L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64LE = 155
     * }
     */
    public static int AV_PIX_FMT_AYUV64LE() {
        return AV_PIX_FMT_AYUV64LE;
    }
    private static final int AV_PIX_FMT_AYUV64BE = (int)156L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64BE = 156
     * }
     */
    public static int AV_PIX_FMT_AYUV64BE() {
        return AV_PIX_FMT_AYUV64BE;
    }
    private static final int AV_PIX_FMT_VIDEOTOOLBOX = (int)157L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VIDEOTOOLBOX = 157
     * }
     */
    public static int AV_PIX_FMT_VIDEOTOOLBOX() {
        return AV_PIX_FMT_VIDEOTOOLBOX;
    }
    private static final int AV_PIX_FMT_P010LE = (int)158L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010LE = 158
     * }
     */
    public static int AV_PIX_FMT_P010LE() {
        return AV_PIX_FMT_P010LE;
    }
    private static final int AV_PIX_FMT_P010BE = (int)159L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010BE = 159
     * }
     */
    public static int AV_PIX_FMT_P010BE() {
        return AV_PIX_FMT_P010BE;
    }
    private static final int AV_PIX_FMT_GBRAP12BE = (int)160L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12BE = 160
     * }
     */
    public static int AV_PIX_FMT_GBRAP12BE() {
        return AV_PIX_FMT_GBRAP12BE;
    }
    private static final int AV_PIX_FMT_GBRAP12LE = (int)161L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12LE = 161
     * }
     */
    public static int AV_PIX_FMT_GBRAP12LE() {
        return AV_PIX_FMT_GBRAP12LE;
    }
    private static final int AV_PIX_FMT_GBRAP10BE = (int)162L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10BE = 162
     * }
     */
    public static int AV_PIX_FMT_GBRAP10BE() {
        return AV_PIX_FMT_GBRAP10BE;
    }
    private static final int AV_PIX_FMT_GBRAP10LE = (int)163L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10LE = 163
     * }
     */
    public static int AV_PIX_FMT_GBRAP10LE() {
        return AV_PIX_FMT_GBRAP10LE;
    }
    private static final int AV_PIX_FMT_MEDIACODEC = (int)164L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MEDIACODEC = 164
     * }
     */
    public static int AV_PIX_FMT_MEDIACODEC() {
        return AV_PIX_FMT_MEDIACODEC;
    }
    private static final int AV_PIX_FMT_GRAY12BE = (int)165L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12BE = 165
     * }
     */
    public static int AV_PIX_FMT_GRAY12BE() {
        return AV_PIX_FMT_GRAY12BE;
    }
    private static final int AV_PIX_FMT_GRAY12LE = (int)166L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12LE = 166
     * }
     */
    public static int AV_PIX_FMT_GRAY12LE() {
        return AV_PIX_FMT_GRAY12LE;
    }
    private static final int AV_PIX_FMT_GRAY10BE = (int)167L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10BE = 167
     * }
     */
    public static int AV_PIX_FMT_GRAY10BE() {
        return AV_PIX_FMT_GRAY10BE;
    }
    private static final int AV_PIX_FMT_GRAY10LE = (int)168L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10LE = 168
     * }
     */
    public static int AV_PIX_FMT_GRAY10LE() {
        return AV_PIX_FMT_GRAY10LE;
    }
    private static final int AV_PIX_FMT_P016LE = (int)169L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016LE = 169
     * }
     */
    public static int AV_PIX_FMT_P016LE() {
        return AV_PIX_FMT_P016LE;
    }
    private static final int AV_PIX_FMT_P016BE = (int)170L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016BE = 170
     * }
     */
    public static int AV_PIX_FMT_P016BE() {
        return AV_PIX_FMT_P016BE;
    }
    private static final int AV_PIX_FMT_D3D11 = (int)171L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11 = 171
     * }
     */
    public static int AV_PIX_FMT_D3D11() {
        return AV_PIX_FMT_D3D11;
    }
    private static final int AV_PIX_FMT_GRAY9BE = (int)172L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9BE = 172
     * }
     */
    public static int AV_PIX_FMT_GRAY9BE() {
        return AV_PIX_FMT_GRAY9BE;
    }
    private static final int AV_PIX_FMT_GRAY9LE = (int)173L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9LE = 173
     * }
     */
    public static int AV_PIX_FMT_GRAY9LE() {
        return AV_PIX_FMT_GRAY9LE;
    }
    private static final int AV_PIX_FMT_GBRPF32BE = (int)174L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32BE = 174
     * }
     */
    public static int AV_PIX_FMT_GBRPF32BE() {
        return AV_PIX_FMT_GBRPF32BE;
    }
    private static final int AV_PIX_FMT_GBRPF32LE = (int)175L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32LE = 175
     * }
     */
    public static int AV_PIX_FMT_GBRPF32LE() {
        return AV_PIX_FMT_GBRPF32LE;
    }
    private static final int AV_PIX_FMT_GBRAPF32BE = (int)176L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32BE = 176
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32BE() {
        return AV_PIX_FMT_GBRAPF32BE;
    }
    private static final int AV_PIX_FMT_GBRAPF32LE = (int)177L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32LE = 177
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32LE() {
        return AV_PIX_FMT_GBRAPF32LE;
    }
    private static final int AV_PIX_FMT_DRM_PRIME = (int)178L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DRM_PRIME = 178
     * }
     */
    public static int AV_PIX_FMT_DRM_PRIME() {
        return AV_PIX_FMT_DRM_PRIME;
    }
    private static final int AV_PIX_FMT_OPENCL = (int)179L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_OPENCL = 179
     * }
     */
    public static int AV_PIX_FMT_OPENCL() {
        return AV_PIX_FMT_OPENCL;
    }
    private static final int AV_PIX_FMT_GRAY14BE = (int)180L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14BE = 180
     * }
     */
    public static int AV_PIX_FMT_GRAY14BE() {
        return AV_PIX_FMT_GRAY14BE;
    }
    private static final int AV_PIX_FMT_GRAY14LE = (int)181L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14LE = 181
     * }
     */
    public static int AV_PIX_FMT_GRAY14LE() {
        return AV_PIX_FMT_GRAY14LE;
    }
    private static final int AV_PIX_FMT_GRAYF32BE = (int)182L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32BE = 182
     * }
     */
    public static int AV_PIX_FMT_GRAYF32BE() {
        return AV_PIX_FMT_GRAYF32BE;
    }
    private static final int AV_PIX_FMT_GRAYF32LE = (int)183L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32LE = 183
     * }
     */
    public static int AV_PIX_FMT_GRAYF32LE() {
        return AV_PIX_FMT_GRAYF32LE;
    }
    private static final int AV_PIX_FMT_YUVA422P12BE = (int)184L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12BE = 184
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12BE() {
        return AV_PIX_FMT_YUVA422P12BE;
    }
    private static final int AV_PIX_FMT_YUVA422P12LE = (int)185L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12LE = 185
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12LE() {
        return AV_PIX_FMT_YUVA422P12LE;
    }
    private static final int AV_PIX_FMT_YUVA444P12BE = (int)186L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12BE = 186
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12BE() {
        return AV_PIX_FMT_YUVA444P12BE;
    }
    private static final int AV_PIX_FMT_YUVA444P12LE = (int)187L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12LE = 187
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12LE() {
        return AV_PIX_FMT_YUVA444P12LE;
    }
    private static final int AV_PIX_FMT_NV24 = (int)188L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV24 = 188
     * }
     */
    public static int AV_PIX_FMT_NV24() {
        return AV_PIX_FMT_NV24;
    }
    private static final int AV_PIX_FMT_NV42 = (int)189L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV42 = 189
     * }
     */
    public static int AV_PIX_FMT_NV42() {
        return AV_PIX_FMT_NV42;
    }
    private static final int AV_PIX_FMT_VULKAN = (int)190L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VULKAN = 190
     * }
     */
    public static int AV_PIX_FMT_VULKAN() {
        return AV_PIX_FMT_VULKAN;
    }
    private static final int AV_PIX_FMT_Y210BE = (int)191L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210BE = 191
     * }
     */
    public static int AV_PIX_FMT_Y210BE() {
        return AV_PIX_FMT_Y210BE;
    }
    private static final int AV_PIX_FMT_Y210LE = (int)192L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210LE = 192
     * }
     */
    public static int AV_PIX_FMT_Y210LE() {
        return AV_PIX_FMT_Y210LE;
    }
    private static final int AV_PIX_FMT_X2RGB10LE = (int)193L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10LE = 193
     * }
     */
    public static int AV_PIX_FMT_X2RGB10LE() {
        return AV_PIX_FMT_X2RGB10LE;
    }
    private static final int AV_PIX_FMT_X2RGB10BE = (int)194L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10BE = 194
     * }
     */
    public static int AV_PIX_FMT_X2RGB10BE() {
        return AV_PIX_FMT_X2RGB10BE;
    }
    private static final int AV_PIX_FMT_X2BGR10LE = (int)195L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10LE = 195
     * }
     */
    public static int AV_PIX_FMT_X2BGR10LE() {
        return AV_PIX_FMT_X2BGR10LE;
    }
    private static final int AV_PIX_FMT_X2BGR10BE = (int)196L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10BE = 196
     * }
     */
    public static int AV_PIX_FMT_X2BGR10BE() {
        return AV_PIX_FMT_X2BGR10BE;
    }
    private static final int AV_PIX_FMT_P210BE = (int)197L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210BE = 197
     * }
     */
    public static int AV_PIX_FMT_P210BE() {
        return AV_PIX_FMT_P210BE;
    }
    private static final int AV_PIX_FMT_P210LE = (int)198L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210LE = 198
     * }
     */
    public static int AV_PIX_FMT_P210LE() {
        return AV_PIX_FMT_P210LE;
    }
    private static final int AV_PIX_FMT_P410BE = (int)199L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410BE = 199
     * }
     */
    public static int AV_PIX_FMT_P410BE() {
        return AV_PIX_FMT_P410BE;
    }
    private static final int AV_PIX_FMT_P410LE = (int)200L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410LE = 200
     * }
     */
    public static int AV_PIX_FMT_P410LE() {
        return AV_PIX_FMT_P410LE;
    }
    private static final int AV_PIX_FMT_P216BE = (int)201L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216BE = 201
     * }
     */
    public static int AV_PIX_FMT_P216BE() {
        return AV_PIX_FMT_P216BE;
    }
    private static final int AV_PIX_FMT_P216LE = (int)202L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216LE = 202
     * }
     */
    public static int AV_PIX_FMT_P216LE() {
        return AV_PIX_FMT_P216LE;
    }
    private static final int AV_PIX_FMT_P416BE = (int)203L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416BE = 203
     * }
     */
    public static int AV_PIX_FMT_P416BE() {
        return AV_PIX_FMT_P416BE;
    }
    private static final int AV_PIX_FMT_P416LE = (int)204L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416LE = 204
     * }
     */
    public static int AV_PIX_FMT_P416LE() {
        return AV_PIX_FMT_P416LE;
    }
    private static final int AV_PIX_FMT_VUYA = (int)205L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYA = 205
     * }
     */
    public static int AV_PIX_FMT_VUYA() {
        return AV_PIX_FMT_VUYA;
    }
    private static final int AV_PIX_FMT_RGBAF16BE = (int)206L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16BE = 206
     * }
     */
    public static int AV_PIX_FMT_RGBAF16BE() {
        return AV_PIX_FMT_RGBAF16BE;
    }
    private static final int AV_PIX_FMT_RGBAF16LE = (int)207L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16LE = 207
     * }
     */
    public static int AV_PIX_FMT_RGBAF16LE() {
        return AV_PIX_FMT_RGBAF16LE;
    }
    private static final int AV_PIX_FMT_VUYX = (int)208L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYX = 208
     * }
     */
    public static int AV_PIX_FMT_VUYX() {
        return AV_PIX_FMT_VUYX;
    }
    private static final int AV_PIX_FMT_P012LE = (int)209L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012LE = 209
     * }
     */
    public static int AV_PIX_FMT_P012LE() {
        return AV_PIX_FMT_P012LE;
    }
    private static final int AV_PIX_FMT_P012BE = (int)210L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012BE = 210
     * }
     */
    public static int AV_PIX_FMT_P012BE() {
        return AV_PIX_FMT_P012BE;
    }
    private static final int AV_PIX_FMT_Y212BE = (int)211L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212BE = 211
     * }
     */
    public static int AV_PIX_FMT_Y212BE() {
        return AV_PIX_FMT_Y212BE;
    }
    private static final int AV_PIX_FMT_Y212LE = (int)212L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212LE = 212
     * }
     */
    public static int AV_PIX_FMT_Y212LE() {
        return AV_PIX_FMT_Y212LE;
    }
    private static final int AV_PIX_FMT_XV30BE = (int)213L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30BE = 213
     * }
     */
    public static int AV_PIX_FMT_XV30BE() {
        return AV_PIX_FMT_XV30BE;
    }
    private static final int AV_PIX_FMT_XV30LE = (int)214L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30LE = 214
     * }
     */
    public static int AV_PIX_FMT_XV30LE() {
        return AV_PIX_FMT_XV30LE;
    }
    private static final int AV_PIX_FMT_XV36BE = (int)215L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36BE = 215
     * }
     */
    public static int AV_PIX_FMT_XV36BE() {
        return AV_PIX_FMT_XV36BE;
    }
    private static final int AV_PIX_FMT_XV36LE = (int)216L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36LE = 216
     * }
     */
    public static int AV_PIX_FMT_XV36LE() {
        return AV_PIX_FMT_XV36LE;
    }
    private static final int AV_PIX_FMT_RGBF32BE = (int)217L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32BE = 217
     * }
     */
    public static int AV_PIX_FMT_RGBF32BE() {
        return AV_PIX_FMT_RGBF32BE;
    }
    private static final int AV_PIX_FMT_RGBF32LE = (int)218L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32LE = 218
     * }
     */
    public static int AV_PIX_FMT_RGBF32LE() {
        return AV_PIX_FMT_RGBF32LE;
    }
    private static final int AV_PIX_FMT_RGBAF32BE = (int)219L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32BE = 219
     * }
     */
    public static int AV_PIX_FMT_RGBAF32BE() {
        return AV_PIX_FMT_RGBAF32BE;
    }
    private static final int AV_PIX_FMT_RGBAF32LE = (int)220L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32LE = 220
     * }
     */
    public static int AV_PIX_FMT_RGBAF32LE() {
        return AV_PIX_FMT_RGBAF32LE;
    }
    private static final int AV_PIX_FMT_P212BE = (int)221L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P212BE = 221
     * }
     */
    public static int AV_PIX_FMT_P212BE() {
        return AV_PIX_FMT_P212BE;
    }
    private static final int AV_PIX_FMT_P212LE = (int)222L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P212LE = 222
     * }
     */
    public static int AV_PIX_FMT_P212LE() {
        return AV_PIX_FMT_P212LE;
    }
    private static final int AV_PIX_FMT_P412BE = (int)223L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P412BE = 223
     * }
     */
    public static int AV_PIX_FMT_P412BE() {
        return AV_PIX_FMT_P412BE;
    }
    private static final int AV_PIX_FMT_P412LE = (int)224L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P412LE = 224
     * }
     */
    public static int AV_PIX_FMT_P412LE() {
        return AV_PIX_FMT_P412LE;
    }
    private static final int AV_PIX_FMT_GBRAP14BE = (int)225L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP14BE = 225
     * }
     */
    public static int AV_PIX_FMT_GBRAP14BE() {
        return AV_PIX_FMT_GBRAP14BE;
    }
    private static final int AV_PIX_FMT_GBRAP14LE = (int)226L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP14LE = 226
     * }
     */
    public static int AV_PIX_FMT_GBRAP14LE() {
        return AV_PIX_FMT_GBRAP14LE;
    }
    private static final int AV_PIX_FMT_D3D12 = (int)227L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D12 = 227
     * }
     */
    public static int AV_PIX_FMT_D3D12() {
        return AV_PIX_FMT_D3D12;
    }
    private static final int AV_PIX_FMT_NB = (int)228L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NB = 228
     * }
     */
    public static int AV_PIX_FMT_NB() {
        return AV_PIX_FMT_NB;
    }
    private static final int AVCOL_PRI_RESERVED0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_RESERVED0 = 0
     * }
     */
    public static int AVCOL_PRI_RESERVED0() {
        return AVCOL_PRI_RESERVED0;
    }
    private static final int AVCOL_PRI_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT709 = 1
     * }
     */
    public static int AVCOL_PRI_BT709() {
        return AVCOL_PRI_BT709;
    }
    private static final int AVCOL_PRI_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_PRI_UNSPECIFIED() {
        return AVCOL_PRI_UNSPECIFIED;
    }
    private static final int AVCOL_PRI_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_RESERVED = 3
     * }
     */
    public static int AVCOL_PRI_RESERVED() {
        return AVCOL_PRI_RESERVED;
    }
    private static final int AVCOL_PRI_BT470M = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT470M = 4
     * }
     */
    public static int AVCOL_PRI_BT470M() {
        return AVCOL_PRI_BT470M;
    }
    private static final int AVCOL_PRI_BT470BG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT470BG = 5
     * }
     */
    public static int AVCOL_PRI_BT470BG() {
        return AVCOL_PRI_BT470BG;
    }
    private static final int AVCOL_PRI_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE170M = 6
     * }
     */
    public static int AVCOL_PRI_SMPTE170M() {
        return AVCOL_PRI_SMPTE170M;
    }
    private static final int AVCOL_PRI_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE240M = 7
     * }
     */
    public static int AVCOL_PRI_SMPTE240M() {
        return AVCOL_PRI_SMPTE240M;
    }
    private static final int AVCOL_PRI_FILM = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_FILM = 8
     * }
     */
    public static int AVCOL_PRI_FILM() {
        return AVCOL_PRI_FILM;
    }
    private static final int AVCOL_PRI_BT2020 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT2020 = 9
     * }
     */
    public static int AVCOL_PRI_BT2020() {
        return AVCOL_PRI_BT2020;
    }
    private static final int AVCOL_PRI_SMPTE428 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE428 = 10
     * }
     */
    public static int AVCOL_PRI_SMPTE428() {
        return AVCOL_PRI_SMPTE428;
    }
    private static final int AVCOL_PRI_SMPTEST428_1 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTEST428_1 = 10
     * }
     */
    public static int AVCOL_PRI_SMPTEST428_1() {
        return AVCOL_PRI_SMPTEST428_1;
    }
    private static final int AVCOL_PRI_SMPTE431 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE431 = 11
     * }
     */
    public static int AVCOL_PRI_SMPTE431() {
        return AVCOL_PRI_SMPTE431;
    }
    private static final int AVCOL_PRI_SMPTE432 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE432 = 12
     * }
     */
    public static int AVCOL_PRI_SMPTE432() {
        return AVCOL_PRI_SMPTE432;
    }
    private static final int AVCOL_PRI_EBU3213 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_EBU3213 = 22
     * }
     */
    public static int AVCOL_PRI_EBU3213() {
        return AVCOL_PRI_EBU3213;
    }
    private static final int AVCOL_PRI_JEDEC_P22 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_JEDEC_P22 = 22
     * }
     */
    public static int AVCOL_PRI_JEDEC_P22() {
        return AVCOL_PRI_JEDEC_P22;
    }
    private static final int AVCOL_PRI_NB = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_NB = 23
     * }
     */
    public static int AVCOL_PRI_NB() {
        return AVCOL_PRI_NB;
    }
    private static final int AVCOL_TRC_RESERVED0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_RESERVED0 = 0
     * }
     */
    public static int AVCOL_TRC_RESERVED0() {
        return AVCOL_TRC_RESERVED0;
    }
    private static final int AVCOL_TRC_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT709 = 1
     * }
     */
    public static int AVCOL_TRC_BT709() {
        return AVCOL_TRC_BT709;
    }
    private static final int AVCOL_TRC_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_TRC_UNSPECIFIED() {
        return AVCOL_TRC_UNSPECIFIED;
    }
    private static final int AVCOL_TRC_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_RESERVED = 3
     * }
     */
    public static int AVCOL_TRC_RESERVED() {
        return AVCOL_TRC_RESERVED;
    }
    private static final int AVCOL_TRC_GAMMA22 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 = 4
     * }
     */
    public static int AVCOL_TRC_GAMMA22() {
        return AVCOL_TRC_GAMMA22;
    }
    private static final int AVCOL_TRC_GAMMA28 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 = 5
     * }
     */
    public static int AVCOL_TRC_GAMMA28() {
        return AVCOL_TRC_GAMMA28;
    }
    private static final int AVCOL_TRC_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M = 6
     * }
     */
    public static int AVCOL_TRC_SMPTE170M() {
        return AVCOL_TRC_SMPTE170M;
    }
    private static final int AVCOL_TRC_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M = 7
     * }
     */
    public static int AVCOL_TRC_SMPTE240M() {
        return AVCOL_TRC_SMPTE240M;
    }
    private static final int AVCOL_TRC_LINEAR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LINEAR = 8
     * }
     */
    public static int AVCOL_TRC_LINEAR() {
        return AVCOL_TRC_LINEAR;
    }
    private static final int AVCOL_TRC_LOG = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LOG = 9
     * }
     */
    public static int AVCOL_TRC_LOG() {
        return AVCOL_TRC_LOG;
    }
    private static final int AVCOL_TRC_LOG_SQRT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT = 10
     * }
     */
    public static int AVCOL_TRC_LOG_SQRT() {
        return AVCOL_TRC_LOG_SQRT;
    }
    private static final int AVCOL_TRC_IEC61966_2_4 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 = 11
     * }
     */
    public static int AVCOL_TRC_IEC61966_2_4() {
        return AVCOL_TRC_IEC61966_2_4;
    }
    private static final int AVCOL_TRC_BT1361_ECG = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG = 12
     * }
     */
    public static int AVCOL_TRC_BT1361_ECG() {
        return AVCOL_TRC_BT1361_ECG;
    }
    private static final int AVCOL_TRC_IEC61966_2_1 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 = 13
     * }
     */
    public static int AVCOL_TRC_IEC61966_2_1() {
        return AVCOL_TRC_IEC61966_2_1;
    }
    private static final int AVCOL_TRC_BT2020_10 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 = 14
     * }
     */
    public static int AVCOL_TRC_BT2020_10() {
        return AVCOL_TRC_BT2020_10;
    }
    private static final int AVCOL_TRC_BT2020_12 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 = 15
     * }
     */
    public static int AVCOL_TRC_BT2020_12() {
        return AVCOL_TRC_BT2020_12;
    }
    private static final int AVCOL_TRC_SMPTE2084 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 = 16
     * }
     */
    public static int AVCOL_TRC_SMPTE2084() {
        return AVCOL_TRC_SMPTE2084;
    }
    private static final int AVCOL_TRC_SMPTEST2084 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST2084 = 16
     * }
     */
    public static int AVCOL_TRC_SMPTEST2084() {
        return AVCOL_TRC_SMPTEST2084;
    }
    private static final int AVCOL_TRC_SMPTE428 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE428 = 17
     * }
     */
    public static int AVCOL_TRC_SMPTE428() {
        return AVCOL_TRC_SMPTE428;
    }
    private static final int AVCOL_TRC_SMPTEST428_1 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST428_1 = 17
     * }
     */
    public static int AVCOL_TRC_SMPTEST428_1() {
        return AVCOL_TRC_SMPTEST428_1;
    }
    private static final int AVCOL_TRC_ARIB_STD_B67 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 = 18
     * }
     */
    public static int AVCOL_TRC_ARIB_STD_B67() {
        return AVCOL_TRC_ARIB_STD_B67;
    }
    private static final int AVCOL_TRC_NB = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_NB = 19
     * }
     */
    public static int AVCOL_TRC_NB() {
        return AVCOL_TRC_NB;
    }
    private static final int AVCOL_SPC_RGB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_RGB = 0
     * }
     */
    public static int AVCOL_SPC_RGB() {
        return AVCOL_SPC_RGB;
    }
    private static final int AVCOL_SPC_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT709 = 1
     * }
     */
    public static int AVCOL_SPC_BT709() {
        return AVCOL_SPC_BT709;
    }
    private static final int AVCOL_SPC_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_SPC_UNSPECIFIED() {
        return AVCOL_SPC_UNSPECIFIED;
    }
    private static final int AVCOL_SPC_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_RESERVED = 3
     * }
     */
    public static int AVCOL_SPC_RESERVED() {
        return AVCOL_SPC_RESERVED;
    }
    private static final int AVCOL_SPC_FCC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_FCC = 4
     * }
     */
    public static int AVCOL_SPC_FCC() {
        return AVCOL_SPC_FCC;
    }
    private static final int AVCOL_SPC_BT470BG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT470BG = 5
     * }
     */
    public static int AVCOL_SPC_BT470BG() {
        return AVCOL_SPC_BT470BG;
    }
    private static final int AVCOL_SPC_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE170M = 6
     * }
     */
    public static int AVCOL_SPC_SMPTE170M() {
        return AVCOL_SPC_SMPTE170M;
    }
    private static final int AVCOL_SPC_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE240M = 7
     * }
     */
    public static int AVCOL_SPC_SMPTE240M() {
        return AVCOL_SPC_SMPTE240M;
    }
    private static final int AVCOL_SPC_YCGCO = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCGCO = 8
     * }
     */
    public static int AVCOL_SPC_YCGCO() {
        return AVCOL_SPC_YCGCO;
    }
    private static final int AVCOL_SPC_YCOCG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCOCG = 8
     * }
     */
    public static int AVCOL_SPC_YCOCG() {
        return AVCOL_SPC_YCOCG;
    }
    private static final int AVCOL_SPC_BT2020_NCL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT2020_NCL = 9
     * }
     */
    public static int AVCOL_SPC_BT2020_NCL() {
        return AVCOL_SPC_BT2020_NCL;
    }
    private static final int AVCOL_SPC_BT2020_CL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT2020_CL = 10
     * }
     */
    public static int AVCOL_SPC_BT2020_CL() {
        return AVCOL_SPC_BT2020_CL;
    }
    private static final int AVCOL_SPC_SMPTE2085 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE2085 = 11
     * }
     */
    public static int AVCOL_SPC_SMPTE2085() {
        return AVCOL_SPC_SMPTE2085;
    }
    private static final int AVCOL_SPC_CHROMA_DERIVED_NCL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_NCL = 12
     * }
     */
    public static int AVCOL_SPC_CHROMA_DERIVED_NCL() {
        return AVCOL_SPC_CHROMA_DERIVED_NCL;
    }
    private static final int AVCOL_SPC_CHROMA_DERIVED_CL = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_CL = 13
     * }
     */
    public static int AVCOL_SPC_CHROMA_DERIVED_CL() {
        return AVCOL_SPC_CHROMA_DERIVED_CL;
    }
    private static final int AVCOL_SPC_ICTCP = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_ICTCP = 14
     * }
     */
    public static int AVCOL_SPC_ICTCP() {
        return AVCOL_SPC_ICTCP;
    }
    private static final int AVCOL_SPC_IPT_C2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_IPT_C2 = 15
     * }
     */
    public static int AVCOL_SPC_IPT_C2() {
        return AVCOL_SPC_IPT_C2;
    }
    private static final int AVCOL_SPC_YCGCO_RE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCGCO_RE = 16
     * }
     */
    public static int AVCOL_SPC_YCGCO_RE() {
        return AVCOL_SPC_YCGCO_RE;
    }
    private static final int AVCOL_SPC_YCGCO_RO = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCGCO_RO = 17
     * }
     */
    public static int AVCOL_SPC_YCGCO_RO() {
        return AVCOL_SPC_YCGCO_RO;
    }
    private static final int AVCOL_SPC_NB = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_NB = 18
     * }
     */
    public static int AVCOL_SPC_NB() {
        return AVCOL_SPC_NB;
    }
    private static final int AVCOL_RANGE_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_UNSPECIFIED = 0
     * }
     */
    public static int AVCOL_RANGE_UNSPECIFIED() {
        return AVCOL_RANGE_UNSPECIFIED;
    }
    private static final int AVCOL_RANGE_MPEG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_MPEG = 1
     * }
     */
    public static int AVCOL_RANGE_MPEG() {
        return AVCOL_RANGE_MPEG;
    }
    private static final int AVCOL_RANGE_JPEG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_JPEG = 2
     * }
     */
    public static int AVCOL_RANGE_JPEG() {
        return AVCOL_RANGE_JPEG;
    }
    private static final int AVCOL_RANGE_NB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_NB = 3
     * }
     */
    public static int AVCOL_RANGE_NB() {
        return AVCOL_RANGE_NB;
    }
    private static final int AVCHROMA_LOC_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED = 0
     * }
     */
    public static int AVCHROMA_LOC_UNSPECIFIED() {
        return AVCHROMA_LOC_UNSPECIFIED;
    }
    private static final int AVCHROMA_LOC_LEFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_LEFT = 1
     * }
     */
    public static int AVCHROMA_LOC_LEFT() {
        return AVCHROMA_LOC_LEFT;
    }
    private static final int AVCHROMA_LOC_CENTER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_CENTER = 2
     * }
     */
    public static int AVCHROMA_LOC_CENTER() {
        return AVCHROMA_LOC_CENTER;
    }
    private static final int AVCHROMA_LOC_TOPLEFT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_TOPLEFT = 3
     * }
     */
    public static int AVCHROMA_LOC_TOPLEFT() {
        return AVCHROMA_LOC_TOPLEFT;
    }
    private static final int AVCHROMA_LOC_TOP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_TOP = 4
     * }
     */
    public static int AVCHROMA_LOC_TOP() {
        return AVCHROMA_LOC_TOP;
    }
    private static final int AVCHROMA_LOC_BOTTOMLEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_BOTTOMLEFT = 5
     * }
     */
    public static int AVCHROMA_LOC_BOTTOMLEFT() {
        return AVCHROMA_LOC_BOTTOMLEFT;
    }
    private static final int AVCHROMA_LOC_BOTTOM = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_BOTTOM = 6
     * }
     */
    public static int AVCHROMA_LOC_BOTTOM() {
        return AVCHROMA_LOC_BOTTOM;
    }
    private static final int AVCHROMA_LOC_NB = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_NB = 7
     * }
     */
    public static int AVCHROMA_LOC_NB() {
        return AVCHROMA_LOC_NB;
    }

    private static class av_int_list_length_for_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_int_list_length_for_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static FunctionDescriptor av_int_list_length_for_size$descriptor() {
        return av_int_list_length_for_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static MethodHandle av_int_list_length_for_size$handle() {
        return av_int_list_length_for_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static MemorySegment av_int_list_length_for_size$address() {
        return av_int_list_length_for_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static int av_int_list_length_for_size(int elsize, MemorySegment list, long term) {
        var mh$ = av_int_list_length_for_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_int_list_length_for_size", elsize, list, term);
            }
            return (int)mh$.invokeExact(elsize, list, term);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_time_base_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout()    );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_get_time_base_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static FunctionDescriptor av_get_time_base_q$descriptor() {
        return av_get_time_base_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MethodHandle av_get_time_base_q$handle() {
        return av_get_time_base_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MemorySegment av_get_time_base_q$address() {
        return av_get_time_base_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MemorySegment av_get_time_base_q(SegmentAllocator allocator) {
        var mh$ = av_get_time_base_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_time_base_q", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fourcc_make_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_fourcc_make_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static FunctionDescriptor av_fourcc_make_string$descriptor() {
        return av_fourcc_make_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MethodHandle av_fourcc_make_string$handle() {
        return av_fourcc_make_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MemorySegment av_fourcc_make_string$address() {
        return av_fourcc_make_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MemorySegment av_fourcc_make_string(MemorySegment buf, int fourcc) {
        var mh$ = av_fourcc_make_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fourcc_make_string", buf, fourcc);
            }
            return (MemorySegment)mh$.invokeExact(buf, fourcc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_alloc$descriptor() {
        return av_buffer_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MethodHandle av_buffer_alloc$handle() {
        return av_buffer_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MemorySegment av_buffer_alloc$address() {
        return av_buffer_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MemorySegment av_buffer_alloc(long size) {
        var mh$ = av_buffer_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_alloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_allocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_allocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_allocz$descriptor() {
        return av_buffer_allocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MethodHandle av_buffer_allocz$handle() {
        return av_buffer_allocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MemorySegment av_buffer_allocz$address() {
        return av_buffer_allocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MemorySegment av_buffer_allocz(long size) {
        var mh$ = av_buffer_allocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_allocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static FunctionDescriptor av_buffer_create$descriptor() {
        return av_buffer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MethodHandle av_buffer_create$handle() {
        return av_buffer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MemorySegment av_buffer_create$address() {
        return av_buffer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MemorySegment av_buffer_create(MemorySegment data, long size, MemorySegment free, MemorySegment opaque, int flags) {
        var mh$ = av_buffer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_create", data, size, free, opaque, flags);
            }
            return (MemorySegment)mh$.invokeExact(data, size, free, opaque, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_default_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_default_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static FunctionDescriptor av_buffer_default_free$descriptor() {
        return av_buffer_default_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static MethodHandle av_buffer_default_free$handle() {
        return av_buffer_default_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static MemorySegment av_buffer_default_free$address() {
        return av_buffer_default_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static void av_buffer_default_free(MemorySegment opaque, MemorySegment data) {
        var mh$ = av_buffer_default_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_default_free", opaque, data);
            }
            mh$.invokeExact(opaque, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_ref$descriptor() {
        return av_buffer_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_ref$handle() {
        return av_buffer_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_ref$address() {
        return av_buffer_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_ref(MemorySegment buf) {
        var mh$ = av_buffer_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_ref", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static FunctionDescriptor av_buffer_unref$descriptor() {
        return av_buffer_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static MethodHandle av_buffer_unref$handle() {
        return av_buffer_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static MemorySegment av_buffer_unref$address() {
        return av_buffer_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static void av_buffer_unref(MemorySegment buf) {
        var mh$ = av_buffer_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_unref", buf);
            }
            mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_is_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_is_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_is_writable$descriptor() {
        return av_buffer_is_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_is_writable$handle() {
        return av_buffer_is_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_is_writable$address() {
        return av_buffer_is_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static int av_buffer_is_writable(MemorySegment buf) {
        var mh$ = av_buffer_is_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_is_writable", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_get_opaque {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_get_opaque");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_get_opaque$descriptor() {
        return av_buffer_get_opaque.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_get_opaque$handle() {
        return av_buffer_get_opaque.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_get_opaque$address() {
        return av_buffer_get_opaque.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_get_opaque(MemorySegment buf) {
        var mh$ = av_buffer_get_opaque.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_get_opaque", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_get_ref_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_get_ref_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_get_ref_count$descriptor() {
        return av_buffer_get_ref_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_get_ref_count$handle() {
        return av_buffer_get_ref_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_get_ref_count$address() {
        return av_buffer_get_ref_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static int av_buffer_get_ref_count(MemorySegment buf) {
        var mh$ = av_buffer_get_ref_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_get_ref_count", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_make_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static FunctionDescriptor av_buffer_make_writable$descriptor() {
        return av_buffer_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static MethodHandle av_buffer_make_writable$handle() {
        return av_buffer_make_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static MemorySegment av_buffer_make_writable$address() {
        return av_buffer_make_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static int av_buffer_make_writable(MemorySegment buf) {
        var mh$ = av_buffer_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_make_writable", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_realloc$descriptor() {
        return av_buffer_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static MethodHandle av_buffer_realloc$handle() {
        return av_buffer_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static MemorySegment av_buffer_realloc$address() {
        return av_buffer_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static int av_buffer_realloc(MemorySegment buf, long size) {
        var mh$ = av_buffer_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_realloc", buf, size);
            }
            return (int)mh$.invokeExact(buf, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static FunctionDescriptor av_buffer_replace$descriptor() {
        return av_buffer_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static MethodHandle av_buffer_replace$handle() {
        return av_buffer_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static MemorySegment av_buffer_replace$address() {
        return av_buffer_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static int av_buffer_replace(MemorySegment dst, MemorySegment src) {
        var mh$ = av_buffer_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_replace", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_pool_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static FunctionDescriptor av_buffer_pool_init$descriptor() {
        return av_buffer_pool_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MethodHandle av_buffer_pool_init$handle() {
        return av_buffer_pool_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MemorySegment av_buffer_pool_init$address() {
        return av_buffer_pool_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MemorySegment av_buffer_pool_init(long size, MemorySegment alloc) {
        var mh$ = av_buffer_pool_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_init", size, alloc);
            }
            return (MemorySegment)mh$.invokeExact(size, alloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_init2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_pool_init2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static FunctionDescriptor av_buffer_pool_init2$descriptor() {
        return av_buffer_pool_init2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MethodHandle av_buffer_pool_init2$handle() {
        return av_buffer_pool_init2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MemorySegment av_buffer_pool_init2$address() {
        return av_buffer_pool_init2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MemorySegment av_buffer_pool_init2(long size, MemorySegment opaque, MemorySegment alloc, MemorySegment pool_free) {
        var mh$ = av_buffer_pool_init2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_init2", size, opaque, alloc, pool_free);
            }
            return (MemorySegment)mh$.invokeExact(size, opaque, alloc, pool_free);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_uninit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_pool_uninit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_uninit$descriptor() {
        return av_buffer_pool_uninit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static MethodHandle av_buffer_pool_uninit$handle() {
        return av_buffer_pool_uninit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static MemorySegment av_buffer_pool_uninit$address() {
        return av_buffer_pool_uninit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static void av_buffer_pool_uninit(MemorySegment pool) {
        var mh$ = av_buffer_pool_uninit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_uninit", pool);
            }
            mh$.invokeExact(pool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_pool_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_get$descriptor() {
        return av_buffer_pool_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MethodHandle av_buffer_pool_get$handle() {
        return av_buffer_pool_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MemorySegment av_buffer_pool_get$address() {
        return av_buffer_pool_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MemorySegment av_buffer_pool_get(MemorySegment pool) {
        var mh$ = av_buffer_pool_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_get", pool);
            }
            return (MemorySegment)mh$.invokeExact(pool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_buffer_get_opaque {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = FFmpeg.findOrThrow("av_buffer_pool_buffer_get_opaque");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_buffer_get_opaque$descriptor() {
        return av_buffer_pool_buffer_get_opaque.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MethodHandle av_buffer_pool_buffer_get_opaque$handle() {
        return av_buffer_pool_buffer_get_opaque.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_buffer_pool_buffer_get_opaque$address() {
        return av_buffer_pool_buffer_get_opaque.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_buffer_pool_buffer_get_opaque(MemorySegment ref) {
        var mh$ = av_buffer_pool_buffer_get_opaque.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_buffer_get_opaque", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CHAN_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_NONE = -1
     * }
     */
    public static int AV_CHAN_NONE() {
        return AV_CHAN_NONE;
    }
    private static final int AV_CHAN_FRONT_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_LEFT = 0
     * }
     */
    public static int AV_CHAN_FRONT_LEFT() {
        return AV_CHAN_FRONT_LEFT;
    }
    private static final int AV_CHAN_FRONT_RIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_RIGHT = 1
     * }
     */
    public static int AV_CHAN_FRONT_RIGHT() {
        return AV_CHAN_FRONT_RIGHT;
    }
    private static final int AV_CHAN_FRONT_CENTER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_CENTER = 2
     * }
     */
    public static int AV_CHAN_FRONT_CENTER() {
        return AV_CHAN_FRONT_CENTER;
    }
    private static final int AV_CHAN_LOW_FREQUENCY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_LOW_FREQUENCY = 3
     * }
     */
    public static int AV_CHAN_LOW_FREQUENCY() {
        return AV_CHAN_LOW_FREQUENCY;
    }
    private static final int AV_CHAN_BACK_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_LEFT = 4
     * }
     */
    public static int AV_CHAN_BACK_LEFT() {
        return AV_CHAN_BACK_LEFT;
    }
    private static final int AV_CHAN_BACK_RIGHT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_RIGHT = 5
     * }
     */
    public static int AV_CHAN_BACK_RIGHT() {
        return AV_CHAN_BACK_RIGHT;
    }
    private static final int AV_CHAN_FRONT_LEFT_OF_CENTER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_LEFT_OF_CENTER = 6
     * }
     */
    public static int AV_CHAN_FRONT_LEFT_OF_CENTER() {
        return AV_CHAN_FRONT_LEFT_OF_CENTER;
    }
    private static final int AV_CHAN_FRONT_RIGHT_OF_CENTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_RIGHT_OF_CENTER = 7
     * }
     */
    public static int AV_CHAN_FRONT_RIGHT_OF_CENTER() {
        return AV_CHAN_FRONT_RIGHT_OF_CENTER;
    }
    private static final int AV_CHAN_BACK_CENTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_CENTER = 8
     * }
     */
    public static int AV_CHAN_BACK_CENTER() {
        return AV_CHAN_BACK_CENTER;
    }
    private static final int AV_CHAN_SIDE_LEFT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_LEFT = 9
     * }
     */
    public static int AV_CHAN_SIDE_LEFT() {
        return AV_CHAN_SIDE_LEFT;
    }
    private static final int AV_CHAN_SIDE_RIGHT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_RIGHT = 10
     * }
     */
    public static int AV_CHAN_SIDE_RIGHT() {
        return AV_CHAN_SIDE_RIGHT;
    }
    private static final int AV_CHAN_TOP_CENTER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_CENTER = 11
     * }
     */
    public static int AV_CHAN_TOP_CENTER() {
        return AV_CHAN_TOP_CENTER;
    }
    private static final int AV_CHAN_TOP_FRONT_LEFT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_LEFT = 12
     * }
     */
    public static int AV_CHAN_TOP_FRONT_LEFT() {
        return AV_CHAN_TOP_FRONT_LEFT;
    }
    private static final int AV_CHAN_TOP_FRONT_CENTER = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_CENTER = 13
     * }
     */
    public static int AV_CHAN_TOP_FRONT_CENTER() {
        return AV_CHAN_TOP_FRONT_CENTER;
    }
    private static final int AV_CHAN_TOP_FRONT_RIGHT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_RIGHT = 14
     * }
     */
    public static int AV_CHAN_TOP_FRONT_RIGHT() {
        return AV_CHAN_TOP_FRONT_RIGHT;
    }
    private static final int AV_CHAN_TOP_BACK_LEFT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_LEFT = 15
     * }
     */
    public static int AV_CHAN_TOP_BACK_LEFT() {
        return AV_CHAN_TOP_BACK_LEFT;
    }
    private static final int AV_CHAN_TOP_BACK_CENTER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_CENTER = 16
     * }
     */
    public static int AV_CHAN_TOP_BACK_CENTER() {
        return AV_CHAN_TOP_BACK_CENTER;
    }
    private static final int AV_CHAN_TOP_BACK_RIGHT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_RIGHT = 17
     * }
     */
    public static int AV_CHAN_TOP_BACK_RIGHT() {
        return AV_CHAN_TOP_BACK_RIGHT;
    }
    private static final int AV_CHAN_STEREO_LEFT = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_STEREO_LEFT = 29
     * }
     */
    public static int AV_CHAN_STEREO_LEFT() {
        return AV_CHAN_STEREO_LEFT;
    }
    private static final int AV_CHAN_STEREO_RIGHT = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_STEREO_RIGHT = 30
     * }
     */
    public static int AV_CHAN_STEREO_RIGHT() {
        return AV_CHAN_STEREO_RIGHT;
    }
    private static final int AV_CHAN_WIDE_LEFT = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_WIDE_LEFT = 31
     * }
     */
    public static int AV_CHAN_WIDE_LEFT() {
        return AV_CHAN_WIDE_LEFT;
    }
    private static final int AV_CHAN_WIDE_RIGHT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_WIDE_RIGHT = 32
     * }
     */
    public static int AV_CHAN_WIDE_RIGHT() {
        return AV_CHAN_WIDE_RIGHT;
    }
    private static final int AV_CHAN_SURROUND_DIRECT_LEFT = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SURROUND_DIRECT_LEFT = 33
     * }
     */
    public static int AV_CHAN_SURROUND_DIRECT_LEFT() {
        return AV_CHAN_SURROUND_DIRECT_LEFT;
    }
    private static final int AV_CHAN_SURROUND_DIRECT_RIGHT = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SURROUND_DIRECT_RIGHT = 34
     * }
     */
    public static int AV_CHAN_SURROUND_DIRECT_RIGHT() {
        return AV_CHAN_SURROUND_DIRECT_RIGHT;
    }
    private static final int AV_CHAN_LOW_FREQUENCY_2 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_LOW_FREQUENCY_2 = 35
     * }
     */
    public static int AV_CHAN_LOW_FREQUENCY_2() {
        return AV_CHAN_LOW_FREQUENCY_2;
    }
    private static final int AV_CHAN_TOP_SIDE_LEFT = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SIDE_LEFT = 36
     * }
     */
    public static int AV_CHAN_TOP_SIDE_LEFT() {
        return AV_CHAN_TOP_SIDE_LEFT;
    }
    private static final int AV_CHAN_TOP_SIDE_RIGHT = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SIDE_RIGHT = 37
     * }
     */
    public static int AV_CHAN_TOP_SIDE_RIGHT() {
        return AV_CHAN_TOP_SIDE_RIGHT;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_CENTER = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_CENTER = 38
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_CENTER() {
        return AV_CHAN_BOTTOM_FRONT_CENTER;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_LEFT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_LEFT = 39
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_LEFT() {
        return AV_CHAN_BOTTOM_FRONT_LEFT;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_RIGHT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_RIGHT = 40
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_RIGHT() {
        return AV_CHAN_BOTTOM_FRONT_RIGHT;
    }
    private static final int AV_CHAN_SIDE_SURROUND_LEFT = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_SURROUND_LEFT = 41
     * }
     */
    public static int AV_CHAN_SIDE_SURROUND_LEFT() {
        return AV_CHAN_SIDE_SURROUND_LEFT;
    }
    private static final int AV_CHAN_SIDE_SURROUND_RIGHT = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_SURROUND_RIGHT = 42
     * }
     */
    public static int AV_CHAN_SIDE_SURROUND_RIGHT() {
        return AV_CHAN_SIDE_SURROUND_RIGHT;
    }
    private static final int AV_CHAN_TOP_SURROUND_LEFT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SURROUND_LEFT = 43
     * }
     */
    public static int AV_CHAN_TOP_SURROUND_LEFT() {
        return AV_CHAN_TOP_SURROUND_LEFT;
    }
    private static final int AV_CHAN_TOP_SURROUND_RIGHT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SURROUND_RIGHT = 44
     * }
     */
    public static int AV_CHAN_TOP_SURROUND_RIGHT() {
        return AV_CHAN_TOP_SURROUND_RIGHT;
    }
    private static final int AV_CHAN_UNUSED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_UNUSED = 512
     * }
     */
    public static int AV_CHAN_UNUSED() {
        return AV_CHAN_UNUSED;
    }
    private static final int AV_CHAN_UNKNOWN = (int)768L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_UNKNOWN = 768
     * }
     */
    public static int AV_CHAN_UNKNOWN() {
        return AV_CHAN_UNKNOWN;
    }
    private static final int AV_CHAN_AMBISONIC_BASE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_AMBISONIC_BASE = 1024
     * }
     */
    public static int AV_CHAN_AMBISONIC_BASE() {
        return AV_CHAN_AMBISONIC_BASE;
    }
    private static final int AV_CHAN_AMBISONIC_END = (int)2047L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_AMBISONIC_END = 2047
     * }
     */
    public static int AV_CHAN_AMBISONIC_END() {
        return AV_CHAN_AMBISONIC_END;
    }
    private static final int AV_CHANNEL_ORDER_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC = 0
     * }
     */
    public static int AV_CHANNEL_ORDER_UNSPEC() {
        return AV_CHANNEL_ORDER_UNSPEC;
    }
}

